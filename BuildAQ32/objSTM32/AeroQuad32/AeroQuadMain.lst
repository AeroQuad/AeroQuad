   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"AeroQuadMain.cpp"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text._ZL6microsv,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	_ZL6microsv:
  25              	.LFB56:
  26              		.file 1 "../Libmaple/libmaple/wirish/wirish_time.h"
   1:../Libmaple/libmaple/wirish/wirish_time.h **** /******************************************************************************
   2:../Libmaple/libmaple/wirish/wirish_time.h ****  * The MIT License
   3:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   4:../Libmaple/libmaple/wirish/wirish_time.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/wirish/wirish_time.h ****  *
   6:../Libmaple/libmaple/wirish/wirish_time.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/wirish/wirish_time.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/wirish/wirish_time.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/wirish/wirish_time.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/wirish/wirish_time.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/wirish/wirish_time.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/wirish/wirish_time.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  14:../Libmaple/libmaple/wirish/wirish_time.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/wirish/wirish_time.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/wirish/wirish_time.h ****  *
  17:../Libmaple/libmaple/wirish/wirish_time.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/wirish/wirish_time.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/wirish/wirish_time.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/wirish/wirish_time.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/wirish/wirish_time.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/wirish/wirish_time.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/wirish/wirish_time.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/wirish/wirish_time.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/wirish/wirish_time.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/wirish/wirish_time.h **** 
  27:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  28:../Libmaple/libmaple/wirish/wirish_time.h ****  * @file wirish_time.h
  29:../Libmaple/libmaple/wirish/wirish_time.h ****  * @brief Timing and delay functions.
  30:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  31:../Libmaple/libmaple/wirish/wirish_time.h **** 
  32:../Libmaple/libmaple/wirish/wirish_time.h **** #ifndef __WIRISH_TIME_H_
  33:../Libmaple/libmaple/wirish/wirish_time.h **** #define __WIRISH_TIME_H_
  34:../Libmaple/libmaple/wirish/wirish_time.h **** 
  35:../Libmaple/libmaple/wirish/wirish_time.h **** #include "libmaple.h"
  36:../Libmaple/libmaple/wirish/wirish_time.h **** #include "nvic.h"
  37:../Libmaple/libmaple/wirish/wirish_time.h **** #include "systick.h"
  38:../Libmaple/libmaple/wirish/wirish_time.h **** #include "boards.h"
  39:../Libmaple/libmaple/wirish/wirish_time.h **** 
  40:../Libmaple/libmaple/wirish/wirish_time.h **** #define US_PER_MS               1000
  41:../Libmaple/libmaple/wirish/wirish_time.h **** 
  42:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  43:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in milliseconds) since the beginning of program
  44:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution. On overflow, restarts at 0.
  45:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see micros()
  46:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  47:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 millis(void) {
  48:../Libmaple/libmaple/wirish/wirish_time.h ****     return systick_uptime();
  49:../Libmaple/libmaple/wirish/wirish_time.h **** }
  50:../Libmaple/libmaple/wirish/wirish_time.h **** 
  51:../Libmaple/libmaple/wirish/wirish_time.h **** /**
  52:../Libmaple/libmaple/wirish/wirish_time.h ****  * Returns time (in microseconds) since the beginning of program
  53:../Libmaple/libmaple/wirish/wirish_time.h ****  * execution.  On overflow, restarts at 0.
  54:../Libmaple/libmaple/wirish/wirish_time.h ****  * @see millis()
  55:../Libmaple/libmaple/wirish/wirish_time.h ****  */
  56:../Libmaple/libmaple/wirish/wirish_time.h **** static inline uint32 micros(void) {
  27              		.loc 1 56 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 30B5     		push	{r4, r5, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 12
  34              		.cfi_offset 4, -12
  35              		.cfi_offset 5, -8
  36              		.cfi_offset 14, -4
  37              	.LBB76:
  38              	.LBB77:
  39              	.LBB78:
  40              	.LBB79:
  41              		.file 2 "../Libmaple/libmaple/libmaple/systick.h"
   1:../Libmaple/libmaple/libmaple/systick.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/systick.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/systick.h ****  *
   4:../Libmaple/libmaple/libmaple/systick.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/systick.h ****  *
   6:../Libmaple/libmaple/libmaple/systick.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/systick.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/systick.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/systick.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/systick.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/systick.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/systick.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/systick.h ****  *
  14:../Libmaple/libmaple/libmaple/systick.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/systick.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/systick.h ****  *
  17:../Libmaple/libmaple/libmaple/systick.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/systick.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/systick.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/systick.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/systick.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/systick.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/systick.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/systick.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/systick.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/systick.h **** 
  27:../Libmaple/libmaple/libmaple/systick.h **** /**
  28:../Libmaple/libmaple/libmaple/systick.h ****  * @file systick.h
  29:../Libmaple/libmaple/libmaple/systick.h ****  *
  30:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Various system timer definitions
  31:../Libmaple/libmaple/libmaple/systick.h ****  */
  32:../Libmaple/libmaple/libmaple/systick.h **** 
  33:../Libmaple/libmaple/libmaple/systick.h **** #ifndef _SYSTICK_H_
  34:../Libmaple/libmaple/libmaple/systick.h **** #define _SYSTICK_H_
  35:../Libmaple/libmaple/libmaple/systick.h **** 
  36:../Libmaple/libmaple/libmaple/systick.h **** #include "libmaple_types.h"
  37:../Libmaple/libmaple/libmaple/systick.h **** #include "util.h"
  38:../Libmaple/libmaple/libmaple/systick.h **** 
  39:../Libmaple/libmaple/libmaple/systick.h **** #ifdef __cplusplus
  40:../Libmaple/libmaple/libmaple/systick.h **** extern "C"{
  41:../Libmaple/libmaple/libmaple/systick.h **** #endif
  42:../Libmaple/libmaple/libmaple/systick.h **** 
  43:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map type */
  44:../Libmaple/libmaple/libmaple/systick.h **** typedef struct systick_reg_map {
  45:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CSR;            /**< Control and status register */
  46:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 RVR;            /**< Reload value register */
  47:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CNT;            /**< Current value register ("count") */
  48:../Libmaple/libmaple/libmaple/systick.h ****     __io uint32 CVR;            /**< Calibration value register */
  49:../Libmaple/libmaple/libmaple/systick.h **** } systick_reg_map;
  50:../Libmaple/libmaple/libmaple/systick.h **** 
  51:../Libmaple/libmaple/libmaple/systick.h **** /** SysTick register map base pointer */
  52:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_BASE                    ((struct systick_reg_map*)0xE000E010)
  53:../Libmaple/libmaple/libmaple/systick.h **** 
  54:../Libmaple/libmaple/libmaple/systick.h **** /*
  55:../Libmaple/libmaple/libmaple/systick.h ****  * Register bit definitions.
  56:../Libmaple/libmaple/libmaple/systick.h ****  */
  57:../Libmaple/libmaple/libmaple/systick.h **** 
  58:../Libmaple/libmaple/libmaple/systick.h **** /* Control and status register */
  59:../Libmaple/libmaple/libmaple/systick.h **** 
  60:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_COUNTFLAG           BIT(16)
  61:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE           BIT(2)
  62:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_EXTERNAL  0
  63:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_CLKSOURCE_CORE      BIT(2)
  64:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT             BIT(1)
  65:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_PEND        BIT(1)
  66:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_TICKINT_NO_PEND     0
  67:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE              BIT(0)
  68:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_MULTISHOT    BIT(0)
  69:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CSR_ENABLE_DISABLED     0
  70:../Libmaple/libmaple/libmaple/systick.h **** 
  71:../Libmaple/libmaple/libmaple/systick.h **** /* Calibration value register */
  72:../Libmaple/libmaple/libmaple/systick.h **** 
  73:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_NOREF               BIT(31)
  74:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_SKEW                BIT(30)
  75:../Libmaple/libmaple/libmaple/systick.h **** #define SYSTICK_CVR_TENMS               0xFFFFFF
  76:../Libmaple/libmaple/libmaple/systick.h **** 
  77:../Libmaple/libmaple/libmaple/systick.h **** /** System elapsed time, in milliseconds */
  78:../Libmaple/libmaple/libmaple/systick.h **** extern volatile uint32 systick_uptime_millis;
  79:../Libmaple/libmaple/libmaple/systick.h **** 
  80:../Libmaple/libmaple/libmaple/systick.h **** /**
  81:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the system uptime, in milliseconds.
  82:../Libmaple/libmaple/libmaple/systick.h ****  */
  83:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_uptime(void) {
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  42              		.loc 2 84 0
  43 0002 0D48     		ldr	r0, .L8
  44              	.LBE79:
  45              	.LBE78:
  46              	.LBE77:
  47              	.LBB82:
  48              	.LBB83:
  85:../Libmaple/libmaple/libmaple/systick.h **** }
  86:../Libmaple/libmaple/libmaple/systick.h **** 
  87:../Libmaple/libmaple/libmaple/systick.h **** 
  88:../Libmaple/libmaple/libmaple/systick.h **** void systick_init(uint32 reload_val);
  89:../Libmaple/libmaple/libmaple/systick.h **** void systick_disable();
  90:../Libmaple/libmaple/libmaple/systick.h **** void systick_enable();
  91:../Libmaple/libmaple/libmaple/systick.h **** 
  92:../Libmaple/libmaple/libmaple/systick.h **** /**
  93:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Returns the current value of the SysTick counter.
  94:../Libmaple/libmaple/libmaple/systick.h ****  */
  95:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_get_count(void) {
  96:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CNT;
  49              		.loc 2 96 0
  50 0004 0D4D     		ldr	r5, .L8+4
  51              	.L2:
  52              	.LBE83:
  53              	.LBE82:
  54              	.LBB85:
  55              	.LBB81:
  56              	.LBB80:
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  57              		.loc 2 84 0 discriminator 1
  58 0006 0368     		ldr	r3, [r0, #0]
  59              	.LBE80:
  60              	.LBE81:
  61              	.LBE85:
  62              	.LBB86:
  63              	.LBB84:
  64              		.loc 2 96 0 discriminator 1
  65 0008 0C49     		ldr	r1, .L8+4
  66 000a AA68     		ldr	r2, [r5, #8]
  67              	.LBE84:
  68              	.LBE86:
  57:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 ms;
  58:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 cycle_cnt;
  59:../Libmaple/libmaple/wirish/wirish_time.h ****     uint32 res;
  60:../Libmaple/libmaple/wirish/wirish_time.h **** 
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
  62:../Libmaple/libmaple/wirish/wirish_time.h ****         ms = millis();
  63:../Libmaple/libmaple/wirish/wirish_time.h ****         cycle_cnt = systick_get_count();
  64:../Libmaple/libmaple/wirish/wirish_time.h ****         asm volatile("nop"); //allow interrupt to fire
  69              		.loc 1 64 0 discriminator 1
  70              	@ 64 "../Libmaple/libmaple/wirish/wirish_time.h" 1
  71 000c 00BF     		nop
  72              	@ 0 "" 2
  65:../Libmaple/libmaple/wirish/wirish_time.h ****         asm volatile("nop");
  73              		.loc 1 65 0 discriminator 1
  74              	@ 65 "../Libmaple/libmaple/wirish/wirish_time.h" 1
  75 000e 00BF     		nop
  76              	@ 0 "" 2
  77              		.thumb
  78              	.LBB87:
  79              	.LBB88:
  80              	.LBB89:
  84:../Libmaple/libmaple/libmaple/systick.h ****     return systick_uptime_millis;
  81              		.loc 2 84 0 discriminator 1
  82 0010 0468     		ldr	r4, [r0, #0]
  83              	.LBE89:
  84              	.LBE88:
  85              	.LBE87:
  61:../Libmaple/libmaple/wirish/wirish_time.h ****     do {
  86              		.loc 1 61 0 discriminator 1
  87 0012 A342     		cmp	r3, r4
  88 0014 F7D1     		bne	.L2
  89              	.LBB90:
  90              	.LBB91:
  97:../Libmaple/libmaple/libmaple/systick.h **** }
  98:../Libmaple/libmaple/libmaple/systick.h **** 
  99:../Libmaple/libmaple/libmaple/systick.h **** /**
 100:../Libmaple/libmaple/libmaple/systick.h ****  * @brief Check for underflow.
 101:../Libmaple/libmaple/libmaple/systick.h ****  *
 102:../Libmaple/libmaple/libmaple/systick.h ****  * This function returns 1 if the SysTick timer has counted to 0 since
 103:../Libmaple/libmaple/libmaple/systick.h ****  * the last time it was called.  However, any reads of any part of the
 104:../Libmaple/libmaple/libmaple/systick.h ****  * SysTick Control and Status Register SYSTICK_BASE->CSR will
 105:../Libmaple/libmaple/libmaple/systick.h ****  * interfere with this functionality.  See the ARM Cortex M3 Technical
 106:../Libmaple/libmaple/libmaple/systick.h ****  * Reference Manual for more details (e.g. Table 8-3 in revision r1p1).
 107:../Libmaple/libmaple/libmaple/systick.h ****  */
 108:../Libmaple/libmaple/libmaple/systick.h **** static inline uint32 systick_check_underflow(void) {
 109:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CSR & SYSTICK_CSR_COUNTFLAG;
  91              		.loc 2 109 0
  92 0016 0868     		ldr	r0, [r1, #0]
  93              	.LBE91:
  94              	.LBE90:
  66:../Libmaple/libmaple/wirish/wirish_time.h ****     } while (ms != millis());
  67:../Libmaple/libmaple/wirish/wirish_time.h **** 
  68:../Libmaple/libmaple/wirish/wirish_time.h ****     if(systick_check_underflow()) {
  95              		.loc 1 68 0
  96 0018 C003     		lsls	r0, r0, #15
  97 001a 01D5     		bpl	.L3
  98              	.LBB92:
  99              	.LBB93:
  96:../Libmaple/libmaple/libmaple/systick.h ****     return SYSTICK_BASE->CNT;
 100              		.loc 2 96 0
 101 001c 8A68     		ldr	r2, [r1, #8]
 102              	.LBE93:
 103              	.LBE92:
  69:../Libmaple/libmaple/wirish/wirish_time.h ****     	ms++;
 104              		.loc 1 69 0
 105 001e 0133     		adds	r3, r3, #1
 106              	.LVL0:
 107              	.L3:
  70:../Libmaple/libmaple/wirish/wirish_time.h ****     	cycle_cnt = systick_get_count();
  71:../Libmaple/libmaple/wirish/wirish_time.h ****     }
  72:../Libmaple/libmaple/wirish/wirish_time.h **** 
  73:../Libmaple/libmaple/wirish/wirish_time.h ****     /* SYSTICK_RELOAD_VAL is 1 less than the number of cycles it
  74:../Libmaple/libmaple/wirish/wirish_time.h ****        actually takes to complete a SysTick reload */
  75:../Libmaple/libmaple/wirish/wirish_time.h ****     res = (ms * US_PER_MS) +
  76:../Libmaple/libmaple/wirish/wirish_time.h ****         (SYSTICK_RELOAD_VAL + 1 - cycle_cnt) / CYCLES_PER_MICROSECOND;
 108              		.loc 1 76 0
 109 0020 C2F52432 		rsb	r2, r2, #167936
 110              	.LVL1:
 111 0024 4032     		adds	r2, r2, #64
 112 0026 A821     		movs	r1, #168
 113 0028 B2FBF1F2 		udiv	r2, r2, r1
 114              	.LBE76:
  77:../Libmaple/libmaple/wirish/wirish_time.h **** 
  78:../Libmaple/libmaple/wirish/wirish_time.h ****     return res;
  79:../Libmaple/libmaple/wirish/wirish_time.h **** }
 115              		.loc 1 79 0
 116 002c 4FF47A70 		mov	r0, #1000
 117 0030 00FB0320 		mla	r0, r0, r3, r2
 118 0034 30BD     		pop	{r4, r5, pc}
 119              	.L9:
 120 0036 00BF     		.align	2
 121              	.L8:
 122 0038 00000000 		.word	systick_uptime_millis
 123 003c 10E000E0 		.word	-536813552
 124              		.cfi_endproc
 125              	.LFE56:
 127              		.section	.text._Z9FrqChangev,"ax",%progbits
 128              		.align	1
 129              		.global	_Z9FrqChangev
 130              		.thumb
 131              		.thumb_func
 133              	_Z9FrqChangev:
 134              	.LFB170:
 135              		.file 3 "../Libraries/AQ_Receiver/Receiver_STM32PPM.h"
   1:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** /*
   2:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Copyright (c) 2012 kha.  All rights reserved.
   3:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
   4:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   STM32 PPM receiver by kha based on
   5:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   STM32 receiver class by ala42 using time input capture
   6:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   for use with AeroQuad software and Maple library
   7:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   V 1.0 Jun 14 2012
   8:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
   9:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Define the pin numbers used for the receiver in receiverPinPPM
  10:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  11:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Timer and timer channels are accessed using the Maple PIN_MAP array.
  12:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   Make sure libmaple and this receiver class are compiled using the
  13:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   same structure alignment mode. When in doubt, change the stm32_pin_info
  14:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   declaration in wirish_types.h to align the size to a multiple of 4 byte
  15:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   by adding a filler byte at the end of the structure declaration.
  16:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** */
  17:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  18:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #ifndef _AEROQUAD_RECEIVER_STM32PPM_H_
  19:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #define _AEROQUAD_RECEIVER_STM32PPM_H_
  20:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  21:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #if defined(AeroQuadSTM32)
  22:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  23:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "Receiver.h"
  24:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "wirish.h"
  25:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** #include "Receiver_PPM_common.h"
  26:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  27:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** static byte ReceiverChannelMap[PPM_CHANNELS] = {SERIAL_SUM_PPM};
  28:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  29:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** uint16 rawChannelValue[PPM_CHANNELS] =  {1500,1500,1500,1500,1500,1500,1500,1500,1500,1500};
  30:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** byte   currentChannel;
  31:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  32:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  33:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
  34:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // implementation part starts here.
  35:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  36:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** typedef struct {
  37:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev   *TimerDev;
  38:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *TimerRegs;
  39:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   __io uint32	*Timer_ccr;
  40:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16		RiseTime;
  41:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int			TimerChannel;
  42:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int			PolarityMask;
  43:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** } tFrqData;
  44:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  45:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** volatile tFrqData FrqData;
  46:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  47:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void FrqInit(int aDefault, timer_dev *aTimer, int aTimerChannel)
  48:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
  49:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
  50:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  51:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerDev     = aTimer;
  52:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
  53:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs    = timer;
  54:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  55:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
  56:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerChannel = aTimerChannel;
  57:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  58:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int TimerEnable = (1 << (4*aTimerChannel));
  59:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
  60:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  61:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(FrqData.TimerDev->clk_id);
  62:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
  63:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
  64:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
  65:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->DIER &= ~(1);
  66:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  67:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~TimerEnable; // Disable timer
  68:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
  69:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  70:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   volatile uint32 *mr;
  71:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(aTimerChannel < 2) {
  72:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR1);
  73:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } 
  74:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   else {
  75:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR2);
  76:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
  77:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
  78:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
  79:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
  82:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  83:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
  84:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
  85:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void FrqChange()
  86:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 136              		.loc 3 86 0
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 0
 139              		@ frame_needed = 0, uses_anonymous_args = 0
 140              	.LBB94:
  87:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16_t c = *(FrqData.Timer_ccr);
 141              		.loc 3 87 0
 142 0000 124B     		ldr	r3, .L15
 143 0002 9A68     		ldr	r2, [r3, #8]
 144 0004 1068     		ldr	r0, [r2, #0]
 145              	.LVL2:
  88:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint16_t diffTime = c - FrqData.RiseTime;
 146              		.loc 3 88 0
 147 0006 9A89     		ldrh	r2, [r3, #12]
 148 0008 821A     		subs	r2, r0, r2
 149 000a 92B2     		uxth	r2, r2
 150              	.LVL3:
  89:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if ((diffTime > 900) && (diffTime < 2100)) {
 151              		.loc 3 89 0
 152 000c 6FF4617C 		mvn	ip, #900
 153 0010 02EB0C01 		add	r1, r2, ip
 154 0014 40F2AE43 		movw	r3, #1198
 155 0018 89B2     		uxth	r1, r1
 156 001a 9942     		cmp	r1, r3
 157              	.LBE94:
  86:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 158              		.loc 3 86 0
 159 001c 10B5     		push	{r4, lr}
 160              	.LCFI1:
 161              		.cfi_def_cfa_offset 8
 162              		.cfi_offset 4, -8
 163              		.cfi_offset 14, -4
 164 001e 0C4B     		ldr	r3, .L15+4
 165              	.LBB95:
 166              		.loc 3 89 0
 167 0020 08D8     		bhi	.L11
  90:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     if (currentChannel < PPM_CHANNELS) {
 168              		.loc 3 90 0
 169 0022 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 170 0024 0929     		cmp	r1, #9
 171 0026 0DD8     		bhi	.L12
  91:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       rawChannelValue[currentChannel] = diffTime;
 172              		.loc 3 91 0
 173 0028 0A4C     		ldr	r4, .L15+8
 174 002a 24F81120 		strh	r2, [r4, r1, lsl #1]	@ movhi
  92:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****       currentChannel++;
 175              		.loc 3 92 0
 176 002e 0131     		adds	r1, r1, #1
 177 0030 1970     		strb	r1, [r3, #0]
 178 0032 07E0     		b	.L12
 179              	.L11:
  93:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     }
  94:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } 
  95:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   else if (diffTime > 2500) {
 180              		.loc 3 95 0
 181 0034 40F6C411 		movw	r1, #2500
 182 0038 8A42     		cmp	r2, r1
 183 003a 01D9     		bls	.L13
  96:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     currentChannel = 0;
 184              		.loc 3 96 0
 185 003c 0022     		movs	r2, #0
 186              	.LVL4:
 187 003e 00E0     		b	.L14
 188              	.LVL5:
 189              	.L13:
  97:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   } 
  98:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   else {
  99:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     // glitch; stop and wait next round
 100:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     currentChannel = PPM_CHANNELS;
 190              		.loc 3 100 0
 191 0040 0A22     		movs	r2, #10
 192              	.LVL6:
 193              	.L14:
 194 0042 1A70     		strb	r2, [r3, #0]
 195              	.L12:
 101:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 102:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.RiseTime = c;
 196              		.loc 3 102 0
 197 0044 014B     		ldr	r3, .L15
 198 0046 9881     		strh	r0, [r3, #12]	@ movhi
 199 0048 10BD     		pop	{r4, pc}
 200              	.L16:
 201 004a 00BF     		.align	2
 202              	.L15:
 203 004c 00000000 		.word	.LANCHOR0
 204 0050 00000000 		.word	.LANCHOR1
 205 0054 00000000 		.word	.LANCHOR2
 206              	.LBE95:
 207              		.cfi_endproc
 208              	.LFE170:
 210              		.section	.text.startup._Z7premainv,"ax",%progbits
 211              		.align	1
 212              		.global	_Z7premainv
 213              		.thumb
 214              		.thumb_func
 216              	_Z7premainv:
 217              	.LFB114:
 218              		.file 4 "c:/Working/Aeroquad/AeroQuad32/AeroQuadMain.cpp"
   1:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** #include <../AeroQuad/UserConfiguration.h>
   2:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** #include <SerialMapping.h>
   3:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** #include <WProgram.h>
   4:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 
   5:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** __attribute__(( constructor )) void premain() {
 219              		.loc 4 5 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 0
 222              		@ frame_needed = 0, uses_anonymous_args = 0
 223              		@ link register save eliminated.
   6:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp ****     init();
   7:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** }
 224              		.loc 4 7 0
   6:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp ****     init();
 225              		.loc 4 6 0
 226 0000 FFF7FEBF 		b	_Z4initv
 227              	.LVL7:
 228              		.cfi_endproc
 229              	.LFE114:
 231              		.section	.init_array,"aw",%init_array
 232              		.align	2
 233 0000 00000000 		.word	_Z7premainv(target1)
 234              		.section	.text._init,"ax",%progbits
 235              		.align	1
 236              		.global	_init
 237              		.thumb
 238              		.thumb_func
 240              	_init:
 241              	.LFB115:
   8:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 
   9:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** extern "C"{
  10:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp ****         void _init(){};
 242              		.loc 4 10 0
 243              		.cfi_startproc
 244              		@ args = 0, pretend = 0, frame = 0
 245              		@ frame_needed = 0, uses_anonymous_args = 0
 246              		@ link register save eliminated.
 247 0000 7047     		bx	lr
 248              		.cfi_endproc
 249              	.LFE115:
 251              		.section	.text._Z23initializeReceiverParami,"ax",%progbits
 252              		.align	1
 253              		.global	_Z23initializeReceiverParami
 254              		.thumb
 255              		.thumb_func
 257              	_Z23initializeReceiverParami:
 258              	.LFB123:
 259              		.file 5 "../Libraries/AQ_Receiver/Receiver.h"
   1:../Libraries/AQ_Receiver/Receiver.h **** /*
   2:../Libraries/AQ_Receiver/Receiver.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Receiver/Receiver.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Receiver/Receiver.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Receiver/Receiver.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Receiver/Receiver.h ****  
   7:../Libraries/AQ_Receiver/Receiver.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Receiver/Receiver.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Receiver/Receiver.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Receiver/Receiver.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Receiver/Receiver.h **** 
  12:../Libraries/AQ_Receiver/Receiver.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Receiver/Receiver.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Receiver/Receiver.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Receiver/Receiver.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Receiver/Receiver.h **** 
  17:../Libraries/AQ_Receiver/Receiver.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Receiver/Receiver.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Receiver/Receiver.h **** */
  20:../Libraries/AQ_Receiver/Receiver.h **** 
  21:../Libraries/AQ_Receiver/Receiver.h **** #ifndef _AEROQUAD_RECEIVER_H_
  22:../Libraries/AQ_Receiver/Receiver.h **** #define _AEROQUAD_RECEIVER_H_
  23:../Libraries/AQ_Receiver/Receiver.h **** 
  24:../Libraries/AQ_Receiver/Receiver.h **** #include "Arduino.h"
  25:../Libraries/AQ_Receiver/Receiver.h **** 
  26:../Libraries/AQ_Receiver/Receiver.h **** #define PWM2RAD 0.002 //  Based upon 5RAD for full stick movement, you take this times the RAD to g
  27:../Libraries/AQ_Receiver/Receiver.h **** 
  28:../Libraries/AQ_Receiver/Receiver.h **** // Receiver variables
  29:../Libraries/AQ_Receiver/Receiver.h **** #define TIMEOUT 25000
  30:../Libraries/AQ_Receiver/Receiver.h **** #define MINCOMMAND 1000
  31:../Libraries/AQ_Receiver/Receiver.h **** #define MIDCOMMAND 1500
  32:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCOMMAND 2000
  33:../Libraries/AQ_Receiver/Receiver.h **** #define MINDELTA 200
  34:../Libraries/AQ_Receiver/Receiver.h **** #define MINCHECK (MINCOMMAND + 100)
  35:../Libraries/AQ_Receiver/Receiver.h **** #define MAXCHECK (MAXCOMMAND - 100)
  36:../Libraries/AQ_Receiver/Receiver.h **** #define MINTHROTTLE (MINCOMMAND + 100)
  37:../Libraries/AQ_Receiver/Receiver.h **** #define LEVELOFF 100
  38:../Libraries/AQ_Receiver/Receiver.h **** #define MAX_NB_CHANNEL 10
  39:../Libraries/AQ_Receiver/Receiver.h **** 
  40:../Libraries/AQ_Receiver/Receiver.h **** int lastReceiverChannel = 0;
  41:../Libraries/AQ_Receiver/Receiver.h **** 
  42:../Libraries/AQ_Receiver/Receiver.h **** float receiverXmitFactor = 0.0;
  43:../Libraries/AQ_Receiver/Receiver.h **** int receiverData[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0};
  44:../Libraries/AQ_Receiver/Receiver.h **** int receiverZero[3] = {0,0,0};
  45:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommand[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0};
  46:../Libraries/AQ_Receiver/Receiver.h **** int receiverCommandSmooth[MAX_NB_CHANNEL] = {0,0,0,0,0,0,0,0,0,0,};
  47:../Libraries/AQ_Receiver/Receiver.h **** float receiverSlope[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  48:../Libraries/AQ_Receiver/Receiver.h **** float receiverOffset[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  49:../Libraries/AQ_Receiver/Receiver.h **** float receiverSmoothFactor[MAX_NB_CHANNEL] = {0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0};
  50:../Libraries/AQ_Receiver/Receiver.h **** int channelCal;
  51:../Libraries/AQ_Receiver/Receiver.h **** 
  52:../Libraries/AQ_Receiver/Receiver.h **** void initializeReceiverParam(int nbChannel = 6) {
 260              		.loc 5 52 0
 261              		.cfi_startproc
 262              		@ args = 0, pretend = 0, frame = 0
 263              		@ frame_needed = 0, uses_anonymous_args = 0
 264              	.LVL8:
 265              	.LBB96:
  53:../Libraries/AQ_Receiver/Receiver.h ****   
  54:../Libraries/AQ_Receiver/Receiver.h ****   lastReceiverChannel = nbChannel;
 266              		.loc 5 54 0
 267 0000 234B     		ldr	r3, .L28
 268              	.LBE96:
  52:../Libraries/AQ_Receiver/Receiver.h **** void initializeReceiverParam(int nbChannel = 6) {
 269              		.loc 5 52 0
 270 0002 10B5     		push	{r4, lr}
 271              	.LCFI2:
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 4, -8
 274              		.cfi_offset 14, -4
 275              	.LBB104:
 276              		.loc 5 54 0
 277 0004 1860     		str	r0, [r3, #0]
  55:../Libraries/AQ_Receiver/Receiver.h **** 
  56:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[XAXIS] = 1500;
 278              		.loc 5 56 0
 279 0006 234B     		ldr	r3, .L28+4
 280 0008 40F2DC52 		movw	r2, #1500
 281 000c 1A60     		str	r2, [r3, #0]
  57:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[YAXIS] = 1500;
 282              		.loc 5 57 0
 283 000e 5A60     		str	r2, [r3, #4]
  58:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[ZAXIS] = 1500;
 284              		.loc 5 58 0
 285 0010 9A60     		str	r2, [r3, #8]
  59:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[THROTTLE] = 1000;
 286              		.loc 5 59 0
 287 0012 4FF47A72 		mov	r2, #1000
 288 0016 DA60     		str	r2, [r3, #12]
  60:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[MODE] = 1000;
 289              		.loc 5 60 0
 290 0018 1A61     		str	r2, [r3, #16]
  61:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX1] = 1000;
 291              		.loc 5 61 0
 292 001a 5A61     		str	r2, [r3, #20]
  62:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX2] = 1000;
 293              		.loc 5 62 0
 294 001c 9A61     		str	r2, [r3, #24]
  63:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX3] = 1000;
 295              		.loc 5 63 0
 296 001e DA61     		str	r2, [r3, #28]
  64:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX4] = 1000;
 297              		.loc 5 64 0
 298 0020 1A62     		str	r2, [r3, #32]
  65:../Libraries/AQ_Receiver/Receiver.h ****   receiverCommand[AUX5] = 1000;
 299              		.loc 5 65 0
 300 0022 5A62     		str	r2, [r3, #36]
 301              	.LVL9:
 302              	.LBB97:
  66:../Libraries/AQ_Receiver/Receiver.h ****   
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  68:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = 1.0;
 303              		.loc 5 68 0
 304 0024 0121     		movs	r1, #1
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 305              		.loc 5 67 0
 306 0026 0023     		movs	r3, #0
 307              		.loc 5 68 0
 308 0028 1B4A     		ldr	r2, .L28+8
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 309              		.loc 5 67 0
 310 002a 03E0     		b	.L20
 311              	.LVL10:
 312              	.L21:
 313              		.loc 5 68 0 discriminator 2
 314 002c 42F82310 		str	r1, [r2, r3, lsl #2]
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 315              		.loc 5 67 0 discriminator 2
 316 0030 0133     		adds	r3, r3, #1
 317              	.LVL11:
 318 0032 DBB2     		uxtb	r3, r3
 319              	.LVL12:
 320              	.L20:
  67:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 321              		.loc 5 67 0 is_stmt 0 discriminator 1
 322 0034 8342     		cmp	r3, r0
 323 0036 F9DB     		blt	.L21
 324              	.LVL13:
 325              	.LBE97:
 326              	.LBB98:
  69:../Libraries/AQ_Receiver/Receiver.h ****   }
  70:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
  71:../Libraries/AQ_Receiver/Receiver.h ****     receiverZero[channel] = 1500;
 327              		.loc 5 71 0 is_stmt 1 discriminator 1
 328 0038 184B     		ldr	r3, .L28+12
 329              	.LVL14:
 330 003a 40F2DC52 		movw	r2, #1500
 331 003e 1A60     		str	r2, [r3, #0]
 332              	.LVL15:
 333 0040 5A60     		str	r2, [r3, #4]
 334              	.LVL16:
 335 0042 9A60     		str	r2, [r3, #8]
 336              	.LVL17:
 337              	.LBE98:
 338              	.LBB99:
  72:../Libraries/AQ_Receiver/Receiver.h ****   }
  73:../Libraries/AQ_Receiver/Receiver.h **** 	
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  75:../Libraries/AQ_Receiver/Receiver.h ****     receiverSlope[channel] = 1;
 339              		.loc 5 75 0 discriminator 1
 340 0044 4FF07E54 		mov	r4, #1065353216
 341              	.LBE99:
 342              	.LBB100:
  71:../Libraries/AQ_Receiver/Receiver.h ****     receiverZero[channel] = 1500;
 343              		.loc 5 71 0 discriminator 1
 344 0048 0023     		movs	r3, #0
 345              	.LBE100:
 346              	.LBB101:
 347              		.loc 5 75 0 discriminator 1
 348 004a 154A     		ldr	r2, .L28+16
 349 004c 04E0     		b	.L22
 350              	.LVL18:
 351              	.L23:
 352              		.loc 5 75 0 is_stmt 0 discriminator 2
 353 004e 02EB8301 		add	r1, r2, r3, lsl #2
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 354              		.loc 5 74 0 is_stmt 1 discriminator 2
 355 0052 0133     		adds	r3, r3, #1
 356              	.LVL19:
 357              		.loc 5 75 0 discriminator 2
 358 0054 0C60     		str	r4, [r1, #0]	@ float
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 359              		.loc 5 74 0 discriminator 2
 360 0056 DBB2     		uxtb	r3, r3
 361              	.LVL20:
 362              	.L22:
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 363              		.loc 5 74 0 is_stmt 0 discriminator 1
 364 0058 8342     		cmp	r3, r0
 365 005a F8DB     		blt	.L23
  74:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 366              		.loc 5 74 0
 367 005c 0023     		movs	r3, #0
 368              	.LVL21:
 369              	.LBE101:
 370              	.LBB102:
  76:../Libraries/AQ_Receiver/Receiver.h ****   }	
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  78:../Libraries/AQ_Receiver/Receiver.h ****     receiverOffset[channel] = 1;
 371              		.loc 5 78 0 is_stmt 1
 372 005e 114A     		ldr	r2, .L28+20
 373 0060 4FF07E54 		mov	r4, #1065353216
 374 0064 04E0     		b	.L24
 375              	.LVL22:
 376              	.L25:
 377              		.loc 5 78 0 is_stmt 0 discriminator 2
 378 0066 02EB8301 		add	r1, r2, r3, lsl #2
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 379              		.loc 5 77 0 is_stmt 1 discriminator 2
 380 006a 0133     		adds	r3, r3, #1
 381              	.LVL23:
 382              		.loc 5 78 0 discriminator 2
 383 006c 0C60     		str	r4, [r1, #0]	@ float
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 384              		.loc 5 77 0 discriminator 2
 385 006e DBB2     		uxtb	r3, r3
 386              	.LVL24:
 387              	.L24:
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 388              		.loc 5 77 0 is_stmt 0 discriminator 1
 389 0070 8342     		cmp	r3, r0
 390 0072 F8DB     		blt	.L25
  77:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 391              		.loc 5 77 0
 392 0074 0023     		movs	r3, #0
 393              	.LVL25:
 394              	.LBE102:
 395              	.LBB103:
  79:../Libraries/AQ_Receiver/Receiver.h ****   }
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
  81:../Libraries/AQ_Receiver/Receiver.h ****     receiverSmoothFactor[channel] = 1; 
 396              		.loc 5 81 0 is_stmt 1
 397 0076 0C4A     		ldr	r2, .L28+24
 398 0078 4FF07E54 		mov	r4, #1065353216
 399 007c 04E0     		b	.L26
 400              	.LVL26:
 401              	.L27:
 402              		.loc 5 81 0 is_stmt 0 discriminator 2
 403 007e 02EB8301 		add	r1, r2, r3, lsl #2
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 404              		.loc 5 80 0 is_stmt 1 discriminator 2
 405 0082 0133     		adds	r3, r3, #1
 406              	.LVL27:
 407              		.loc 5 81 0 discriminator 2
 408 0084 0C60     		str	r4, [r1, #0]	@ float
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 409              		.loc 5 80 0 discriminator 2
 410 0086 DBB2     		uxtb	r3, r3
 411              	.LVL28:
 412              	.L26:
  80:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 413              		.loc 5 80 0 is_stmt 0 discriminator 1
 414 0088 8342     		cmp	r3, r0
 415 008a F8DB     		blt	.L27
 416              	.LBE103:
 417              	.LBE104:
  82:../Libraries/AQ_Receiver/Receiver.h ****   }
  83:../Libraries/AQ_Receiver/Receiver.h **** }
 418              		.loc 5 83 0 is_stmt 1
 419 008c 10BD     		pop	{r4, pc}
 420              	.L29:
 421 008e 00BF     		.align	2
 422              	.L28:
 423 0090 00000000 		.word	.LANCHOR3
 424 0094 00000000 		.word	.LANCHOR4
 425 0098 00000000 		.word	.LANCHOR5
 426 009c 00000000 		.word	.LANCHOR6
 427 00a0 00000000 		.word	.LANCHOR7
 428 00a4 00000000 		.word	.LANCHOR8
 429 00a8 00000000 		.word	.LANCHOR9
 430              		.cfi_endproc
 431              	.LFE123:
 433              		.section	.text._Z12readReceiverv,"ax",%progbits
 434              		.align	1
 435              		.global	_Z12readReceiverv
 436              		.thumb
 437              		.thumb_func
 439              	_Z12readReceiverv:
 440              	.LFB124:
  84:../Libraries/AQ_Receiver/Receiver.h ****   
  85:../Libraries/AQ_Receiver/Receiver.h **** int getRawChannelValue(byte channel);  
  86:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver();
  87:../Libraries/AQ_Receiver/Receiver.h ****   
  88:../Libraries/AQ_Receiver/Receiver.h **** void readReceiver()
  89:../Libraries/AQ_Receiver/Receiver.h **** {
 441              		.loc 5 89 0
 442              		.cfi_startproc
 443              		@ args = 0, pretend = 0, frame = 0
 444              		@ frame_needed = 0, uses_anonymous_args = 0
 445              	.LVL29:
 446 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 447              	.LCFI3:
 448              		.cfi_def_cfa_offset 24
 449              		.cfi_offset 4, -24
 450              		.cfi_offset 5, -20
 451              		.cfi_offset 6, -16
 452              		.cfi_offset 7, -12
 453              		.cfi_offset 8, -8
 454              		.cfi_offset 14, -4
 455              	.LBB105:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 456              		.loc 5 90 0
 457 0004 0024     		movs	r4, #0
 458 0006 334E     		ldr	r6, .L37
  91:../Libraries/AQ_Receiver/Receiver.h **** 
  92:../Libraries/AQ_Receiver/Receiver.h ****     // Apply receiver calibration adjustment
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 459              		.loc 5 93 0
 460 0008 334F     		ldr	r7, .L37+4
 461              	.LBB106:
 462              	.LBB107:
 103:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 104:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 105:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void InitFrqMeasurement()
 106:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 107:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int pin = receiverPinPPM;
 108:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 109:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 110:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   currentChannel=8;
 111:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(timer_num != NULL) {
 112:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     gpio_set_mode(PIN_MAP[pin].gpio_device, PIN_MAP[pin].gpio_bit, GPIO_AF_INPUT_PD);
 113:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     FrqInit(1500, timer_num, PIN_MAP[pin].timer_channel);
 114:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 115:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   }
 116:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 117:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 118:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 119:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 120:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 121:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** ///////////////////////////////////////////////////////////////////////////////
 122:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** // interface part starts here
 123:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 124:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void initializeReceiver(int nbChannel = 8) {
 125:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   initializeReceiverParam(nbChannel);
 126:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   InitFrqMeasurement();
 127:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 128:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 129:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 130:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** int getRawChannelValue(const byte channel) {
 131:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   return rawChannelValue[ReceiverChannelMap[channel]];
 463              		.loc 3 131 0
 464 000a DFF8F080 		ldr	r8, .L37+40
 465              	.LBE107:
 466              	.LBE106:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 467              		.loc 5 90 0
 468 000e 34E0     		b	.L31
 469              	.LVL30:
 470              	.L32:
 471              	.LBB112:
 472              	.LBB108:
 473              		.loc 3 131 0 discriminator 2
 474 0010 3249     		ldr	r1, .L37+8
 475              	.LBE108:
 476              	.LBE112:
  94:../Libraries/AQ_Receiver/Receiver.h ****     // Smooth the flight control receiver inputs
  95:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommandSmooth[channel] = filterSmooth(receiverData[channel], receiverCommandSmooth[chan
 477              		.loc 5 95 0 discriminator 2
 478 0012 334D     		ldr	r5, .L37+12
 479              	.LBB113:
 480              	.LBB109:
 481              		.loc 3 131 0 discriminator 2
 482 0014 095D     		ldrb	r1, [r1, r4]	@ zero_extendqisi2
 483              	.LBE109:
 484              	.LBE113:
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 485              		.loc 5 93 0 discriminator 2
 486 0016 A300     		lsls	r3, r4, #2
 487 0018 FA18     		adds	r2, r7, r3
 488              	.LBB114:
 489              	.LBB110:
 490              		.loc 3 131 0 discriminator 2
 491 001a 38F81110 		ldrh	r1, [r8, r1, lsl #1]
 492              	.LBE110:
 493              	.LBE114:
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 494              		.loc 5 93 0 discriminator 2
 495 001e 92ED007A 		flds	s14, [r2, #0]
 496 0022 304A     		ldr	r2, .L37+16
 497              	.LBB115:
 498              	.LBB111:
 499              		.loc 3 131 0 discriminator 2
 500 0024 06EE901A 		fmsr	s13, r1	@ int
 501              	.LBE111:
 502              	.LBE115:
  93:../Libraries/AQ_Receiver/Receiver.h ****     receiverData[channel] = (receiverSlope[channel] * getRawChannelValue(channel)) + receiverOffset
 503              		.loc 5 93 0 discriminator 2
 504 0028 D218     		adds	r2, r2, r3
 505 002a D2ED007A 		flds	s15, [r2, #0]
 506 002e F8EEE66A 		fsitos	s13, s13
 507 0032 2D4A     		ldr	r2, .L37+20
 508 0034 46EE877A 		fmacs	s15, s13, s14
 509 0038 FDEEE77A 		ftosizs	s15, s15
 510 003c 17EE901A 		fmrs	r1, s15	@ int
 511 0040 42F82410 		str	r1, [r2, r4, lsl #2]
 512              		.loc 5 95 0 discriminator 2
 513 0044 294A     		ldr	r2, .L37+24
 514 0046 D318     		adds	r3, r2, r3
 515 0048 55F82420 		ldr	r2, [r5, r4, lsl #2]
 516 004c 06EE102A 		fmsr	s12, r2	@ int
 517 0050 F8EEE77A 		fsitos	s15, s15
 518 0054 B8EEC66A 		fsitos	s12, s12
 519 0058 17EE900A 		fmrs	r0, s15
 520 005c 16EE101A 		fmrs	r1, s12
 521 0060 1A68     		ldr	r2, [r3, #0]	@ float
 522 0062 FFF7FEFF 		bl	_Z12filterSmoothfff
 523              	.LVL31:
 524 0066 06EE100A 		fmsr	s12, r0
 525 006a FDEEC67A 		ftosizs	s15, s12
 526 006e 17EE901A 		fmrs	r1, s15	@ int
 527 0072 45F82410 		str	r1, [r5, r4, lsl #2]
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 528              		.loc 5 90 0 discriminator 2
 529 0076 0134     		adds	r4, r4, #1
 530              	.LVL32:
 531 0078 E4B2     		uxtb	r4, r4
 532              	.LVL33:
 533              	.L31:
  90:../Libraries/AQ_Receiver/Receiver.h ****   for(byte channel = XAXIS; channel < lastReceiverChannel; channel++) {
 534              		.loc 5 90 0 is_stmt 0 discriminator 1
 535 007a 3268     		ldr	r2, [r6, #0]
 536 007c 9442     		cmp	r4, r2
 537 007e C7DB     		blt	.L32
 538              	.LVL34:
 539              	.LBE105:
 540              	.LBB116:
  96:../Libraries/AQ_Receiver/Receiver.h ****   }
  97:../Libraries/AQ_Receiver/Receiver.h ****   
  98:../Libraries/AQ_Receiver/Receiver.h ****   // Reduce receiver commands using receiverXmitFactor and center around 1500
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 100:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = ((receiverCommandSmooth[channel] - receiverZero[channel]) * receiver
 541              		.loc 5 100 0 is_stmt 1 discriminator 1
 542 0080 1B4B     		ldr	r3, .L37+28
 543 0082 1C4D     		ldr	r5, .L37+32
 544 0084 1C48     		ldr	r0, .L37+36
 545 0086 164C     		ldr	r4, .L37+12
 546              	.LVL35:
 547 0088 93ED007A 		flds	s14, [r3, #0]
 548 008c 0023     		movs	r3, #0
 549              	.LVL36:
 550              	.L33:
 551              		.loc 5 100 0 is_stmt 0 discriminator 2
 552 008e 5E59     		ldr	r6, [r3, r5]
 553 0090 1959     		ldr	r1, [r3, r4]
 554 0092 891B     		subs	r1, r1, r6
 555 0094 06EE101A 		fmsr	s12, r1	@ int
 556 0098 F8EEC66A 		fsitos	s13, s12
 557 009c 06EE106A 		fmsr	s12, r6	@ int
 558 00a0 F8EEC67A 		fsitos	s15, s12
 559 00a4 46EE877A 		fmacs	s15, s13, s14
 560 00a8 FDEEE77A 		ftosizs	s15, s15
 561 00ac 17EE906A 		fmrs	r6, s15	@ int
 562 00b0 1E50     		str	r6, [r3, r0]
 563 00b2 0433     		adds	r3, r3, #4
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 564              		.loc 5 99 0 is_stmt 1 discriminator 2
 565 00b4 0C2B     		cmp	r3, #12
 566 00b6 EAD1     		bne	.L33
  99:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = XAXIS; channel < THROTTLE; channel++) {
 567              		.loc 5 99 0 is_stmt 0
 568 00b8 0323     		movs	r3, #3
 569              	.LBE116:
 570              	.LBB117:
 101:../Libraries/AQ_Receiver/Receiver.h ****   }	
 102:../Libraries/AQ_Receiver/Receiver.h ****   // No xmitFactor reduction applied for throttle, mode and AUX
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 104:../Libraries/AQ_Receiver/Receiver.h ****     receiverCommand[channel] = receiverCommandSmooth[channel];
 571              		.loc 5 104 0 is_stmt 1
 572 00ba 0F48     		ldr	r0, .L37+36
 573 00bc 084C     		ldr	r4, .L37+12
 574 00be 05E0     		b	.L34
 575              	.LVL37:
 576              	.L35:
 577              		.loc 5 104 0 is_stmt 0 discriminator 2
 578 00c0 54F82310 		ldr	r1, [r4, r3, lsl #2]
 579 00c4 40F82310 		str	r1, [r0, r3, lsl #2]
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 580              		.loc 5 103 0 is_stmt 1 discriminator 2
 581 00c8 0133     		adds	r3, r3, #1
 582              	.LVL38:
 583 00ca DBB2     		uxtb	r3, r3
 584              	.LVL39:
 585              	.L34:
 103:../Libraries/AQ_Receiver/Receiver.h ****   for (byte channel = THROTTLE; channel < lastReceiverChannel; channel++) {
 586              		.loc 5 103 0 is_stmt 0 discriminator 1
 587 00cc 9342     		cmp	r3, r2
 588 00ce F7DB     		blt	.L35
 589              	.LBE117:
 105:../Libraries/AQ_Receiver/Receiver.h ****   }
 106:../Libraries/AQ_Receiver/Receiver.h **** }
 590              		.loc 5 106 0 is_stmt 1
 591 00d0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 592              	.L38:
 593              		.align	2
 594              	.L37:
 595 00d4 00000000 		.word	.LANCHOR3
 596 00d8 00000000 		.word	.LANCHOR7
 597 00dc 00000000 		.word	.LANCHOR10
 598 00e0 00000000 		.word	.LANCHOR5
 599 00e4 00000000 		.word	.LANCHOR8
 600 00e8 00000000 		.word	.LANCHOR11
 601 00ec 00000000 		.word	.LANCHOR9
 602 00f0 00000000 		.word	.LANCHOR12
 603 00f4 00000000 		.word	.LANCHOR6
 604 00f8 00000000 		.word	.LANCHOR4
 605 00fc 00000000 		.word	.LANCHOR2
 606              		.cfi_endproc
 607              	.LFE124:
 609              		.section	.text._Z17getReceiverSIDatah,"ax",%progbits
 610              		.align	1
 611              		.global	_Z17getReceiverSIDatah
 612              		.thumb
 613              		.thumb_func
 615              	_Z17getReceiverSIDatah:
 616              	.LFB125:
 107:../Libraries/AQ_Receiver/Receiver.h **** 
 108:../Libraries/AQ_Receiver/Receiver.h **** 
 109:../Libraries/AQ_Receiver/Receiver.h **** void setChannelValue(byte channel,int value);
 110:../Libraries/AQ_Receiver/Receiver.h ****   
 111:../Libraries/AQ_Receiver/Receiver.h **** // return the smoothed & scaled number of radians/sec in stick movement - zero centered
 112:../Libraries/AQ_Receiver/Receiver.h **** const float getReceiverSIData(byte channel) {
 617              		.loc 5 112 0
 618              		.cfi_startproc
 619              		@ args = 0, pretend = 0, frame = 0
 620              		@ frame_needed = 0, uses_anonymous_args = 0
 621              		@ link register save eliminated.
 622              	.LVL40:
 113:../Libraries/AQ_Receiver/Receiver.h ****   return ((receiverCommand[channel] - receiverZero[channel]) * (2.5 * PWM2RAD));  // +/- 2.5RPS 50%
 623              		.loc 5 113 0
 624 0000 084B     		ldr	r3, .L40
 625 0002 53F82020 		ldr	r2, [r3, r0, lsl #2]
 626 0006 084B     		ldr	r3, .L40+4
 627 0008 53F82030 		ldr	r3, [r3, r0, lsl #2]
 628 000c D31A     		subs	r3, r2, r3
 629 000e 07EE903A 		fmsr	s15, r3	@ int
 630 0012 B8EEE77A 		fsitos	s14, s15
 114:../Libraries/AQ_Receiver/Receiver.h **** }
 631              		.loc 5 114 0
 632 0016 DFED057A 		flds	s15, .L40+8
 633 001a 67EE277A 		fmuls	s15, s14, s15
 634 001e 17EE900A 		fmrs	r0, s15
 635              	.LVL41:
 636 0022 7047     		bx	lr
 637              	.L41:
 638              		.align	2
 639              	.L40:
 640 0024 00000000 		.word	.LANCHOR4
 641 0028 00000000 		.word	.LANCHOR6
 642 002c 0BD7A33B 		.word	1000593163
 643              		.cfi_endproc
 644              	.LFE125:
 646              		.section	.text._Z9updatePIDffP7PIDdata,"ax",%progbits
 647              		.align	1
 648              		.global	_Z9updatePIDffP7PIDdata
 649              		.thumb
 650              		.thumb_func
 652              	_Z9updatePIDffP7PIDdata:
 653              	.LFB126:
 654              		.file 6 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/PID.h"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****  
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   This program is free software: you can redistribute it and/or modify 
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   it under the terms of the GNU General Public License as published by 
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   (at your option) any later version. 
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   This program is distributed in the hope that it will be useful, 
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   GNU General Public License for more details. 
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   You should have received a copy of the GNU General Public License 
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** #ifndef _AQ_PID_H_
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** #define _AQ_PID_H_
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** enum {
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   RATE_XAXIS_PID_IDX = 0,
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   RATE_YAXIS_PID_IDX,
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   ZAXIS_PID_IDX,
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_XAXIS_PID_IDX,
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_YAXIS_PID_IDX,
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   HEADING_HOLD_PID_IDX,
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_GYRO_XAXIS_PID_IDX,
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   ATTITUDE_GYRO_YAXIS_PID_IDX,
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     BARO_ALTITUDE_HOLD_PID_IDX,
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     ZDAMPENING_PID_IDX,
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   #endif
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   #if defined AltitudeHoldRangeFinder
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     SONAR_ALTITUDE_HOLD_PID_IDX,
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   #endif
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   #if defined UseGPSNavigator
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     GPSPITCH_PID_IDX,
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     GPSROLL_PID_IDX,
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     GPSYAW_PID_IDX,
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   #endif    
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   LAST_PID_IDX  // keep this definition at the end of this enum
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** };
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** //// PID Variables
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** struct PIDdata {
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float P, I, D;
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float lastError;
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   // AKA experiments with PID
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float previousPIDTime;
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float integratedError;
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** } PID[LAST_PID_IDX];
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // This struct above declares the variable PID[] to hold each of the PID values for various functio
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // The following constants are declared in AeroQuad.h
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // ROLL = 0, PITCH = 1, YAW = 2 (used for Arcobatic Mode, gyros only)
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // ROLLLEVEL = 3, PITCHLEVEL = 4, LEVELGYROROLL = 6, LEVELGYROPITCH = 7 (used for Stable Mode, acce
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // HEADING = 5 (used for heading hold)
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // ALTITUDE = 8 (used for altitude hold)
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** // ZDAMPENING = 9 (used in altitude hold to dampen vertical accelerations)
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 655              		.loc 6 66 0
 656              		.cfi_startproc
 657              		@ args = 0, pretend = 0, frame = 0
 658              		@ frame_needed = 0, uses_anonymous_args = 0
 659              		@ link register save eliminated.
 660              	.LVL42:
 661              	.LBB118:
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 662              		.loc 6 68 0
 663 0000 1F4B     		ldr	r3, .L45
 664 0002 93ED007A 		flds	s14, [r3, #0]	@ int
 665 0006 92ED046A 		flds	s12, [r2, #16]
 666 000a B8EE477A 		fuitos	s14, s14
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   if (inFlight) {
 667              		.loc 6 73 0
 668 000e 1D4B     		ldr	r3, .L45+4
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 669              		.loc 6 68 0
 670 0010 37EE466A 		fsubs	s12, s14, s12
 671 0014 DFED1C6A 		flds	s13, .L45+8
 672              	.LBE118:
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** float updatePID(float targetPosition, float currentPosition, struct PIDdata *PIDparameters) {
 673              		.loc 6 66 0
 674 0018 07EE901A 		fmsr	s15, r1
 675              	.LBB119:
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->previousPIDTime = currentTime;  // AKA PID experiments
 676              		.loc 6 70 0
 677 001c 82ED047A 		fsts	s14, [r2, #16]
 678              		.loc 6 73 0
 679 0020 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
 680              		.loc 6 71 0
 681 0022 07EE100A 		fmsr	s14, r0
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   const float deltaPIDTime = (currentTime - PIDparameters->previousPIDTime) / 1000000.0;
 682              		.loc 6 68 0
 683 0026 86EE266A 		fdivs	s12, s12, s13
 684              	.LVL43:
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float error = targetPosition - currentPosition;
 685              		.loc 6 71 0
 686 002a 77EE676A 		fsubs	s13, s14, s15
 687              	.LVL44:
 688              		.loc 6 73 0
 689 002e 33B1     		cbz	r3, .L43
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     PIDparameters->integratedError += error * deltaPIDTime;
 690              		.loc 6 74 0
 691 0030 92ED057A 		flds	s14, [r2, #20]
 692 0034 06EE867A 		fmacs	s14, s13, s12
 693 0038 82ED057A 		fsts	s14, [r2, #20]
 694 003c 01E0     		b	.L44
 695              	.L43:
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   }
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   else {
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     PIDparameters->integratedError = 0.0;
 696              		.loc 6 77 0
 697 003e 0023     		movs	r3, #0
 698 0040 5361     		str	r3, [r2, #20]	@ float
 699              	.L44:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   }
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 700              		.loc 6 79 0
 701 0042 92ED037A 		flds	s14, [r2, #12]
 702 0046 D2ED025A 		flds	s11, [r2, #8]
 703 004a 37EEC77A 		fsubs	s14, s15, s14
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   PIDparameters->lastError = currentPosition;
 704              		.loc 6 80 0
 705 004e C2ED037A 		fsts	s15, [r2, #12]
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 706              		.loc 6 79 0
 707 0052 27EE257A 		fmuls	s14, s14, s11
 708 0056 DFED0D5A 		flds	s11, .L45+12
 709 005a 26EE256A 		fmuls	s12, s12, s11
 710              	.LVL45:
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   return (PIDparameters->P * error) + (PIDparameters->I * PIDparameters->integratedError) + dTerm;
 711              		.loc 6 82 0
 712 005e D2ED057A 		flds	s15, [r2, #20]
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   float dTerm = PIDparameters->D * (currentPosition - PIDparameters->lastError) / (deltaPIDTime * 1
 713              		.loc 6 79 0
 714 0062 87EE067A 		fdivs	s14, s14, s12
 715              	.LVL46:
 716              		.loc 6 82 0
 717 0066 D2ED015A 		flds	s11, [r2, #4]
 718 006a 92ED006A 		flds	s12, [r2, #0]
 719 006e 65EEA77A 		fmuls	s15, s11, s15
 720 0072 46EE867A 		fmacs	s15, s13, s12
 721              	.LBE119:
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** }
 722              		.loc 6 83 0
 723 0076 77EE877A 		fadds	s15, s15, s14
 724 007a 17EE900A 		fmrs	r0, s15
 725              	.LVL47:
 726 007e 7047     		bx	lr
 727              	.L46:
 728              		.align	2
 729              	.L45:
 730 0080 00000000 		.word	.LANCHOR13
 731 0084 00000000 		.word	.LANCHOR14
 732 0088 00247449 		.word	1232348160
 733 008c 0000C842 		.word	1120403456
 734              		.cfi_endproc
 735              	.LFE126:
 737              		.section	.text._Z17zeroIntegralErrorv,"ax",%progbits
 738              		.align	1
 739              		.global	_Z17zeroIntegralErrorv
 740              		.thumb
 741              		.thumb_func
 743              	_Z17zeroIntegralErrorv:
 744              	.LFB127:
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** 
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() __attribute__ ((noinline));
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() {
 745              		.loc 6 86 0
 746              		.cfi_startproc
 747              		@ args = 0, pretend = 0, frame = 0
 748              		@ frame_needed = 0, uses_anonymous_args = 0
 749              		@ link register save eliminated.
 750              	.LVL48:
 751              	.LBB120:
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   for (byte axis = 0; axis <= ATTITUDE_GYRO_YAXIS_PID_IDX; axis++) {
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].previousPIDTime = currentTime;
 752              		.loc 6 89 0
 753 0000 074B     		ldr	r3, .L50
 754 0002 D3ED007A 		flds	s15, [r3, #0]	@ int
 755 0006 074B     		ldr	r3, .L50+4
 756 0008 F8EE677A 		fuitos	s15, s15
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** void zeroIntegralError() {
 757              		.loc 6 86 0
 758 000c 03F1C002 		add	r2, r3, #192
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 759              		.loc 6 88 0
 760 0010 0021     		movs	r1, #0
 761              	.LVL49:
 762              	.L48:
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****     PID[axis].integratedError = 0;
 763              		.loc 6 88 0 is_stmt 0 discriminator 2
 764 0012 1960     		str	r1, [r3, #0]	@ float
 765              		.loc 6 89 0 is_stmt 1 discriminator 2
 766 0014 43ED017A 		fsts	s15, [r3, #-4]
 767 0018 1833     		adds	r3, r3, #24
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   for (byte axis = 0; axis <= ATTITUDE_GYRO_YAXIS_PID_IDX; axis++) {
 768              		.loc 6 87 0 discriminator 2
 769 001a 9342     		cmp	r3, r2
 770 001c F9D1     		bne	.L48
 771              	.LBE120:
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h ****   }
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\PID.h **** }
 772              		.loc 6 91 0
 773 001e 7047     		bx	lr
 774              	.L51:
 775              		.align	2
 776              	.L50:
 777 0020 00000000 		.word	.LANCHOR13
 778 0024 14000000 		.word	.LANCHOR15+20
 779              		.cfi_endproc
 780              	.LFE127:
 782              		.section	.text._Z18computeFourthOrderfP15fourthOrderData,"ax",%progbits
 783              		.align	1
 784              		.global	_Z18computeFourthOrderfP15fourthOrderData
 785              		.thumb
 786              		.thumb_func
 788              	_Z18computeFourthOrderfP15fourthOrderData:
 789              	.LFB128:
 790              		.file 7 "../Libraries/AQ_Math/FourtOrderFilter.h"
   1:../Libraries/AQ_Math/FourtOrderFilter.h **** /*
   2:../Libraries/AQ_Math/FourtOrderFilter.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Math/FourtOrderFilter.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Math/FourtOrderFilter.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Math/FourtOrderFilter.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Math/FourtOrderFilter.h ****  
   7:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Math/FourtOrderFilter.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Math/FourtOrderFilter.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Math/FourtOrderFilter.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  12:../Libraries/AQ_Math/FourtOrderFilter.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Math/FourtOrderFilter.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Math/FourtOrderFilter.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Math/FourtOrderFilter.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  17:../Libraries/AQ_Math/FourtOrderFilter.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Math/FourtOrderFilter.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Math/FourtOrderFilter.h **** */
  20:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  21:../Libraries/AQ_Math/FourtOrderFilter.h **** #ifndef _AQ_FOURTH_ORDER_FILTER_H_
  22:../Libraries/AQ_Math/FourtOrderFilter.h **** #define _AQ_FOURTH_ORDER_FILTER_H_
  23:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  24:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  25:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  26:../Libraries/AQ_Math/FourtOrderFilter.h **** //
  27:../Libraries/AQ_Math/FourtOrderFilter.h **** ////////////////////////////////////////////////////////////////////////////////
  28:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  29:../Libraries/AQ_Math/FourtOrderFilter.h **** #include <GlobalDefined.h>
  30:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  31:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  32:../Libraries/AQ_Math/FourtOrderFilter.h **** struct fourthOrderData
  33:../Libraries/AQ_Math/FourtOrderFilter.h **** {
  34:../Libraries/AQ_Math/FourtOrderFilter.h ****   float  inputTm1,  inputTm2,  inputTm3,  inputTm4;
  35:../Libraries/AQ_Math/FourtOrderFilter.h ****   float outputTm1, outputTm2, outputTm3, outputTm4;
  36:../Libraries/AQ_Math/FourtOrderFilter.h **** } fourthOrder[4];
  37:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  38:../Libraries/AQ_Math/FourtOrderFilter.h **** float computeFourthOrder(float currentInput, struct fourthOrderData *filterParameters)
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 791              		.loc 7 39 0
 792              		.cfi_startproc
 793              		@ args = 0, pretend = 0, frame = 0
 794              		@ frame_needed = 0, uses_anonymous_args = 0
 795              		@ link register save eliminated.
 796              	.LVL50:
 797              	.LBB121:
  40:../Libraries/AQ_Math/FourtOrderFilter.h ****   // cheby2(4,60,12.5/50)
  41:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b0  0.001893594048567
  42:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b1 -0.002220262954039
  43:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b2  0.003389066536478
  44:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b3 -0.002220262954039
  45:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _b4  0.001893594048567
  46:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  47:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a1 -3.362256889209355
  48:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a2  4.282608240117919
  49:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a3 -2.444765517272841
  50:../Libraries/AQ_Math/FourtOrderFilter.h ****   #define _a4  0.527149895089809
  51:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  52:../Libraries/AQ_Math/FourtOrderFilter.h ****   float output;
  53:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  54:../Libraries/AQ_Math/FourtOrderFilter.h ****   output = _b0 * currentInput                + 
  55:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b1 * filterParameters->inputTm1  + 
  56:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b2 * filterParameters->inputTm2  +
  57:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b3 * filterParameters->inputTm3  +
  58:../Libraries/AQ_Math/FourtOrderFilter.h ****            _b4 * filterParameters->inputTm4  -
  59:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a1 * filterParameters->outputTm1 -
  60:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a2 * filterParameters->outputTm2 -
  61:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a3 * filterParameters->outputTm3 -
  62:../Libraries/AQ_Math/FourtOrderFilter.h ****            _a4 * filterParameters->outputTm4;
 798              		.loc 7 62 0
 799 0000 91ED005A 		flds	s10, [r1, #0]
 800 0004 9FED203A 		flds	s6, .L53
 801              	.LBE121:
  39:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 802              		.loc 7 39 0
 803 0008 05EE900A 		fmsr	s11, r0
 804              	.LBB122:
 805              		.loc 7 62 0
 806 000c DFED1F3A 		flds	s7, .L53+4
 807 0010 65EE037A 		fmuls	s15, s10, s6
 808 0014 45EEA37A 		fmacs	s15, s11, s7
 809 0018 D1ED014A 		flds	s9, [r1, #4]
 810 001c DFED1C2A 		flds	s5, .L53+8
 811 0020 44EEA27A 		fmacs	s15, s9, s5
 812 0024 91ED024A 		flds	s8, [r1, #8]
 813 0028 44EE037A 		fmacs	s15, s8, s6
 814 002c 91ED033A 		flds	s6, [r1, #12]
 815 0030 43EE237A 		fmacs	s15, s6, s7
 816 0034 91ED047A 		flds	s14, [r1, #16]
 817 0038 DFED163A 		flds	s7, .L53+12
 818 003c 47EE237A 		fmacs	s15, s14, s7
 819 0040 D1ED056A 		flds	s13, [r1, #20]
 820 0044 DFED143A 		flds	s7, .L53+16
 821 0048 46EEE37A 		fnmacs	s15, s13, s7
 822 004c 91ED066A 		flds	s12, [r1, #24]
 823 0050 DFED123A 		flds	s7, .L53+20
 824 0054 46EE237A 		fmacs	s15, s12, s7
 825 0058 91ED073A 		flds	s6, [r1, #28]
 826 005c DFED103A 		flds	s7, .L53+24
 827 0060 43EE637A 		fnmacs	s15, s6, s7
 828              	.LVL51:
  63:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
  67:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm1 = currentInput;
 829              		.loc 7 67 0
 830 0064 0860     		str	r0, [r1, #0]	@ float
  64:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm4 = filterParameters->inputTm3;
 831              		.loc 7 64 0
 832 0066 81ED034A 		fsts	s8, [r1, #12]
  65:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm3 = filterParameters->inputTm2;
 833              		.loc 7 65 0
 834 006a C1ED024A 		fsts	s9, [r1, #8]
  66:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->inputTm2 = filterParameters->inputTm1;
 835              		.loc 7 66 0
 836 006e 81ED015A 		fsts	s10, [r1, #4]
  68:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  69:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm4 = filterParameters->outputTm3;
 837              		.loc 7 69 0
 838 0072 81ED076A 		fsts	s12, [r1, #28]
  70:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm3 = filterParameters->outputTm2;
 839              		.loc 7 70 0
 840 0076 C1ED066A 		fsts	s13, [r1, #24]
  71:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm2 = filterParameters->outputTm1;
 841              		.loc 7 71 0
 842 007a 81ED057A 		fsts	s14, [r1, #20]
  72:../Libraries/AQ_Math/FourtOrderFilter.h ****   filterParameters->outputTm1 = output;
 843              		.loc 7 72 0
 844 007e C1ED047A 		fsts	s15, [r1, #16]
 845              	.LBE122:
  73:../Libraries/AQ_Math/FourtOrderFilter.h ****     
  74:../Libraries/AQ_Math/FourtOrderFilter.h ****   return output;
  75:../Libraries/AQ_Math/FourtOrderFilter.h **** }
 846              		.loc 7 75 0
 847 0082 17EE900A 		fmrs	r0, s15
 848              	.LVL52:
 849 0086 7047     		bx	lr
 850              	.L54:
 851              		.align	2
 852              	.L53:
 853 0088 D58111BB 		.word	-1156480555
 854 008c 7932F83A 		.word	989344377
 855 0090 1A1B5E3B 		.word	996023066
 856 0094 382F5740 		.word	1079455544
 857 0098 200B8940 		.word	1082723104
 858 009c 0A771C40 		.word	1075607306
 859 00a0 4CF3063F 		.word	1057420108
 860              		.cfi_endproc
 861              	.LFE128:
 863              		.section	.text._Z16setupFourthOrderv,"ax",%progbits
 864              		.align	1
 865              		.global	_Z16setupFourthOrderv
 866              		.thumb
 867              		.thumb_func
 869              	_Z16setupFourthOrderv:
 870              	.LFB129:
  76:../Libraries/AQ_Math/FourtOrderFilter.h **** 
  77:../Libraries/AQ_Math/FourtOrderFilter.h **** void setupFourthOrder(void)
  78:../Libraries/AQ_Math/FourtOrderFilter.h **** {
 871              		.loc 7 78 0
 872              		.cfi_startproc
 873              		@ args = 0, pretend = 0, frame = 0
 874              		@ frame_needed = 0, uses_anonymous_args = 0
 875              		@ link register save eliminated.
  79:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm1 = 0.0;
 876              		.loc 7 79 0
 877 0000 0D4B     		ldr	r3, .L56
 878 0002 0022     		movs	r2, #0
 879 0004 1A60     		str	r2, [r3, #0]	@ float
  80:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm2 = 0.0;
 880              		.loc 7 80 0
 881 0006 5A60     		str	r2, [r3, #4]	@ float
  81:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm3 = 0.0;
 882              		.loc 7 81 0
 883 0008 9A60     		str	r2, [r3, #8]	@ float
  82:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].inputTm4 = 0.0;
 884              		.loc 7 82 0
 885 000a DA60     		str	r2, [r3, #12]	@ float
  83:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  84:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm1 = 0.0;
 886              		.loc 7 84 0
 887 000c 1A61     		str	r2, [r3, #16]	@ float
  85:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm2 = 0.0;
 888              		.loc 7 85 0
 889 000e 5A61     		str	r2, [r3, #20]	@ float
  86:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm3 = 0.0;
 890              		.loc 7 86 0
 891 0010 9A61     		str	r2, [r3, #24]	@ float
  87:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[XAXIS].outputTm4 = 0.0;
 892              		.loc 7 87 0
 893 0012 DA61     		str	r2, [r3, #28]	@ float
  88:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  89:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
  90:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm1 = 0.0;
 894              		.loc 7 90 0
 895 0014 1A62     		str	r2, [r3, #32]	@ float
  91:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm2 = 0.0;
 896              		.loc 7 91 0
 897 0016 5A62     		str	r2, [r3, #36]	@ float
  92:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm3 = 0.0;
 898              		.loc 7 92 0
 899 0018 9A62     		str	r2, [r3, #40]	@ float
  93:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].inputTm4 = 0.0;
 900              		.loc 7 93 0
 901 001a DA62     		str	r2, [r3, #44]	@ float
  94:../Libraries/AQ_Math/FourtOrderFilter.h ****   
  95:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm1 = 0.0;
 902              		.loc 7 95 0
 903 001c 1A63     		str	r2, [r3, #48]	@ float
  96:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm2 = 0.0;
 904              		.loc 7 96 0
 905 001e 5A63     		str	r2, [r3, #52]	@ float
  97:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm3 = 0.0;
 906              		.loc 7 97 0
 907 0020 9A63     		str	r2, [r3, #56]	@ float
  98:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[YAXIS].outputTm4 = 0.0;
 908              		.loc 7 98 0
 909 0022 DA63     		str	r2, [r3, #60]	@ float
  99:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 100:../Libraries/AQ_Math/FourtOrderFilter.h ****   //////////
 101:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm1 = -9.8065;
 910              		.loc 7 101 0
 911 0024 054A     		ldr	r2, .L56+4
 912 0026 1A64     		str	r2, [r3, #64]	@ float
 102:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm2 = -9.8065;
 913              		.loc 7 102 0
 914 0028 5A64     		str	r2, [r3, #68]	@ float
 103:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm3 = -9.8065;
 915              		.loc 7 103 0
 916 002a 9A64     		str	r2, [r3, #72]	@ float
 104:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].inputTm4 = -9.8065;
 917              		.loc 7 104 0
 918 002c DA64     		str	r2, [r3, #76]	@ float
 105:../Libraries/AQ_Math/FourtOrderFilter.h ****   
 106:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm1 = -9.8065;
 919              		.loc 7 106 0
 920 002e 1A65     		str	r2, [r3, #80]	@ float
 107:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm2 = -9.8065;
 921              		.loc 7 107 0
 922 0030 5A65     		str	r2, [r3, #84]	@ float
 108:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm3 = -9.8065;
 923              		.loc 7 108 0
 924 0032 9A65     		str	r2, [r3, #88]	@ float
 109:../Libraries/AQ_Math/FourtOrderFilter.h ****   fourthOrder[ZAXIS].outputTm4 = -9.8065;
 925              		.loc 7 109 0
 926 0034 DA65     		str	r2, [r3, #92]	@ float
 927 0036 7047     		bx	lr
 928              	.L57:
 929              		.align	2
 930              	.L56:
 931 0038 00000000 		.word	.LANCHOR16
 932 003c 6DE71CC1 		.word	-1055070355
 933              		.cfi_endproc
 934              	.LFE129:
 936              		.section	.text._ZN14HardwareSPIExt4ReadEiPhi,"axG",%progbits,_ZN14HardwareSPIExt4ReadEiPhi,comdat
 937              		.align	1
 938              		.weak	_ZN14HardwareSPIExt4ReadEiPhi
 939              		.thumb
 940              		.thumb_func
 942              	_ZN14HardwareSPIExt4ReadEiPhi:
 943              	.LFB136:
 944              		.file 8 "../Libraries/AQ_SPI/HardwareSPIExt.h"
   1:../Libraries/AQ_SPI/HardwareSPIExt.h **** #ifndef _AEROQUAD_SPI_HARDWARESPIEXT_H_
   2:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define _AEROQUAD_SPI_HARDWARESPIEXT_H_
   3:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   4:../Libraries/AQ_SPI/HardwareSPIExt.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   6:../Libraries/AQ_SPI/HardwareSPIExt.h **** // helper class to extend the maple HardwareSPI class
   7:../Libraries/AQ_SPI/HardwareSPIExt.h **** // used by the MPU6000 library
   8:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
   9:../Libraries/AQ_SPI/HardwareSPIExt.h **** #include <HardwareSPI.h>
  10:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  11:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_READ_FLAG  0x80
  12:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SPI_MULTI_FLAG 0x40
  13:../Libraries/AQ_SPI/HardwareSPIExt.h **** #define SetPin digitalWrite
  14:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  15:../Libraries/AQ_SPI/HardwareSPIExt.h **** class HardwareSPIExt : public HardwareSPI {
  16:../Libraries/AQ_SPI/HardwareSPIExt.h **** public:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
  20:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  21:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  22:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetCS(int aCS)
  23:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  24:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fCS = aCS;
  25:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  26:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  27:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void SetMultiFlag() {
  28:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = SPI_MULTI_FLAG;
  29:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  30:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  31:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void begin(SPIFrequency frequency, uint32 bitOrder, uint32 mode)
  32:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
  35:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
  37:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  38:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 945              		.loc 8 39 0
 946              		.cfi_startproc
 947              		@ args = 0, pretend = 0, frame = 0
 948              		@ frame_needed = 0, uses_anonymous_args = 0
 949              	.LVL53:
 950 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 951              	.LCFI4:
 952              		.cfi_def_cfa_offset 24
 953              		.cfi_offset 3, -24
 954              		.cfi_offset 4, -20
 955              		.cfi_offset 5, -16
 956              		.cfi_offset 6, -12
 957              		.cfi_offset 7, -8
 958              		.cfi_offset 14, -4
 959              		.loc 8 39 0
 960 0002 0446     		mov	r4, r0
 961 0004 0E46     		mov	r6, r1
  40:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  41:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 962              		.loc 8 41 0
 963 0006 0079     		ldrb	r0, [r0, #4]	@ zero_extendqisi2
 964              	.LVL54:
 965 0008 0021     		movs	r1, #0
 966              	.LVL55:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 967              		.loc 8 39 0
 968 000a 1546     		mov	r5, r2
 969 000c 1F46     		mov	r7, r3
 970              		.loc 8 41 0
 971 000e FFF7FEFF 		bl	_Z12digitalWritehh
 972              	.LVL56:
  42:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | SPI_READ_FLAG | fSpiMultiFlag);
 973              		.loc 8 42 0
 974 0012 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 975 0014 66F07F06 		orn	r6, r6, #127
 976              	.LVL57:
 977 0018 46EA0301 		orr	r1, r6, r3
 978 001c 2046     		mov	r0, r4
 979 001e C9B2     		uxtb	r1, r1
 980 0020 FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 981              	.LVL58:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 982              		.loc 8 39 0
 983 0024 EE19     		adds	r6, r5, r7
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 984              		.loc 8 43 0
 985 0026 05E0     		b	.L59
 986              	.LVL59:
 987              	.L60:
  44:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			*data++ = transfer(0);
 988              		.loc 8 44 0
 989 0028 2046     		mov	r0, r4
 990 002a 0021     		movs	r1, #0
 991 002c FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 992              	.LVL60:
 993 0030 05F8010B 		strb	r0, [r5], #1
 994              	.LVL61:
 995              	.L59:
  39:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Read(int addr, unsigned char *data, int dataLen)
 996              		.loc 8 39 0 discriminator 1
 997 0034 731B     		subs	r3, r6, r5
  43:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
 998              		.loc 8 43 0 discriminator 1
 999 0036 002B     		cmp	r3, #0
 1000 0038 F6DC     		bgt	.L60
  45:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1001              		.loc 8 46 0
 1002 003a 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1003 003c 0121     		movs	r1, #1
  47:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
 1004              		.loc 8 47 0
 1005 003e BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
  46:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1006              		.loc 8 46 0
 1007 0042 FFF7FEBF 		b	_Z12digitalWritehh
 1008              	.LVL62:
 1009              		.cfi_endproc
 1010              	.LFE136:
 1012              		.section	.text._Z19MPU6000_SpiLowSpeedv,"ax",%progbits
 1013              		.align	1
 1014              		.global	_Z19MPU6000_SpiLowSpeedv
 1015              		.thumb
 1016              		.thumb_func
 1018              	_Z19MPU6000_SpiLowSpeedv:
 1019              	.LFB140:
 1020              		.file 9 "../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h"
   1:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** /*
   2:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
   7:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  12:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  17:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** */
  20:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  21:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // parts of the init sequence were taken from AP_InertialSensor_MPU6000.h
  22:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  23:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifndef _AEROQUAD_PLATFORM_MPU6000_H_
  24:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define _AEROQUAD_PLATFORM_MPU6000_H_
  25:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  26:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // I2C support for MPU6000/6050 is not tested yet
  27:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C
  28:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  29:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include "Arduino.h"
  30:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #include <SensorsStatus.h>
  31:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  32:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** //#define MPU6000_I2C	// insert this define before #include <Platform_MPU6000.h> when you use a I2C
  33:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  34:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // MPU 6000 registers
  35:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_WHOAMI			0x75
  36:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_SMPLRT_DIV		0x19
  37:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_CONFIG			0x1A
  38:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_CONFIG		0x1B
  39:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_CONFIG		0x1C
  40:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_EN			0x23
  41:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_PIN_CFG		0x37
  42:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_ENABLE		0x38
  43:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_INT_STATUS		0x3A
  44:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_H		0x3B
  45:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_XOUT_L		0x3C
  46:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_H		0x3D
  47:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_YOUT_L		0x3E
  48:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_H		0x3F
  49:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_ACCEL_ZOUT_L		0x40
  50:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_H		0x41
  51:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_TEMP_OUT_L		0x42
  52:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_H		0x43
  53:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_XOUT_L		0x44
  54:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_H		0x45
  55:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_YOUT_L		0x46
  56:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_H		0x47
  57:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_GYRO_ZOUT_L		0x48
  58:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_USER_CTRL		0x6A
  59:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_1		0x6B
  60:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_PWR_MGMT_2		0x6C
  61:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTH		0x72
  62:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_COUNTL		0x73
  63:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPUREG_FIFO_R_W			0x74
  64:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  65:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  66:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** // Configuration bits
  67:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_SLEEP				0x40
  68:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_H_RESET				0x80
  69:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_CLKSEL				0x07
  70:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROX	0x01
  71:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_CLK_SEL_PLLGYROZ	0x03
  72:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define MPU_EXT_SYNC_GYROX		0x02
  73:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_250DPS          0x00
  74:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_500DPS          0x08
  75:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_1000DPS         0x10
  76:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_2000DPS         0x18
  77:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_FS_MASK            0x18
  78:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_256HZ_NOLPF2  0x00
  79:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_188HZ         0x01
  80:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_98HZ          0x02
  81:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_42HZ          0x03
  82:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_20HZ          0x04
  83:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_10HZ          0x05
  84:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_5HZ           0x06
  85:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_2100HZ_NOLPF  0x07
  86:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BITS_DLPF_CFG_MASK          0x07
  87:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_ANYRD_2CLEAR    0x10
  88:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_RAW_RDY_EN			0x01
  89:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_I2C_IF_DIS          0x10
  90:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #define BIT_INT_STATUS_DATA		0x01
  91:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  92:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  93:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** typedef struct {
  94:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short x;
  95:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short y;
  96:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   short z;
  97:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } tAxis;
  98:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
  99:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** union uMPU6000 {
 100:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned char rawByte[];
 101:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned short rawWord[];
 102:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   struct {
 103:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	tAxis accel;
 104:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	short temperature;
 105:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	tAxis gyro;
 106:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   } data;
 107:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** } MPU6000;
 108:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 109:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 110:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #ifdef MPU6000_I2C
 111:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C_ADDRESS
 112:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	#define MPU6000_I2C_ADDRESS 0x68
 113:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 114:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #else
 115:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #include <HardwareSPIExt.h>
 116:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   HardwareSPIExt spiMPU6000(4);
 117:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** #endif
 118:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 119:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiLowSpeed()
 120:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1021              		.loc 9 120 0
 1022              		.cfi_startproc
 1023              		@ args = 0, pretend = 0, frame = 0
 1024              		@ frame_needed = 0, uses_anonymous_args = 0
 1025              	.LVL63:
 1026 0000 10B5     		push	{r4, lr}
 1027              	.LCFI5:
 1028              		.cfi_def_cfa_offset 8
 1029              		.cfi_offset 4, -8
 1030              		.cfi_offset 14, -4
 1031              	.LBB125:
 1032              	.LBB126:
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1033              		.loc 8 33 0
 1034 0002 084C     		ldr	r4, .L62
 1035 0004 0121     		movs	r1, #1
 1036 0006 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1037 0008 FFF7FEFF 		bl	_Z12digitalWritehh
 1038              	.LVL64:
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
 1039              		.loc 8 34 0
 1040 000c 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1041 000e 0021     		movs	r1, #0
 1042 0010 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 1043              	.LVL65:
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1044              		.loc 8 36 0
 1045 0014 2046     		mov	r0, r4
 1046 0016 0521     		movs	r1, #5
 1047 0018 0122     		movs	r2, #1
 1048 001a 0323     		movs	r3, #3
 1049              	.LBE126:
 1050              	.LBE125:
 121:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 122:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.begin(SPI_562_500KHZ, MSBFIRST, 3);
 123:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 124:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1051              		.loc 9 124 0
 1052 001c BDE81040 		pop	{r4, lr}
 1053              	.LBB128:
 1054              	.LBB127:
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1055              		.loc 8 36 0
 1056 0020 FFF7FEBF 		b	_ZN11HardwareSPI5beginE12SPIFrequencyjj
 1057              	.LVL66:
 1058              	.L63:
 1059              		.align	2
 1060              	.L62:
 1061 0024 00000000 		.word	.LANCHOR17
 1062              	.LBE127:
 1063              	.LBE128:
 1064              		.cfi_endproc
 1065              	.LFE140:
 1067              		.section	.text._Z20MPU6000_SpiHighSpeedv,"ax",%progbits
 1068              		.align	1
 1069              		.global	_Z20MPU6000_SpiHighSpeedv
 1070              		.thumb
 1071              		.thumb_func
 1073              	_Z20MPU6000_SpiHighSpeedv:
 1074              	.LFB141:
 125:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 126:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_SpiHighSpeed()
 127:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1075              		.loc 9 127 0
 1076              		.cfi_startproc
 1077              		@ args = 0, pretend = 0, frame = 0
 1078              		@ frame_needed = 0, uses_anonymous_args = 0
 1079 0000 10B5     		push	{r4, lr}
 1080              	.LCFI6:
 1081              		.cfi_def_cfa_offset 8
 1082              		.cfi_offset 4, -8
 1083              		.cfi_offset 14, -4
 128:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 129:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.end();
 1084              		.loc 9 129 0
 1085 0002 0A4C     		ldr	r4, .L65
 1086 0004 2046     		mov	r0, r4
 1087 0006 FFF7FEFF 		bl	_ZN11HardwareSPI3endEv
 1088              	.LVL67:
 1089              	.LBB131:
 1090              	.LBB132:
  33:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1091              		.loc 8 33 0
 1092 000a 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1093 000c 0121     		movs	r1, #1
 1094 000e FFF7FEFF 		bl	_Z12digitalWritehh
 1095              	.LVL68:
  34:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		pinMode(fCS, OUTPUT);
 1096              		.loc 8 34 0
 1097 0012 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1098 0014 0021     		movs	r1, #0
 1099 0016 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 1100              	.LVL69:
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1101              		.loc 8 36 0
 1102 001a 0121     		movs	r1, #1
 1103 001c 2046     		mov	r0, r4
 1104 001e 0A46     		mov	r2, r1
 1105 0020 0323     		movs	r3, #3
 1106              	.LBE132:
 1107              	.LBE131:
 130:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.begin(SPI_9MHZ, MSBFIRST, 3);
 131:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 132:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1108              		.loc 9 132 0
 1109 0022 BDE81040 		pop	{r4, lr}
 1110              	.LBB134:
 1111              	.LBB133:
  36:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		HardwareSPI::begin(frequency, bitOrder, mode);
 1112              		.loc 8 36 0
 1113 0026 FFF7FEBF 		b	_ZN11HardwareSPI5beginE12SPIFrequencyjj
 1114              	.LVL70:
 1115              	.L66:
 1116 002a 00BF     		.align	2
 1117              	.L65:
 1118 002c 00000000 		.word	.LANCHOR17
 1119              	.LBE133:
 1120              	.LBE134:
 1121              		.cfi_endproc
 1122              	.LFE141:
 1124              		.section	.text._Z16MPU6000_WriteRegih,"ax",%progbits
 1125              		.align	1
 1126              		.global	_Z16MPU6000_WriteRegih
 1127              		.thumb
 1128              		.thumb_func
 1130              	_Z16MPU6000_WriteRegih:
 1131              	.LFB142:
 133:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 134:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000_WriteReg(int addr, byte data)
 135:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1132              		.loc 9 135 0
 1133              		.cfi_startproc
 1134              		@ args = 0, pretend = 0, frame = 0
 1135              		@ frame_needed = 0, uses_anonymous_args = 0
 1136              	.LVL71:
 1137 0000 70B5     		push	{r4, r5, r6, lr}
 1138              	.LCFI7:
 1139              		.cfi_def_cfa_offset 16
 1140              		.cfi_offset 4, -16
 1141              		.cfi_offset 5, -12
 1142              		.cfi_offset 6, -8
 1143              		.cfi_offset 14, -4
 1144              	.LBB139:
 1145              	.LBB140:
 1146              	.LBB141:
  48:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  49:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	unsigned char Read(int addr)
  50:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  51:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		unsigned char data;
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
  53:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  54:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		return data;
  55:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	}
  56:../Libraries/AQ_SPI/HardwareSPIExt.h **** 
  57:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	void Write(int addr, unsigned char *data, int dataLen)
  58:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	{
  59:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 0);
 1147              		.loc 8 59 0
 1148 0002 0D4C     		ldr	r4, .L68
 1149              	.LBE141:
 1150              	.LBE140:
 1151              	.LBE139:
 1152              		.loc 9 135 0
 1153 0004 0646     		mov	r6, r0
 1154              	.LVL72:
 1155 0006 0D46     		mov	r5, r1
 1156              	.LVL73:
 1157              	.LBB144:
 1158              	.LBB143:
 1159              	.LBB142:
 1160              		.loc 8 59 0
 1161 0008 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1162              	.LVL74:
 1163 000a 0021     		movs	r1, #0
 1164              	.LVL75:
 1165 000c FFF7FEFF 		bl	_Z12digitalWritehh
 1166              	.LVL76:
  60:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		transfer(addr | fSpiMultiFlag);
 1167              		.loc 8 60 0
 1168 0010 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 1169 0012 46EA0301 		orr	r1, r6, r3
 1170 0016 2046     		mov	r0, r4
 1171 0018 C9B2     		uxtb	r1, r1
 1172 001a FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1173              	.LVL77:
  61:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		while(dataLen-- > 0) {
  62:../Libraries/AQ_SPI/HardwareSPIExt.h **** 			transfer(*data++);
 1174              		.loc 8 62 0
 1175 001e 2946     		mov	r1, r5
 1176 0020 2046     		mov	r0, r4
 1177 0022 FFF7FEFF 		bl	_ZN11HardwareSPI8transferEh
 1178              	.LVL78:
  63:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		}
  64:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetPin(fCS, 1);
 1179              		.loc 8 64 0
 1180 0026 2079     		ldrb	r0, [r4, #4]	@ zero_extendqisi2
 1181 0028 0121     		movs	r1, #1
 1182 002a FFF7FEFF 		bl	_Z12digitalWritehh
 1183              	.LVL79:
 1184              	.LBE142:
 1185              	.LBE143:
 1186              	.LBE144:
 136:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 137:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	updateRegisterI2C(MPU6000_I2C_ADDRESS, addr, data);
 138:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 139:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	spiMPU6000.Write(addr, data);
 140:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1187              		.loc 9 141 0
 1188 002e 0120     		movs	r0, #1
 142:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1189              		.loc 9 142 0
 1190 0030 BDE87040 		pop	{r4, r5, r6, lr}
 141:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1191              		.loc 9 141 0
 1192 0034 FFF7FEBF 		b	_Z5delaym
 1193              	.LVL80:
 1194              	.L69:
 1195              		.align	2
 1196              	.L68:
 1197 0038 00000000 		.word	.LANCHOR17
 1198              		.cfi_endproc
 1199              	.LFE142:
 1201              		.section	.text._Z15MPU6000_ReadRegi,"ax",%progbits
 1202              		.align	1
 1203              		.global	_Z15MPU6000_ReadRegi
 1204              		.thumb
 1205              		.thumb_func
 1207              	_Z15MPU6000_ReadRegi:
 1208              	.LFB143:
 143:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 144:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** byte MPU6000_ReadReg(int addr)
 145:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1209              		.loc 9 145 0
 1210              		.cfi_startproc
 1211              		@ args = 0, pretend = 0, frame = 8
 1212              		@ frame_needed = 0, uses_anonymous_args = 0
 1213              	.LVL81:
 1214 0000 13B5     		push	{r0, r1, r4, lr}
 1215              	.LCFI8:
 1216              		.cfi_def_cfa_offset 16
 1217              		.cfi_offset 0, -16
 1218              		.cfi_offset 1, -12
 1219              		.cfi_offset 4, -8
 1220              		.cfi_offset 14, -4
 1221              	.LBB149:
 1222              	.LBB150:
 1223              	.LBB151:
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
 1224              		.loc 8 52 0
 1225 0002 0123     		movs	r3, #1
 1226              	.LBE151:
 1227              	.LBE150:
 1228              	.LBE149:
 1229              		.loc 9 145 0
 1230 0004 0146     		mov	r1, r0
 1231              	.LVL82:
 1232              	.LBB154:
 1233              	.LBB153:
 1234              	.LBB152:
  52:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		Read(addr, &data, 1);
 1235              		.loc 8 52 0
 1236 0006 0DF10702 		add	r2, sp, #7
 1237 000a 0548     		ldr	r0, .L71
 1238              	.LVL83:
 1239 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 1240              	.LVL84:
  54:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		return data;
 1241              		.loc 8 54 0
 1242 0010 9DF80740 		ldrb	r4, [sp, #7]	@ zero_extendqisi2
 1243              	.LBE152:
 1244              	.LBE153:
 146:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 147:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	sendByteI2C(MPU6000_I2C_ADDRESS, addr);
 148:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = readByteI2C(MPU6000_I2C_ADDRESS);
 149:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 150:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	byte data = spiMPU6000.Read(addr);
 151:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 152:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(1);
 1245              		.loc 9 152 0
 1246 0014 0120     		movs	r0, #1
 1247 0016 FFF7FEFF 		bl	_Z5delaym
 1248              	.LVL85:
 1249              	.LBE154:
 153:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   return data;
 154:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1250              		.loc 9 154 0
 1251 001a 2046     		mov	r0, r4
 1252 001c 1CBD     		pop	{r2, r3, r4, pc}
 1253              	.L72:
 1254 001e 00BF     		.align	2
 1255              	.L71:
 1256 0020 00000000 		.word	.LANCHOR17
 1257              		.cfi_endproc
 1258              	.LFE143:
 1260              		.section	.text._Z24initializeMPU6000Sensorsv,"ax",%progbits
 1261              		.align	1
 1262              		.global	_Z24initializeMPU6000Sensorsv
 1263              		.thumb
 1264              		.thumb_func
 1266              	_Z24initializeMPU6000Sensorsv:
 1267              	.LFB144:
 155:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 156:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void initializeMPU6000Sensors()
 157:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1268              		.loc 9 157 0
 1269              		.cfi_startproc
 1270              		@ args = 0, pretend = 0, frame = 0
 1271              		@ frame_needed = 0, uses_anonymous_args = 0
 1272 0000 08B5     		push	{r3, lr}
 1273              	.LCFI9:
 1274              		.cfi_def_cfa_offset 8
 1275              		.cfi_offset 3, -8
 1276              		.cfi_offset 14, -4
 1277              	.LBB159:
 158:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiLowSpeed();
 1278              		.loc 9 158 0
 1279 0002 FFF7FEFF 		bl	_Z19MPU6000_SpiLowSpeedv
 1280              	.LVL86:
 159:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 160:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   unsigned char val;
 161:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 162:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   val = MPU6000_ReadReg(MPUREG_WHOAMI);
 1281              		.loc 9 162 0
 1282 0006 7520     		movs	r0, #117
 1283 0008 FFF7FEFF 		bl	_Z15MPU6000_ReadRegi
 1284              	.LVL87:
 163:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   if((val&0x7E) == 0x68) {
 1285              		.loc 9 163 0
 1286 000c 00F07E00 		and	r0, r0, #126
 1287              	.LVL88:
 1288 0010 6828     		cmp	r0, #104
 1289 0012 34D1     		bne	.L73
 1290              	.LBE159:
 1291              	.LBB160:
 1292              	.LBB161:
 164:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= GYRO_DETECTED;
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= ACCEL_DETECTED;
 1293              		.loc 9 165 0
 1294 0014 1A4B     		ldr	r3, .L75
 1295 0016 1A68     		ldr	r2, [r3, #0]
 166:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   } 
 167:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   else {
 168:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	return;
 169:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 170:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 171:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // Chip reset
 172:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_1, BIT_H_RESET);
 1296              		.loc 9 172 0
 1297 0018 8021     		movs	r1, #128
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= ACCEL_DETECTED;
 1298              		.loc 9 165 0
 1299 001a 42F00302 		orr	r2, r2, #3
 1300              		.loc 9 172 0
 1301 001e 6B20     		movs	r0, #107
 165:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 	vehicleState |= ACCEL_DETECTED;
 1302              		.loc 9 165 0
 1303 0020 1A60     		str	r2, [r3, #0]
 1304              		.loc 9 172 0
 1305 0022 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1306              	.LVL89:
 173:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   delay(100);  // Startup time delay
 1307              		.loc 9 173 0
 1308 0026 6420     		movs	r0, #100
 1309 0028 FFF7FEFF 		bl	_Z5delaym
 1310              	.LVL90:
 174:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   
 175:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifndef MPU6000_I2C
 176:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     // Disable I2C bus
 177:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000_WriteReg(MPUREG_USER_CTRL, BIT_I2C_IF_DIS);
 1311              		.loc 9 177 0
 1312 002c 6A20     		movs	r0, #106
 1313 002e 1021     		movs	r1, #16
 1314 0030 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1315              	.LVL91:
 178:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 179:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 180:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // Wake Up device and select GyroZ clock (better performance)
 181:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_1, MPU_CLK_SEL_PLLGYROZ);
 1316              		.loc 9 181 0
 1317 0034 6B20     		movs	r0, #107
 1318 0036 0321     		movs	r1, #3
 1319 0038 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1320              	.LVL92:
 182:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_PWR_MGMT_2, 0);
 1321              		.loc 9 182 0
 1322 003c 6C20     		movs	r0, #108
 1323 003e 0021     		movs	r1, #0
 1324 0040 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1325              	.LVL93:
 183:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 184:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // SAMPLE RATE
 185:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_SMPLRT_DIV,0x00);     // Sample rate = 1kHz
 1326              		.loc 9 185 0
 1327 0044 1920     		movs	r0, #25
 1328 0046 0021     		movs	r1, #0
 1329 0048 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1330              	.LVL94:
 186:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 187:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // FS & DLPF   FS=1000/s, DLPF = 42Hz (low pass filter)
 188:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_CONFIG, BITS_DLPF_CFG_42HZ);
 1331              		.loc 9 188 0
 1332 004c 1A20     		movs	r0, #26
 1333 004e 0321     		movs	r1, #3
 1334 0050 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1335              	.LVL95:
 189:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_GYRO_CONFIG,BITS_FS_1000DPS);  // Gyro scale 1000/s
 1336              		.loc 9 189 0
 1337 0054 1B20     		movs	r0, #27
 1338 0056 1021     		movs	r1, #16
 1339 0058 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1340              	.LVL96:
 190:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_ACCEL_CONFIG,0x08);   // Accel scale +-4g (4096LSB/g)
 1341              		.loc 9 190 0
 1342 005c 0821     		movs	r1, #8
 1343 005e 1C20     		movs	r0, #28
 1344 0060 FFF7FEFF 		bl	_Z16MPU6000_WriteRegih
 1345              	.LVL97:
 191:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 192:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   // switch to high clock rate
 193:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_SpiHighSpeed();
 1346              		.loc 9 193 0
 1347 0064 FFF7FEFF 		bl	_Z20MPU6000_SpiHighSpeedv
 1348              	.LVL98:
 194:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   
 195:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_INT_PIN_CFG, MPU6000_ReadReg(MPUREG_INT_PIN_CFG) | 2); // enable I2C bypa
 1349              		.loc 9 195 0
 1350 0068 3720     		movs	r0, #55
 1351 006a FFF7FEFF 		bl	_Z15MPU6000_ReadRegi
 1352              	.LVL99:
 1353 006e 40F00201 		orr	r1, r0, #2
 1354 0072 C9B2     		uxtb	r1, r1
 1355 0074 3720     		movs	r0, #55
 1356              	.LBE161:
 1357              	.LBE160:
 196:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1358              		.loc 9 196 0
 1359 0076 BDE80840 		pop	{r3, lr}
 1360              	.LBB163:
 1361              	.LBB162:
 195:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   MPU6000_WriteReg(MPUREG_INT_PIN_CFG, MPU6000_ReadReg(MPUREG_INT_PIN_CFG) | 2); // enable I2C bypa
 1362              		.loc 9 195 0
 1363 007a FFF7FEBF 		b	_Z16MPU6000_WriteRegih
 1364              	.LVL100:
 1365              	.L73:
 1366 007e 08BD     		pop	{r3, pc}
 1367              	.L76:
 1368              		.align	2
 1369              	.L75:
 1370 0080 00000000 		.word	.LANCHOR18
 1371              	.LBE162:
 1372              	.LBE163:
 1373              		.cfi_endproc
 1374              	.LFE144:
 1376              		.section	.text._Z15MPU6000SwapDataPhi,"ax",%progbits
 1377              		.align	1
 1378              		.global	_Z15MPU6000SwapDataPhi
 1379              		.thumb
 1380              		.thumb_func
 1382              	_Z15MPU6000SwapDataPhi:
 1383              	.LFB145:
 197:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 198:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 199:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void MPU6000SwapData(unsigned char *data, int datalen)
 200:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1384              		.loc 9 200 0
 1385              		.cfi_startproc
 1386              		@ args = 0, pretend = 0, frame = 0
 1387              		@ frame_needed = 0, uses_anonymous_args = 0
 1388              		@ link register save eliminated.
 1389              	.LVL101:
 1390              	.LBB164:
 201:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   datalen /= 2;
 1391              		.loc 9 201 0
 1392 0000 0223     		movs	r3, #2
 1393 0002 91FBF3F1 		sdiv	r1, r1, r3
 1394              	.LVL102:
 202:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   while(datalen--) {
 1395              		.loc 9 202 0
 1396 0006 07E0     		b	.L78
 1397              	.LVL103:
 1398              	.L79:
 1399              	.LBB165:
 203:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     unsigned char t = data[0];
 1400              		.loc 9 203 0
 1401 0008 10F8023C 		ldrb	r3, [r0, #-2]	@ zero_extendqisi2
 1402              	.LVL104:
 204:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[0] = data[1];
 1403              		.loc 9 204 0
 1404 000c 10F8012C 		ldrb	r2, [r0, #-1]	@ zero_extendqisi2
 205:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[1] = t;
 1405              		.loc 9 205 0
 1406 0010 00F8013C 		strb	r3, [r0, #-1]
 204:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data[0] = data[1];
 1407              		.loc 9 204 0
 1408 0014 00F8022C 		strb	r2, [r0, #-2]
 1409              	.LVL105:
 1410              	.L78:
 1411              	.LBE165:
 202:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   while(datalen--) {
 1412              		.loc 9 202 0 discriminator 1
 1413 0018 0139     		subs	r1, r1, #1
 1414              	.LVL106:
 1415 001a 0230     		adds	r0, r0, #2
 1416 001c 4B1C     		adds	r3, r1, #1
 1417 001e F3D1     		bne	.L79
 1418              	.LBE164:
 206:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     data += 2;
 207:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   }
 208:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1419              		.loc 9 208 0
 1420 0020 7047     		bx	lr
 1421              		.cfi_endproc
 1422              	.LFE145:
 1424              		.section	.text._Z18readMPU6000Sensorsv,"ax",%progbits
 1425              		.align	1
 1426              		.global	_Z18readMPU6000Sensorsv
 1427              		.thumb
 1428              		.thumb_func
 1430              	_Z18readMPU6000Sensorsv:
 1431              	.LFB146:
 209:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** 
 210:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** void readMPU6000Sensors()
 211:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** {
 1432              		.loc 9 211 0
 1433              		.cfi_startproc
 1434              		@ args = 0, pretend = 0, frame = 0
 1435              		@ frame_needed = 0, uses_anonymous_args = 0
 1436 0000 10B5     		push	{r4, lr}
 1437              	.LCFI10:
 1438              		.cfi_def_cfa_offset 8
 1439              		.cfi_offset 4, -8
 1440              		.cfi_offset 14, -4
 212:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #ifdef MPU6000_I2C
 213:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     sendByteI2C(MPU6000_I2C_ADDRESS, MPUREG_ACCEL_XOUT_H);
 214:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     Wire.requestFrom(MPU6000_I2C_ADDRESS, sizeof(MPU6000));
 215:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     for(byte i=0; i<sizeof(MPU6000)/sizeof(short); i++) {
 216:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****       MPU6000.rawWord[i] = readWordI2C();
 217:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     }
 218:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #else
 219:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     spiMPU6000.Read(MPUREG_ACCEL_XOUT_H, MPU6000.rawByte, sizeof(MPU6000));
 1441              		.loc 9 219 0
 1442 0002 064C     		ldr	r4, .L81
 1443 0004 0648     		ldr	r0, .L81+4
 1444 0006 3B21     		movs	r1, #59
 1445 0008 2246     		mov	r2, r4
 1446 000a 0E23     		movs	r3, #14
 1447 000c FFF7FEFF 		bl	_ZN14HardwareSPIExt4ReadEiPhi
 1448              	.LVL107:
 220:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1449              		.loc 9 220 0
 1450 0010 2046     		mov	r0, r4
 1451 0012 0E21     		movs	r1, #14
 221:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****   #endif
 222:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h **** }
 1452              		.loc 9 222 0
 1453 0014 BDE81040 		pop	{r4, lr}
 220:../Libraries/AQ_Platform_MPU6000/Platform_MPU6000.h ****     MPU6000SwapData(MPU6000.rawByte, sizeof(MPU6000));
 1454              		.loc 9 220 0
 1455 0018 FFF7FEBF 		b	_Z15MPU6000SwapDataPhi
 1456              	.LVL108:
 1457              	.L82:
 1458              		.align	2
 1459              	.L81:
 1460 001c 00000000 		.word	.LANCHOR19
 1461 0020 00000000 		.word	.LANCHOR17
 1462              		.cfi_endproc
 1463              	.LFE146:
 1465              		.section	.text._Z14initializeGyrov,"ax",%progbits
 1466              		.align	1
 1467              		.global	_Z14initializeGyrov
 1468              		.thumb
 1469              		.thumb_func
 1471              	_Z14initializeGyrov:
 1472              	.LFB147:
 1473              		.file 10 "../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h"
   1:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** /*
   2:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
   7:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  12:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  17:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** */
  20:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  21:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #ifndef _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  22:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define _AEROQUAD_GYROSCOPE_MPU6000_COMMON_H_
  23:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  24:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** int gyroRaw[3] = {0,0,0};
  25:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  26:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Platform_MPU6000.h>
  27:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #include <Gyroscope.h>
  28:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  29:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** #define GYRO_CALIBRATION_TRESHOLD 35
  30:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  31:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void initializeGyro() {
 1474              		.loc 10 31 0
 1475              		.cfi_startproc
 1476              		@ args = 0, pretend = 0, frame = 0
 1477              		@ frame_needed = 0, uses_anonymous_args = 0
 1478              		@ link register save eliminated.
 1479              	.LVL109:
 1480              	.LBB166:
  32:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   float range = 2*1000.0;
  33:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroScaleFactor = radians(range/65536.0);
 1481              		.loc 10 33 0
 1482 0000 024A     		ldr	r2, .L84
 1483 0002 034B     		ldr	r3, .L84+4
 1484 0004 1A60     		str	r2, [r3, #0]	@ float
 1485              	.LBE166:
  34:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
  36:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1486              		.loc 10 36 0
 1487              	.LBB167:
  35:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   initializeMPU6000Sensors();
 1488              		.loc 10 35 0
 1489 0006 FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 1490              	.LVL110:
 1491              	.L85:
 1492 000a 00BF     		.align	2
 1493              	.L84:
 1494 000c 58A00B3A 		.word	973840472
 1495 0010 00000000 		.word	.LANCHOR20
 1496              	.LBE167:
 1497              		.cfi_endproc
 1498              	.LFE147:
 1500              		.section	.text._Z17gyroUpdateHeadingv,"ax",%progbits
 1501              		.align	1
 1502              		.global	_Z17gyroUpdateHeadingv
 1503              		.thumb
 1504              		.thumb_func
 1506              	_Z17gyroUpdateHeadingv:
 1507              	.LFB148:
  37:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  38:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void gyroUpdateHeading()
  39:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** {
 1508              		.loc 10 39 0
 1509              		.cfi_startproc
 1510              		@ args = 0, pretend = 0, frame = 0
 1511              		@ frame_needed = 0, uses_anonymous_args = 0
 1512 0000 08B5     		push	{r3, lr}
 1513              	.LCFI11:
 1514              		.cfi_def_cfa_offset 8
 1515              		.cfi_offset 3, -8
 1516              		.cfi_offset 14, -4
 1517              	.LBB168:
  40:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   long int currentTime = micros();
 1518              		.loc 10 40 0
 1519 0002 FFF7FEFF 		bl	_ZL6microsv
 1520              	.LVL111:
  41:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   if (gyroRate[ZAXIS] > (float)radians(1.0) || gyroRate[ZAXIS] < (float)radians(-1.0)) {
 1521              		.loc 10 41 0
 1522 0006 134B     		ldr	r3, .L90
 1523 0008 DFED137A 		flds	s15, .L90+4
 1524 000c 93ED027A 		flds	s14, [r3, #8]
 1525 0010 B4EEE77A 		fcmpes	s14, s15
 1526 0014 F1EE10FA 		fmstat
 1527 0018 06DC     		bgt	.L87
 1528              		.loc 10 41 0 is_stmt 0 discriminator 1
 1529 001a DFED107A 		flds	s15, .L90+8
 1530 001e B4EEE77A 		fcmpes	s14, s15
 1531 0022 F1EE10FA 		fmstat
 1532 0026 11D5     		bpl	.L88
 1533              	.L87:
  42:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
 1534              		.loc 10 42 0 is_stmt 1
 1535 0028 0D4A     		ldr	r2, .L90+12
 1536 002a 0E4B     		ldr	r3, .L90+16
 1537 002c 1268     		ldr	r2, [r2, #0]
 1538 002e 821A     		subs	r2, r0, r2
 1539 0030 07EE902A 		fmsr	s15, r2	@ int
 1540 0034 F8EE676A 		fuitos	s13, s15
 1541 0038 DFED0B7A 		flds	s15, .L90+20
 1542 003c C6EEA76A 		fdivs	s13, s13, s15
 1543 0040 D3ED007A 		flds	s15, [r3, #0]
 1544 0044 47EE267A 		fmacs	s15, s14, s13
 1545 0048 C3ED007A 		fsts	s15, [r3, #0]
 1546              	.L88:
  43:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  44:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroLastMesuredTime = currentTime;
 1547              		.loc 10 44 0
 1548 004c 044B     		ldr	r3, .L90+12
 1549 004e 1860     		str	r0, [r3, #0]
 1550 0050 08BD     		pop	{r3, pc}
 1551              	.L91:
 1552 0052 00BF     		.align	2
 1553              	.L90:
 1554 0054 00000000 		.word	.LANCHOR21
 1555 0058 35FA8E3C 		.word	1016003125
 1556 005c 35FA8EBC 		.word	-1131480523
 1557 0060 00000000 		.word	.LANCHOR23
 1558 0064 00000000 		.word	.LANCHOR22
 1559 0068 00247449 		.word	1232348160
 1560              	.LBE168:
 1561              		.cfi_endproc
 1562              	.LFE148:
 1564              		.section	.text._Z11measureGyrov,"ax",%progbits
 1565              		.align	1
 1566              		.global	_Z11measureGyrov
 1567              		.thumb
 1568              		.thumb_func
 1570              	_Z11measureGyrov:
 1571              	.LFB149:
  45:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
  46:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  47:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyro() {
 1572              		.loc 10 47 0
 1573              		.cfi_startproc
 1574              		@ args = 0, pretend = 0, frame = 16
 1575              		@ frame_needed = 0, uses_anonymous_args = 0
 1576 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 1577              	.LCFI12:
 1578              		.cfi_def_cfa_offset 24
 1579              		.cfi_offset 0, -24
 1580              		.cfi_offset 1, -20
 1581              		.cfi_offset 2, -16
 1582              		.cfi_offset 3, -12
 1583              		.cfi_offset 4, -8
 1584              		.cfi_offset 14, -4
 1585              	.LBB169:
  48:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   readMPU6000Sensors();
 1586              		.loc 10 48 0
 1587 0002 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 1588              	.LVL112:
  49:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  50:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  51:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroRaw[XAXIS]=MPU6000.data.gyro.x)  - gyroZero[XAXIS];
 1589              		.loc 10 51 0
 1590 0006 194A     		ldr	r2, .L93
 1591 0008 1949     		ldr	r1, .L93+4
 1592 000a B2F90800 		ldrsh	r0, [r2, #8]
 1593 000e 0C68     		ldr	r4, [r1, #0]
 1594 0010 184B     		ldr	r3, .L93+8
 1595 0012 041B     		subs	r4, r0, r4
 1596 0014 1860     		str	r0, [r3, #0]
 1597 0016 06EE104A 		fmsr	s12, r4	@ int
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1598              		.loc 10 52 0
 1599 001a B2F90A00 		ldrsh	r0, [r2, #10]
 1600 001e 4C68     		ldr	r4, [r1, #4]
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1601              		.loc 10 53 0
 1602 0020 B2F90C20 		ldrsh	r2, [r2, #12]
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1603              		.loc 10 52 0
 1604 0024 5860     		str	r0, [r3, #4]
 1605 0026 201A     		subs	r0, r4, r0
 1606              		.loc 10 53 0
 1607 0028 9A60     		str	r2, [r3, #8]
  52:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1608              		.loc 10 52 0
 1609 002a 06EE900A 		fmsr	s13, r0	@ int
 1610              	.LBB170:
  54:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  55:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  56:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1611              		.loc 10 56 0
 1612 002e 124B     		ldr	r3, .L93+12
 1613              	.LBE170:
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1614              		.loc 10 53 0
 1615 0030 8968     		ldr	r1, [r1, #8]
 1616              	.LBB171:
 1617              		.loc 10 56 0
 1618 0032 D3ED007A 		flds	s15, [r3, #0]
 1619 0036 F8EEE66A 		fsitos	s13, s13
 1620 003a 104B     		ldr	r3, .L93+16
 1621 003c 66EEA76A 		fmuls	s13, s13, s15
 1622              	.LBE171:
  53:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1623              		.loc 10 53 0
 1624 0040 8A1A     		subs	r2, r1, r2
 1625              	.LVL113:
 1626              	.LBB172:
 1627              		.loc 10 56 0
 1628 0042 C3ED016A 		fsts	s13, [r3, #4]
 1629 0046 06EE902A 		fmsr	s13, r2	@ int
 1630 004a B8EEC66A 		fsitos	s12, s12
 1631 004e B8EEE67A 		fsitos	s14, s13
 1632 0052 26EE276A 		fmuls	s12, s12, s15
 1633 0056 67EE277A 		fmuls	s15, s14, s15
 1634 005a 83ED006A 		fsts	s12, [r3, #0]
 1635              	.LVL114:
 1636 005e C3ED027A 		fsts	s15, [r3, #8]
 1637              	.LVL115:
 1638              	.LBE172:
 1639              	.LBE169:
  57:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  58:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  60:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1640              		.loc 10 60 0
 1641 0062 04B0     		add	sp, sp, #16
 1642 0064 BDE81040 		pop	{r4, lr}
 1643              	.LBB173:
  59:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1644              		.loc 10 59 0
 1645 0068 FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1646              	.LVL116:
 1647              	.L94:
 1648              		.align	2
 1649              	.L93:
 1650 006c 00000000 		.word	.LANCHOR19
 1651 0070 00000000 		.word	.LANCHOR25
 1652 0074 00000000 		.word	.LANCHOR24
 1653 0078 00000000 		.word	.LANCHOR20
 1654 007c 00000000 		.word	.LANCHOR21
 1655              	.LBE173:
 1656              		.cfi_endproc
 1657              	.LFE149:
 1659              		.section	.text._Z14measureGyroSumv,"ax",%progbits
 1660              		.align	1
 1661              		.global	_Z14measureGyroSumv
 1662              		.thumb
 1663              		.thumb_func
 1665              	_Z14measureGyroSumv:
 1666              	.LFB150:
  61:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  62:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void measureGyroSum() {
 1667              		.loc 10 62 0
 1668              		.cfi_startproc
 1669              		@ args = 0, pretend = 0, frame = 0
 1670              		@ frame_needed = 0, uses_anonymous_args = 0
 1671 0000 10B5     		push	{r4, lr}
 1672              	.LCFI13:
 1673              		.cfi_def_cfa_offset 8
 1674              		.cfi_offset 4, -8
 1675              		.cfi_offset 14, -4
  63:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  64:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] += (gyroRaw[XAXIS]=MPU6000.data.gyro.x);
 1676              		.loc 10 64 0
 1677 0002 0D4B     		ldr	r3, .L96
 1678 0004 0D49     		ldr	r1, .L96+4
 1679 0006 1C68     		ldr	r4, [r3, #0]
 1680 0008 0D4A     		ldr	r2, .L96+8
 1681 000a B1F90800 		ldrsh	r0, [r1, #8]
 1682 000e 1060     		str	r0, [r2, #0]
 1683 0010 2018     		adds	r0, r4, r0
 1684 0012 1860     		str	r0, [r3, #0]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1685              		.loc 10 65 0
 1686 0014 B1F90A00 		ldrsh	r0, [r1, #10]
  66:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] += (gyroRaw[ZAXIS]=MPU6000.data.gyro.z);
 1687              		.loc 10 66 0
 1688 0018 B1F90C10 		ldrsh	r1, [r1, #12]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1689              		.loc 10 65 0
 1690 001c 5C68     		ldr	r4, [r3, #4]
 1691 001e 5060     		str	r0, [r2, #4]
 1692              		.loc 10 66 0
 1693 0020 9160     		str	r1, [r2, #8]
 1694 0022 9A68     		ldr	r2, [r3, #8]
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1695              		.loc 10 65 0
 1696 0024 2018     		adds	r0, r4, r0
 1697              		.loc 10 66 0
 1698 0026 5118     		adds	r1, r2, r1
  65:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] += (gyroRaw[YAXIS]=MPU6000.data.gyro.y);
 1699              		.loc 10 65 0
 1700 0028 5860     		str	r0, [r3, #4]
 1701              		.loc 10 66 0
 1702 002a 9960     		str	r1, [r3, #8]
  67:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  68:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount++;
 1703              		.loc 10 68 0
 1704 002c 054B     		ldr	r3, .L96+12
 1705 002e 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 1706 0030 0132     		adds	r2, r2, #1
 1707 0032 1A70     		strb	r2, [r3, #0]
 1708 0034 10BD     		pop	{r4, pc}
 1709              	.L97:
 1710 0036 00BF     		.align	2
 1711              	.L96:
 1712 0038 00000000 		.word	.LANCHOR26
 1713 003c 00000000 		.word	.LANCHOR19
 1714 0040 00000000 		.word	.LANCHOR24
 1715 0044 00000000 		.word	.LANCHOR27
 1716              		.cfi_endproc
 1717              	.LFE150:
 1719              		.section	.text._Z16evaluateGyroRatev,"ax",%progbits
 1720              		.align	1
 1721              		.global	_Z16evaluateGyroRatev
 1722              		.thumb
 1723              		.thumb_func
 1725              	_Z16evaluateGyroRatev:
 1726              	.LFB151:
  69:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
  70:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void evaluateGyroRate() {
 1727              		.loc 10 71 0
 1728              		.cfi_startproc
 1729              		@ args = 0, pretend = 0, frame = 16
 1730              		@ frame_needed = 0, uses_anonymous_args = 0
 1731 0000 30B5     		push	{r4, r5, lr}
 1732              	.LCFI14:
 1733              		.cfi_def_cfa_offset 12
 1734              		.cfi_offset 4, -12
 1735              		.cfi_offset 5, -8
 1736              		.cfi_offset 14, -4
 1737              	.LBB174:
  72:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int gyroADC[3];
  73:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[XAXIS] = (gyroSample[XAXIS] / gyroSampleCount) - gyroZero[XAXIS];
 1738              		.loc 10 73 0
 1739 0002 1D4B     		ldr	r3, .L99
 1740 0004 1D48     		ldr	r0, .L99+4
 1741 0006 1C68     		ldr	r4, [r3, #0]
 1742 0008 0178     		ldrb	r1, [r0, #0]	@ zero_extendqisi2
 1743 000a 1D4A     		ldr	r2, .L99+8
 1744 000c 94FBF1F5 		sdiv	r5, r4, r1
 1745 0010 1468     		ldr	r4, [r2, #0]
 1746 0012 2C1B     		subs	r4, r5, r4
 1747 0014 06EE104A 		fmsr	s12, r4	@ int
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1748              		.loc 10 74 0
 1749 0018 5C68     		ldr	r4, [r3, #4]
 1750 001a 94FBF1F5 		sdiv	r5, r4, r1
 1751 001e 5468     		ldr	r4, [r2, #4]
  75:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[ZAXIS] = gyroZero[ZAXIS] - (gyroSample[ZAXIS] / gyroSampleCount);
 1752              		.loc 10 75 0
 1753 0020 9268     		ldr	r2, [r2, #8]
  74:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroADC[YAXIS] = gyroZero[YAXIS] - (gyroSample[YAXIS] / gyroSampleCount);
 1754              		.loc 10 74 0
 1755 0022 641B     		subs	r4, r4, r5
 1756 0024 06EE904A 		fmsr	s13, r4	@ int
 1757              		.loc 10 75 0
 1758 0028 9C68     		ldr	r4, [r3, #8]
 1759 002a 94FBF1F1 		sdiv	r1, r4, r1
 1760 002e 511A     		subs	r1, r2, r1
  76:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  77:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[XAXIS] = 0;
 1761              		.loc 10 77 0
 1762 0030 0022     		movs	r2, #0
 1763 0032 1A60     		str	r2, [r3, #0]
  78:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[YAXIS] = 0;
 1764              		.loc 10 78 0
 1765 0034 5A60     		str	r2, [r3, #4]
  79:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSample[ZAXIS] = 0;
 1766              		.loc 10 79 0
 1767 0036 9A60     		str	r2, [r3, #8]
 1768              	.LBB175:
  80:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount = 0;
  81:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  82:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis <= ZAXIS; axis++) {
  83:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     gyroRate[axis] = gyroADC[axis] * gyroScaleFactor;
 1769              		.loc 10 83 0
 1770 0038 124B     		ldr	r3, .L99+12
 1771              	.LBE175:
  80:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroSampleCount = 0;
 1772              		.loc 10 80 0
 1773 003a 0270     		strb	r2, [r0, #0]
 1774              	.LVL117:
 1775              	.LBB176:
 1776              		.loc 10 83 0
 1777 003c D3ED007A 		flds	s15, [r3, #0]
 1778 0040 F8EEE66A 		fsitos	s13, s13
 1779 0044 104B     		ldr	r3, .L99+16
 1780 0046 66EEA76A 		fmuls	s13, s13, s15
 1781 004a B8EEC66A 		fsitos	s12, s12
 1782 004e C3ED016A 		fsts	s13, [r3, #4]
 1783 0052 06EE901A 		fmsr	s13, r1	@ int
 1784 0056 B8EEE67A 		fsitos	s14, s13
 1785 005a 26EE276A 		fmuls	s12, s12, s15
 1786 005e 67EE277A 		fmuls	s15, s14, s15
 1787              	.LBE176:
 1788              	.LBE174:
  71:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** void evaluateGyroRate() {
 1789              		.loc 10 71 0
 1790 0062 85B0     		sub	sp, sp, #20
 1791              	.LCFI15:
 1792              		.cfi_def_cfa_offset 32
 1793              	.LBB178:
 1794              	.LBB177:
 1795              		.loc 10 83 0
 1796 0064 83ED006A 		fsts	s12, [r3, #0]
 1797              	.LVL118:
 1798 0068 C3ED027A 		fsts	s15, [r3, #8]
 1799              	.LVL119:
 1800              	.LBE177:
 1801              	.LBE178:
  84:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
  85:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
  87:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1802              		.loc 10 87 0
 1803 006c 05B0     		add	sp, sp, #20
 1804 006e BDE83040 		pop	{r4, r5, lr}
 1805              	.LBB179:
  86:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   gyroUpdateHeading();
 1806              		.loc 10 86 0
 1807 0072 FFF7FEBF 		b	_Z17gyroUpdateHeadingv
 1808              	.LVL120:
 1809              	.L100:
 1810 0076 00BF     		.align	2
 1811              	.L99:
 1812 0078 00000000 		.word	.LANCHOR26
 1813 007c 00000000 		.word	.LANCHOR27
 1814 0080 00000000 		.word	.LANCHOR25
 1815 0084 00000000 		.word	.LANCHOR20
 1816 0088 00000000 		.word	.LANCHOR21
 1817              	.LBE179:
 1818              		.cfi_endproc
 1819              	.LFE151:
 1821              		.section	.text._Z13calibrateGyrov,"ax",%progbits
 1822              		.align	1
 1823              		.global	_Z13calibrateGyrov
 1824              		.thumb
 1825              		.thumb_func
 1827              	_Z13calibrateGyrov:
 1828              	.LFB152:
  88:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  89:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** boolean calibrateGyro() {
 1829              		.loc 10 90 0
 1830              		.cfi_startproc
 1831              		@ args = 0, pretend = 0, frame = 200
 1832              		@ frame_needed = 0, uses_anonymous_args = 0
 1833 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1834              	.LCFI16:
 1835              		.cfi_def_cfa_offset 24
 1836              		.cfi_offset 4, -24
 1837              		.cfi_offset 5, -20
 1838              		.cfi_offset 6, -16
 1839              		.cfi_offset 7, -12
 1840              		.cfi_offset 8, -8
 1841              		.cfi_offset 14, -4
 1842 0004 B2B0     		sub	sp, sp, #200
 1843              	.LCFI17:
 1844              		.cfi_def_cfa_offset 224
 1845              	.LBB180:
  91:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   
  92:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int findZero[FINDZERO];
  93:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   int diff = 0; 
 1846              		.loc 10 93 0
 1847 0006 32AF     		add	r7, sp, #200
 1848 0008 0025     		movs	r5, #0
 1849 000a 47F8C85D 		str	r5, [r7, #-200]!
 1850              	.LVL121:
 1851 000e 184E     		ldr	r6, .L112
 1852 0010 24E0     		b	.L102
 1853              	.LVL122:
 1854              	.L106:
 1855              	.LBB181:
 1856              	.LBB182:
 1857              	.LBB183:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
  96:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       readMPU6000Sensors();
 1858              		.loc 10 96 0
 1859 0012 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 1860              	.LVL123:
 1861 0016 01AB     		add	r3, sp, #4
  97:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       if(axis == XAXIS) {
 1862              		.loc 10 97 0
 1863 0018 B8F1000F 		cmp	r8, #0
 1864 001c 02D1     		bne	.L103
  98:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.x;
 1865              		.loc 10 98 0
 1866 001e B6F90820 		ldrsh	r2, [r6, #8]
 1867 0022 06E0     		b	.L111
 1868              	.L103:
  99:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } 
 100:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  else if(axis == YAXIS) {
 1869              		.loc 10 100 0
 1870 0024 B8F1010F 		cmp	r8, #1
 101:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.y;
 1871              		.loc 10 101 0
 1872 0028 0CBF     		ite	eq
 1873 002a B6F90A20 		ldrsheq	r2, [r6, #10]
 102:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       } 
 103:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  else {
 104:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     	findZero[i] = MPU6000.data.gyro.z;
 1874              		.loc 10 104 0
 1875 002e B6F90C20 		ldrshne	r2, [r6, #12]
 1876              	.L111:
 1877 0032 1A51     		str	r2, [r3, r4]
 105:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       }
 106:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****       delay(10);
 1878              		.loc 10 106 0
 1879 0034 0A20     		movs	r0, #10
 1880 0036 0434     		adds	r4, r4, #4
 1881 0038 FFF7FEFF 		bl	_Z5delaym
 1882              	.LVL124:
  95:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     for (int i=0; i<FINDZERO; i++) {
 1883              		.loc 10 95 0
 1884 003c C42C     		cmp	r4, #196
 1885 003e E8D1     		bne	.L106
 1886              	.LBE183:
 107:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     }
 108:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****     int tmp = findMedianIntWithDiff(findZero, FINDZERO, &diff);
 1887              		.loc 10 108 0
 1888 0040 3121     		movs	r1, #49
 1889 0042 01A8     		add	r0, sp, #4
 1890 0044 6A46     		mov	r2, sp
 1891 0046 FFF7FEFF 		bl	_Z21findMedianIntWithDiffPiiS_
 1892              	.LVL125:
 109:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	if (diff <= GYRO_CALIBRATION_TRESHOLD) { 
 1893              		.loc 10 109 0
 1894 004a 009B     		ldr	r3, [sp, #0]
 1895 004c 232B     		cmp	r3, #35
 1896 004e 09DC     		bgt	.L108
 110:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	  gyroZero[axis] = tmp;
 1897              		.loc 10 110 0
 1898 0050 084B     		ldr	r3, .L112+4
 1899 0052 43F82500 		str	r0, [r3, r5, lsl #2]
 1900 0056 0135     		adds	r5, r5, #1
 1901              	.LBE182:
  94:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 1902              		.loc 10 94 0
 1903 0058 032D     		cmp	r5, #3
 1904 005a 05D0     		beq	.L109
 1905              	.LVL126:
 1906              	.L102:
 1907              	.LBE181:
 1908              	.LBE180:
  90:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** boolean calibrateGyro() {
 1909              		.loc 10 90 0 discriminator 1
 1910 005c 0024     		movs	r4, #0
 1911 005e 5FFA85F8 		uxtb	r8, r5
 1912 0062 D6E7     		b	.L106
 1913              	.LVL127:
 1914              	.L108:
 1915              	.LBB186:
 1916              	.LBB185:
 1917              	.LBB184:
 111:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	} 
 112:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	else {
 113:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 		return false; //Calibration failed.
 1918              		.loc 10 113 0
 1919 0064 0020     		movs	r0, #0
 1920              	.LVL128:
 1921 0066 00E0     		b	.L107
 1922              	.LVL129:
 1923              	.L109:
 1924              	.LBE184:
 114:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** 	}
 115:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   }
 116:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h ****   return true;
 1925              		.loc 10 116 0
 1926 0068 0120     		movs	r0, #1
 1927              	.LVL130:
 1928              	.L107:
 1929              	.LBE185:
 1930              	.LBE186:
 117:../Libraries/AQ_Gyroscope/Gyroscope_MPU6000.h **** }
 1931              		.loc 10 117 0
 1932 006a 32B0     		add	sp, sp, #200
 1933 006c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1934              	.L113:
 1935              		.align	2
 1936              	.L112:
 1937 0070 00000000 		.word	.LANCHOR19
 1938 0074 00000000 		.word	.LANCHOR25
 1939              		.cfi_endproc
 1940              	.LFE152:
 1942              		.section	.text._Z15initializeAccelv,"ax",%progbits
 1943              		.align	1
 1944              		.global	_Z15initializeAccelv
 1945              		.thumb
 1946              		.thumb_func
 1948              	_Z15initializeAccelv:
 1949              	.LFB153:
 1950              		.file 11 "../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h"
   1:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** /*
   2:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   AeroQuad v3.0 - May 2011
   3:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   Copyright (c) 2011 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
   7:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is free software: you can redistribute it and/or modify
   8:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   it under the terms of the GNU General Public License as published by
   9:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   the Free Software Foundation, either version 3 of the License, or
  10:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   (at your option) any later version.
  11:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  12:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   This program is distributed in the hope that it will be useful,
  13:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   GNU General Public License for more details.
  16:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  17:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   You should have received a copy of the GNU General Public License
  18:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** */
  20:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  21:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #ifndef _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  22:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #define _AEROQUAD_ACCELEROMETER_MPU6000_COMMON_H_
  23:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  24:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Platform_MPU6000.h>
  25:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** #include <Accelerometer.h>
  26:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  27:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void initializeAccel() {
 1951              		.loc 11 27 0
 1952              		.cfi_startproc
 1953              		@ args = 0, pretend = 0, frame = 0
 1954              		@ frame_needed = 0, uses_anonymous_args = 0
 1955              		@ link register save eliminated.
 1956 0000 7047     		bx	lr
 1957              		.cfi_endproc
 1958              	.LFE153:
 1960              		.section	.text._Z12measureAccelv,"ax",%progbits
 1961              		.align	1
 1962              		.global	_Z12measureAccelv
 1963              		.thumb
 1964              		.thumb_func
 1966              	_Z12measureAccelv:
 1967              	.LFB154:
  28:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** //  initializeMPU6000Sensors();
  29:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
  30:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  31:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  32:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccel() {
 1968              		.loc 11 32 0
 1969              		.cfi_startproc
 1970              		@ args = 0, pretend = 0, frame = 0
 1971              		@ frame_needed = 0, uses_anonymous_args = 0
 1972              		.loc 11 32 0
 1973 0000 10B5     		push	{r4, lr}
 1974              	.LCFI18:
 1975              		.cfi_def_cfa_offset 8
 1976              		.cfi_offset 4, -8
 1977              		.cfi_offset 14, -4
  33:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   readMPU6000Sensors();
 1978              		.loc 11 33 0
 1979 0002 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 1980              	.LVL131:
  34:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 1981              		.loc 11 35 0
 1982 0006 1748     		ldr	r0, .L116
 1983 0008 1749     		ldr	r1, .L116+4
 1984 000a B0F90020 		ldrsh	r2, [r0, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 1985              		.loc 11 36 0
 1986 000e B0F90240 		ldrsh	r4, [r0, #2]
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 1987              		.loc 11 35 0
 1988 0012 164B     		ldr	r3, .L116+8
  37:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[ZAXIS] = MPU6000.data.accel.z * accelScaleFactor[ZAXIS] + runTimeAccelBias[ZAXIS];
 1989              		.loc 11 37 0
 1990 0014 B0F90400 		ldrsh	r0, [r0, #4]
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 1991              		.loc 11 35 0
 1992 0018 06EE902A 		fmsr	s13, r2	@ int
 1993 001c 144A     		ldr	r2, .L116+12
 1994 001e F8EEE66A 		fsitos	s13, s13
 1995 0022 91ED007A 		flds	s14, [r1, #0]
 1996 0026 D2ED007A 		flds	s15, [r2, #0]
 1997 002a 46EE877A 		fmacs	s15, s13, s14
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 1998              		.loc 11 36 0
 1999 002e 06EE904A 		fmsr	s13, r4	@ int
 2000 0032 91ED017A 		flds	s14, [r1, #4]
 2001 0036 F8EEE66A 		fsitos	s13, s13
  35:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[XAXIS] = MPU6000.data.accel.x * accelScaleFactor[XAXIS] + runTimeAccelBias[XAXIS];
 2002              		.loc 11 35 0
 2003 003a C3ED007A 		fsts	s15, [r3, #0]
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2004              		.loc 11 36 0
 2005 003e D2ED017A 		flds	s15, [r2, #4]
 2006 0042 46EE877A 		fmacs	s15, s13, s14
 2007              		.loc 11 37 0
 2008 0046 06EE900A 		fmsr	s13, r0	@ int
  36:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   meterPerSecSec[YAXIS] = MPU6000.data.accel.y * accelScaleFactor[YAXIS] + runTimeAccelBias[YAXIS];
 2009              		.loc 11 36 0
 2010 004a C3ED017A 		fsts	s15, [r3, #4]
 2011              		.loc 11 37 0
 2012 004e F8EEE66A 		fsitos	s13, s13
 2013 0052 91ED027A 		flds	s14, [r1, #8]
 2014 0056 D2ED027A 		flds	s15, [r2, #8]
 2015 005a 46EE877A 		fmacs	s15, s13, s14
 2016 005e C3ED027A 		fsts	s15, [r3, #8]
 2017 0062 10BD     		pop	{r4, pc}
 2018              	.L117:
 2019              		.align	2
 2020              	.L116:
 2021 0064 00000000 		.word	.LANCHOR19
 2022 0068 00000000 		.word	.LANCHOR29
 2023 006c 00000000 		.word	.LANCHOR28
 2024 0070 00000000 		.word	.LANCHOR30
 2025              		.cfi_endproc
 2026              	.LFE154:
 2028              		.section	.text._Z15measureAccelSumv,"ax",%progbits
 2029              		.align	1
 2030              		.global	_Z15measureAccelSumv
 2031              		.thumb
 2032              		.thumb_func
 2034              	_Z15measureAccelSumv:
 2035              	.LFB155:
  38:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
  39:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  40:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void measureAccelSum() {
 2036              		.loc 11 40 0
 2037              		.cfi_startproc
 2038              		@ args = 0, pretend = 0, frame = 0
 2039              		@ frame_needed = 0, uses_anonymous_args = 0
 2040              		@ link register save eliminated.
  41:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   
  42:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[XAXIS] += MPU6000.data.accel.x;
 2041              		.loc 11 42 0
 2042 0000 0A4B     		ldr	r3, .L119
 2043 0002 0B4A     		ldr	r2, .L119+4
 2044 0004 1968     		ldr	r1, [r3, #0]
 2045 0006 B2F90000 		ldrsh	r0, [r2, #0]
 2046 000a 0918     		adds	r1, r1, r0
 2047 000c 1960     		str	r1, [r3, #0]
  43:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[YAXIS] += MPU6000.data.accel.y;
 2048              		.loc 11 43 0
 2049 000e B2F90200 		ldrsh	r0, [r2, #2]
 2050 0012 5968     		ldr	r1, [r3, #4]
 2051 0014 0918     		adds	r1, r1, r0
 2052 0016 5960     		str	r1, [r3, #4]
  44:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSample[ZAXIS] += MPU6000.data.accel.z;
 2053              		.loc 11 44 0
 2054 0018 B2F90410 		ldrsh	r1, [r2, #4]
 2055 001c 9A68     		ldr	r2, [r3, #8]
 2056 001e 5218     		adds	r2, r2, r1
 2057 0020 9A60     		str	r2, [r3, #8]
  45:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   
  46:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount++;
 2058              		.loc 11 46 0
 2059 0022 044B     		ldr	r3, .L119+8
 2060 0024 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 2061 0026 0132     		adds	r2, r2, #1
 2062 0028 1A70     		strb	r2, [r3, #0]
 2063 002a 7047     		bx	lr
 2064              	.L120:
 2065              		.align	2
 2066              	.L119:
 2067 002c 00000000 		.word	.LANCHOR31
 2068 0030 00000000 		.word	.LANCHOR19
 2069 0034 00000000 		.word	.LANCHOR32
 2070              		.cfi_endproc
 2071              	.LFE155:
 2073              		.section	.text._Z20evaluateMetersPerSecv,"ax",%progbits
 2074              		.align	1
 2075              		.global	_Z20evaluateMetersPerSecv
 2076              		.thumb
 2077              		.thumb_func
 2079              	_Z20evaluateMetersPerSecv:
 2080              	.LFB156:
  47:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
  48:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2081              		.loc 11 49 0
 2082              		.cfi_startproc
 2083              		@ args = 0, pretend = 0, frame = 0
 2084              		@ frame_needed = 0, uses_anonymous_args = 0
 2085              	.LVL132:
 2086 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2087              	.LCFI19:
 2088              		.cfi_def_cfa_offset 20
 2089              		.cfi_offset 4, -20
 2090              		.cfi_offset 5, -16
 2091              		.cfi_offset 6, -12
 2092              		.cfi_offset 7, -8
 2093              		.cfi_offset 14, -4
 2094              	.LBB187:
 2095              	.LBB188:
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2096              		.loc 11 51 0
 2097 0002 124B     		ldr	r3, .L124
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2098              		.loc 11 49 0
 2099 0004 DFF854C0 		ldr	ip, .L124+16
 2100              		.loc 11 51 0
 2101 0008 1F78     		ldrb	r7, [r3, #0]	@ zero_extendqisi2
 2102 000a 114A     		ldr	r2, .L124+4
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2103              		.loc 11 49 0
 2104 000c 114E     		ldr	r6, .L124+8
 2105 000e 124D     		ldr	r5, .L124+12
 2106              		.loc 11 51 0
 2107 0010 0023     		movs	r3, #0
  52:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   	accelSample[axis] = 0;
 2108              		.loc 11 52 0
 2109 0012 1846     		mov	r0, r3
 2110              	.LVL133:
 2111              	.L122:
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2112              		.loc 11 51 0 discriminator 2
 2113 0014 9958     		ldr	r1, [r3, r2]
 2114              		.loc 11 52 0 discriminator 2
 2115 0016 9850     		str	r0, [r3, r2]
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2116              		.loc 11 51 0 discriminator 2
 2117 0018 91FBF7F1 		sdiv	r1, r1, r7
 2118 001c 07EE901A 		fmsr	s15, r1	@ int
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2119              		.loc 11 49 0 discriminator 2
 2120 0020 F118     		adds	r1, r6, r3
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2121              		.loc 11 51 0 discriminator 2
 2122 0022 91ED007A 		flds	s14, [r1, #0]
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2123              		.loc 11 49 0 discriminator 2
 2124 0026 E918     		adds	r1, r5, r3
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2125              		.loc 11 51 0 discriminator 2
 2126 0028 F8EEE76A 		fsitos	s13, s15
 2127 002c D1ED007A 		flds	s15, [r1, #0]
 2128 0030 46EE877A 		fmacs	s15, s13, s14
  49:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void evaluateMetersPerSec() {
 2129              		.loc 11 49 0 discriminator 2
 2130 0034 0CEB0304 		add	r4, ip, r3
 2131 0038 0433     		adds	r3, r3, #4
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2132              		.loc 11 50 0 discriminator 2
 2133 003a 0C2B     		cmp	r3, #12
  51:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (accelSample[axis] / accelSampleCount) * accelScaleFactor[axis] + runTim
 2134              		.loc 11 51 0 discriminator 2
 2135 003c C4ED007A 		fsts	s15, [r4, #0]
  50:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 2136              		.loc 11 50 0 discriminator 2
 2137 0040 E8D1     		bne	.L122
 2138              	.LBE188:
  53:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  54:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2139              		.loc 11 54 0
 2140 0042 024B     		ldr	r3, .L124
 2141 0044 0022     		movs	r2, #0
 2142 0046 1A70     		strb	r2, [r3, #0]
 2143 0048 F0BD     		pop	{r4, r5, r6, r7, pc}
 2144              	.L125:
 2145 004a 00BF     		.align	2
 2146              	.L124:
 2147 004c 00000000 		.word	.LANCHOR32
 2148 0050 00000000 		.word	.LANCHOR31
 2149 0054 00000000 		.word	.LANCHOR29
 2150 0058 00000000 		.word	.LANCHOR30
 2151 005c 00000000 		.word	.LANCHOR28
 2152              	.LBE187:
 2153              		.cfi_endproc
 2154              	.LFE156:
 2156              		.section	.text._Z16computeAccelBiasv,"ax",%progbits
 2157              		.align	1
 2158              		.global	_Z16computeAccelBiasv
 2159              		.thumb
 2160              		.thumb_func
 2162              	_Z16computeAccelBiasv:
 2163              	.LFB157:
  55:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** }
  56:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2164              		.loc 11 57 0
 2165              		.cfi_startproc
 2166              		@ args = 0, pretend = 0, frame = 0
 2167              		@ frame_needed = 0, uses_anonymous_args = 0
 2168 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2169              	.LCFI20:
 2170              		.cfi_def_cfa_offset 24
 2171              		.cfi_offset 3, -24
 2172              		.cfi_offset 4, -20
 2173              		.cfi_offset 5, -16
 2174              		.cfi_offset 6, -12
 2175              		.cfi_offset 7, -8
 2176              		.cfi_offset 14, -4
 2177              	.LBB189:
  58:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  59:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   evaluateMetersPerSec();	// reset samples
 2178              		.loc 11 59 0
 2179 0002 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 2180              	.LVL134:
  60:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   delay(2);
 2181              		.loc 11 60 0
 2182 0006 0220     		movs	r0, #2
 2183 0008 FFF7FEFF 		bl	_Z5delaym
 2184              	.LVL135:
 2185              	.LBB190:
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2186              		.loc 11 61 0
 2187 000c 0024     		movs	r4, #0
 2188 000e 08E0     		b	.L127
 2189              	.LVL136:
 2190              	.L128:
  62:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 	readMPU6000Sensors();
 2191              		.loc 11 62 0 discriminator 2
 2192 0010 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 2193              	.LVL137:
  63:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     measureAccelSum();
 2194              		.loc 11 63 0 discriminator 2
 2195 0014 FFF7FEFF 		bl	_Z15measureAccelSumv
 2196              	.LVL138:
  64:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     delayMicroseconds(2500);
 2197              		.loc 11 64 0 discriminator 2
 2198 0018 40F6C410 		movw	r0, #2500
 2199 001c FFF7FEFF 		bl	_Z17delayMicrosecondsj
 2200              	.LVL139:
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2201              		.loc 11 61 0 discriminator 2
 2202 0020 0134     		adds	r4, r4, #1
 2203              	.LVL140:
 2204              	.L127:
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2205              		.loc 11 61 0 is_stmt 0 discriminator 1
 2206 0022 B4F5C87F 		cmp	r4, #400
 2207 0026 F3D1     		bne	.L128
  61:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (int samples = 0; samples < SAMPLECOUNT; samples++) {
 2208              		.loc 11 61 0
 2209 0028 0023     		movs	r3, #0
 2210              	.LBE190:
 2211              	.LBB191:
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2212              		.loc 11 57 0 is_stmt 1
 2213 002a 1F4F     		ldr	r7, .L132
  65:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  66:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2214              		.loc 11 68 0
 2215 002c 1F49     		ldr	r1, .L132+4
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2216              		.loc 11 57 0
 2217 002e 204E     		ldr	r6, .L132+8
 2218              		.loc 11 68 0
 2219 0030 DFED206A 		flds	s13, .L132+12
  69:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     accelSample[axis] = 0;
 2220              		.loc 11 69 0
 2221 0034 1846     		mov	r0, r3
 2222              	.LVL141:
 2223              	.L129:
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2224              		.loc 11 68 0 discriminator 2
 2225 0036 5D58     		ldr	r5, [r3, r1]
 2226              		.loc 11 69 0 discriminator 2
 2227 0038 5850     		str	r0, [r3, r1]
 2228              	.LVL142:
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2229              		.loc 11 68 0 discriminator 2
 2230 003a 07EE105A 		fmsr	s14, r5	@ int
 2231 003e F8EEC77A 		fsitos	s15, s14
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2232              		.loc 11 57 0 discriminator 2
 2233 0042 F518     		adds	r5, r6, r3
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2234              		.loc 11 68 0 discriminator 2
 2235 0044 87EEA67A 		fdivs	s14, s15, s13
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2236              		.loc 11 57 0 discriminator 2
 2237 0048 FC18     		adds	r4, r7, r3
 2238 004a 0433     		adds	r3, r3, #4
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2239              		.loc 11 67 0 discriminator 2
 2240 004c 0C2B     		cmp	r3, #12
  57:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** void computeAccelBias() {
 2241              		.loc 11 57 0 discriminator 2
 2242 004e 164A     		ldr	r2, .L132
  68:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****     meterPerSecSec[axis] = (float(accelSample[axis])/SAMPLECOUNT) * accelScaleFactor[axis];
 2243              		.loc 11 68 0 discriminator 2
 2244 0050 D5ED007A 		flds	s15, [r5, #0]
 2245 0054 67EE277A 		fmuls	s15, s14, s15
 2246 0058 C4ED007A 		fsts	s15, [r4, #0]
  67:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   for (byte axis = 0; axis < 3; axis++) {
 2247              		.loc 11 67 0 discriminator 2
 2248 005c EBD1     		bne	.L129
 2249              	.LBE191:
  70:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   }
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2250              		.loc 11 71 0
 2251 005e 164B     		ldr	r3, .L132+16
 2252 0060 0021     		movs	r1, #0
  72:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  73:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[XAXIS] = -meterPerSecSec[XAXIS];
 2253              		.loc 11 73 0
 2254 0062 D2ED007A 		flds	s15, [r2, #0]
  71:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelSampleCount = 0;
 2255              		.loc 11 71 0
 2256 0066 1970     		strb	r1, [r3, #0]
 2257              		.loc 11 73 0
 2258 0068 144B     		ldr	r3, .L132+20
 2259 006a F1EE677A 		fnegs	s15, s15
 2260 006e C3ED007A 		fsts	s15, [r3, #0]
  74:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[YAXIS] = -meterPerSecSec[YAXIS];
 2261              		.loc 11 74 0
 2262 0072 D2ED017A 		flds	s15, [r2, #4]
 2263 0076 F1EE677A 		fnegs	s15, s15
 2264 007a C3ED017A 		fsts	s15, [r3, #4]
  75:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   runTimeAccelBias[ZAXIS] = -9.8065 - meterPerSecSec[ZAXIS];
 2265              		.loc 11 75 0
 2266 007e 92ED027A 		flds	s14, [r2, #8]
 2267 0082 DFED0F7A 		flds	s15, .L132+24
 2268 0086 77EEC77A 		fsubs	s15, s15, s14
 2269 008a C3ED027A 		fsts	s15, [r3, #8]
  76:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h **** 
  77:../Libraries/AQ_Accelerometer/Accelerometer_MPU6000.h ****   accelOneG = abs(meterPerSecSec[ZAXIS] + runTimeAccelBias[ZAXIS]);
 2270              		.loc 11 77 0
 2271 008e 77EE277A 		fadds	s15, s14, s15
 2272 0092 0C4B     		ldr	r3, .L132+28
 2273 0094 F5EEC07A 		fcmpezs	s15
 2274 0098 F1EE10FA 		fmstat
 2275 009c D8BF     		it	le
 2276 009e F1EE677A 		fnegsle	s15, s15
 2277 00a2 C3ED007A 		fsts	s15, [r3, #0]
 2278 00a6 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2279              	.L133:
 2280              		.align	2
 2281              	.L132:
 2282 00a8 00000000 		.word	.LANCHOR28
 2283 00ac 00000000 		.word	.LANCHOR31
 2284 00b0 00000000 		.word	.LANCHOR29
 2285 00b4 0000C843 		.word	1137180672
 2286 00b8 00000000 		.word	.LANCHOR32
 2287 00bc 00000000 		.word	.LANCHOR30
 2288 00c0 6DE71CC1 		.word	-1055070355
 2289 00c4 00000000 		.word	.LANCHOR33
 2290              	.LBE189:
 2291              		.cfi_endproc
 2292              	.LFE157:
 2294              		.section	.text._Z12initPlatformv,"ax",%progbits
 2295              		.align	1
 2296              		.global	_Z12initPlatformv
 2297              		.thumb
 2298              		.thumb_func
 2300              	_Z12initPlatformv:
 2301              	.LFB158:
 2302              		.file 12 "../AeroQuad32/platform_aeroquad32.h"
   1:../AeroQuad32/platform_aeroquad32.h **** #ifndef _PLATFORM_AEROQUAD32_H_
   2:../AeroQuad32/platform_aeroquad32.h **** #define _PLATFORM_AEROQUAD32_H_
   3:../AeroQuad32/platform_aeroquad32.h **** 
   4:../AeroQuad32/platform_aeroquad32.h **** static byte __attribute__((unused)) stm32_motor_mapping[] = {
   5:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  9),
   6:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  8),
   7:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  7),
   8:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  6),
   9:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('A', 15),
  10:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  3),
  11:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  4),
  12:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('B',  5)
  13:../AeroQuad32/platform_aeroquad32.h **** };
  14:../AeroQuad32/platform_aeroquad32.h **** 
  15:../AeroQuad32/platform_aeroquad32.h **** static byte __attribute__((unused)) stm32_motor_mapping_tri[] = {
  16:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('A', 15), // note this must be on separate timer device !!
  17:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  8),
  18:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  7),
  19:../AeroQuad32/platform_aeroquad32.h ****   Port2Pin('C',  6),
  20:../AeroQuad32/platform_aeroquad32.h **** };
  21:../AeroQuad32/platform_aeroquad32.h **** 
  22:../AeroQuad32/platform_aeroquad32.h **** #ifdef RECEIVER_STM32PPM
  23:../AeroQuad32/platform_aeroquad32.h ****   static byte receiverPinPPM = Port2Pin('D', 15);
  24:../AeroQuad32/platform_aeroquad32.h **** #elif defined ReceiverSBUS
  25:../AeroQuad32/platform_aeroquad32.h ****   // Do nothing
  26:../AeroQuad32/platform_aeroquad32.h **** #else
  27:../AeroQuad32/platform_aeroquad32.h ****   static byte receiverPin[] = {
  28:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 12),
  29:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 13),
  30:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 14),
  31:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('D', 15),
  32:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E',  9),
  33:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 11),
  34:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 13),
  35:../AeroQuad32/platform_aeroquad32.h ****     Port2Pin('E', 14)
  36:../AeroQuad32/platform_aeroquad32.h ****   };
  37:../AeroQuad32/platform_aeroquad32.h **** #endif
  38:../AeroQuad32/platform_aeroquad32.h **** 
  39:../AeroQuad32/platform_aeroquad32.h **** #define STM32_BOARD_TYPE "aeroquad32"
  40:../AeroQuad32/platform_aeroquad32.h **** #define LED_Green  Port2Pin('E', 6)
  41:../AeroQuad32/platform_aeroquad32.h **** #define LED_Red    Port2Pin('E', 5)
  42:../AeroQuad32/platform_aeroquad32.h **** #define LED_Yellow LED_Red
  43:../AeroQuad32/platform_aeroquad32.h **** 
  44:../AeroQuad32/platform_aeroquad32.h **** #define BATT_ANALOG_INPUT	Port2Pin('C', 0)
  45:../AeroQuad32/platform_aeroquad32.h **** #define A1       Port2Pin('B',0)
  46:../AeroQuad32/platform_aeroquad32.h **** #define A2       Port2Pin('C',4)
  47:../AeroQuad32/platform_aeroquad32.h **** #define A3       Port2Pin('B',1)
  48:../AeroQuad32/platform_aeroquad32.h **** #define A4       Port2Pin('C',5)
  49:../AeroQuad32/platform_aeroquad32.h **** #define A5       Port2Pin('C',2)
  50:../AeroQuad32/platform_aeroquad32.h **** #define A6       Port2Pin('C',3)
  51:../AeroQuad32/platform_aeroquad32.h **** 
  52:../AeroQuad32/platform_aeroquad32.h **** // external LED drivers
  53:../AeroQuad32/platform_aeroquad32.h **** #define PLED1 Port2Pin('D',  7)
  54:../AeroQuad32/platform_aeroquad32.h **** #define PLED2 Port2Pin('E',  0)
  55:../AeroQuad32/platform_aeroquad32.h **** #define PLED3 Port2Pin('E',  1)
  56:../AeroQuad32/platform_aeroquad32.h **** #define PLED4 Port2Pin('D',  4) 
  57:../AeroQuad32/platform_aeroquad32.h **** 
  58:../AeroQuad32/platform_aeroquad32.h **** #include <Device_I2C.h>
  59:../AeroQuad32/platform_aeroquad32.h **** 
  60:../AeroQuad32/platform_aeroquad32.h **** #include <Gyroscope_MPU6000.h>
  61:../AeroQuad32/platform_aeroquad32.h **** #include <Accelerometer_MPU6000.h>
  62:../AeroQuad32/platform_aeroquad32.h **** 
  63:../AeroQuad32/platform_aeroquad32.h **** // heading mag hold declaration
  64:../AeroQuad32/platform_aeroquad32.h **** #ifdef HeadingMagHold
  65:../AeroQuad32/platform_aeroquad32.h ****   #include <Compass.h>
  66:../AeroQuad32/platform_aeroquad32.h ****   #define HMC5883L
  67:../AeroQuad32/platform_aeroquad32.h **** #endif
  68:../AeroQuad32/platform_aeroquad32.h **** 
  69:../AeroQuad32/platform_aeroquad32.h **** // Altitude declaration
  70:../AeroQuad32/platform_aeroquad32.h **** #ifdef AltitudeHoldBaro
  71:../AeroQuad32/platform_aeroquad32.h ****   #define MS5611
  72:../AeroQuad32/platform_aeroquad32.h **** #endif
  73:../AeroQuad32/platform_aeroquad32.h **** 
  74:../AeroQuad32/platform_aeroquad32.h **** #ifdef AltitudeHoldRangeFinder
  75:../AeroQuad32/platform_aeroquad32.h ****   #define XLMAXSONAR
  76:../AeroQuad32/platform_aeroquad32.h **** #endif
  77:../AeroQuad32/platform_aeroquad32.h **** 
  78:../AeroQuad32/platform_aeroquad32.h **** // Battery Monitor declaration
  79:../AeroQuad32/platform_aeroquad32.h **** #ifdef BattMonitor
  80:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_AREF         3.3		// V
  81:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_R_HIGH       10.0		// kOhm
  82:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_R_LOW        1.5		// kOhm
  83:../AeroQuad32/platform_aeroquad32.h ****   #define BATT_DIODE_LOSS		0.0
  84:../AeroQuad32/platform_aeroquad32.h ****   #define BattDefaultConfig DEFINE_BATTERY(0, BATT_ANALOG_INPUT, (BATT_AREF * (BATT_R_HIGH + BATT_R
  85:../AeroQuad32/platform_aeroquad32.h **** #endif
  86:../AeroQuad32/platform_aeroquad32.h **** 
  87:../AeroQuad32/platform_aeroquad32.h **** #ifdef OSD
  88:../AeroQuad32/platform_aeroquad32.h ****   #define MAX7456_OSD
  89:../AeroQuad32/platform_aeroquad32.h **** #endif
  90:../AeroQuad32/platform_aeroquad32.h **** 
  91:../AeroQuad32/platform_aeroquad32.h **** #ifdef CameraControl
  92:../AeroQuad32/platform_aeroquad32.h ****   #define CameraControl_STM32
  93:../AeroQuad32/platform_aeroquad32.h **** #endif
  94:../AeroQuad32/platform_aeroquad32.h **** 
  95:../AeroQuad32/platform_aeroquad32.h **** void initPlatform() {
 2303              		.loc 12 95 0
 2304              		.cfi_startproc
 2305              		@ args = 0, pretend = 0, frame = 0
 2306              		@ frame_needed = 0, uses_anonymous_args = 0
 2307 0000 10B5     		push	{r4, lr}
 2308              	.LCFI21:
 2309              		.cfi_def_cfa_offset 8
 2310              		.cfi_offset 4, -8
 2311              		.cfi_offset 14, -4
 2312              	.LBB192:
  96:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Green, OUTPUT);
 2313              		.loc 12 96 0
 2314 0002 4620     		movs	r0, #70
 2315 0004 0021     		movs	r1, #0
 2316 0006 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2317              	.LVL143:
  97:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2318              		.loc 12 97 0
 2319 000a 0024     		movs	r4, #0
 2320              	.LVL144:
 2321              	.L135:
 2322              	.LBB193:
  98:../AeroQuad32/platform_aeroquad32.h ****     digitalWrite(LED_Green, ledloop & 1);
 2323              		.loc 12 98 0 discriminator 2
 2324 000c 4620     		movs	r0, #70
 2325 000e 04F00101 		and	r1, r4, #1
  97:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2326              		.loc 12 97 0 discriminator 2
 2327 0012 0134     		adds	r4, r4, #1
 2328              		.loc 12 98 0 discriminator 2
 2329 0014 FFF7FEFF 		bl	_Z12digitalWritehh
 2330              	.LVL145:
  97:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2331              		.loc 12 97 0 discriminator 2
 2332 0018 E4B2     		uxtb	r4, r4
  99:../AeroQuad32/platform_aeroquad32.h ****     delay(50);
 2333              		.loc 12 99 0 discriminator 2
 2334 001a 3220     		movs	r0, #50
 2335 001c FFF7FEFF 		bl	_Z5delaym
 2336              	.LVL146:
  97:../AeroQuad32/platform_aeroquad32.h ****   for(byte ledloop=0; ledloop<10; ledloop++) {
 2337              		.loc 12 97 0 discriminator 2
 2338 0020 0A2C     		cmp	r4, #10
 2339 0022 F3D1     		bne	.L135
 2340              	.LBE193:
 100:../AeroQuad32/platform_aeroquad32.h ****   }
 101:../AeroQuad32/platform_aeroquad32.h **** 
 102:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Red, OUTPUT);
 2341              		.loc 12 102 0
 2342 0024 4520     		movs	r0, #69
 2343 0026 0021     		movs	r1, #0
 2344 0028 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2345              	.LVL147:
 103:../AeroQuad32/platform_aeroquad32.h ****   digitalWrite(LED_Red, LOW);
 2346              		.loc 12 103 0
 2347 002c 4520     		movs	r0, #69
 2348 002e 0021     		movs	r1, #0
 2349 0030 FFF7FEFF 		bl	_Z12digitalWritehh
 2350              	.LVL148:
 104:../AeroQuad32/platform_aeroquad32.h ****   pinMode(LED_Yellow, OUTPUT);
 2351              		.loc 12 104 0
 2352 0034 4520     		movs	r0, #69
 2353 0036 0021     		movs	r1, #0
 2354 0038 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2355              	.LVL149:
 105:../AeroQuad32/platform_aeroquad32.h ****   digitalWrite(LED_Yellow, LOW);
 2356              		.loc 12 105 0
 2357 003c 4520     		movs	r0, #69
 2358 003e 0021     		movs	r1, #0
 2359 0040 FFF7FEFF 		bl	_Z12digitalWritehh
 2360              	.LVL150:
 106:../AeroQuad32/platform_aeroquad32.h **** 
 107:../AeroQuad32/platform_aeroquad32.h ****   pinMode(BATT_ANALOG_INPUT, INPUT_ANALOG);
 2361              		.loc 12 107 0
 2362 0044 2020     		movs	r0, #32
 2363 0046 0321     		movs	r1, #3
 2364 0048 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2365              	.LVL151:
 108:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A1, INPUT_ANALOG);
 2366              		.loc 12 108 0
 2367 004c 1020     		movs	r0, #16
 2368 004e 0321     		movs	r1, #3
 2369 0050 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2370              	.LVL152:
 109:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A2, INPUT_ANALOG);
 2371              		.loc 12 109 0
 2372 0054 2420     		movs	r0, #36
 2373 0056 0321     		movs	r1, #3
 2374 0058 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2375              	.LVL153:
 110:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A3, INPUT_ANALOG);
 2376              		.loc 12 110 0
 2377 005c 1120     		movs	r0, #17
 2378 005e 0321     		movs	r1, #3
 2379 0060 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2380              	.LVL154:
 111:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A4, INPUT_ANALOG);
 2381              		.loc 12 111 0
 2382 0064 2520     		movs	r0, #37
 2383 0066 0321     		movs	r1, #3
 2384 0068 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2385              	.LVL155:
 112:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A5, INPUT_ANALOG);
 2386              		.loc 12 112 0
 2387 006c 2220     		movs	r0, #34
 2388 006e 0321     		movs	r1, #3
 2389 0070 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2390              	.LVL156:
 113:../AeroQuad32/platform_aeroquad32.h ****   pinMode(A6, INPUT_ANALOG);
 2391              		.loc 12 113 0
 2392 0074 0321     		movs	r1, #3
 2393 0076 2320     		movs	r0, #35
 2394 0078 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2395              	.LVL157:
 114:../AeroQuad32/platform_aeroquad32.h **** 
 115:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED1, OUTPUT);
 2396              		.loc 12 115 0
 2397 007c 3720     		movs	r0, #55
 2398 007e 0021     		movs	r1, #0
 2399 0080 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2400              	.LVL158:
 116:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED2, OUTPUT);
 2401              		.loc 12 116 0
 2402 0084 4020     		movs	r0, #64
 2403 0086 0021     		movs	r1, #0
 2404 0088 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2405              	.LVL159:
 117:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED3, OUTPUT);
 2406              		.loc 12 117 0
 2407 008c 4120     		movs	r0, #65
 2408 008e 0021     		movs	r1, #0
 2409 0090 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2410              	.LVL160:
 118:../AeroQuad32/platform_aeroquad32.h ****   pinMode(PLED4, OUTPUT);
 2411              		.loc 12 118 0
 2412 0094 3420     		movs	r0, #52
 2413 0096 0021     		movs	r1, #0
 2414 0098 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 2415              	.LVL161:
 119:../AeroQuad32/platform_aeroquad32.h **** 
 120:../AeroQuad32/platform_aeroquad32.h ****   // I2C setup
 121:../AeroQuad32/platform_aeroquad32.h ****   Wire.begin(Port2Pin('B', 7), Port2Pin('B', 6)); // I2C1_SDA PB7, I2C1_SCL PB6
 2416              		.loc 12 121 0
 2417 009c 0448     		ldr	r0, .L137
 2418 009e 1721     		movs	r1, #23
 2419 00a0 1622     		movs	r2, #22
 2420 00a2 FFF7FEFF 		bl	_ZN7TwoWire5beginEhh
 2421              	.LVL162:
 2422              	.LBE192:
 122:../AeroQuad32/platform_aeroquad32.h **** 
 123:../AeroQuad32/platform_aeroquad32.h ****   initializeMPU6000Sensors();
 124:../AeroQuad32/platform_aeroquad32.h ****   
 125:../AeroQuad32/platform_aeroquad32.h ****   #if !defined(USE_USB_SERIAL)
 126:../AeroQuad32/platform_aeroquad32.h ****     SerialUSB.begin();
 127:../AeroQuad32/platform_aeroquad32.h ****   #endif
 128:../AeroQuad32/platform_aeroquad32.h **** }
 2423              		.loc 12 128 0
 2424 00a6 BDE81040 		pop	{r4, lr}
 2425              	.LBB194:
 123:../AeroQuad32/platform_aeroquad32.h ****   initializeMPU6000Sensors();
 2426              		.loc 12 123 0
 2427 00aa FFF7FEBF 		b	_Z24initializeMPU6000Sensorsv
 2428              	.LVL163:
 2429              	.L138:
 2430 00ae 00BF     		.align	2
 2431              	.L137:
 2432 00b0 00000000 		.word	Wire
 2433              	.LBE194:
 2434              		.cfi_endproc
 2435              	.LFE158:
 2437              		.section	.text._Z42initializePlatformSpecificAccelCalibrationv,"ax",%progbits
 2438              		.align	1
 2439              		.global	_Z42initializePlatformSpecificAccelCalibrationv
 2440              		.thumb
 2441              		.thumb_func
 2443              	_Z42initializePlatformSpecificAccelCalibrationv:
 2444              	.LFB159:
 129:../AeroQuad32/platform_aeroquad32.h **** 
 130:../AeroQuad32/platform_aeroquad32.h **** // called when eeprom is initialized
 131:../AeroQuad32/platform_aeroquad32.h **** void initializePlatformSpecificAccelCalibration() {
 2445              		.loc 12 131 0
 2446              		.cfi_startproc
 2447              		@ args = 0, pretend = 0, frame = 0
 2448              		@ frame_needed = 0, uses_anonymous_args = 0
 2449              		@ link register save eliminated.
 132:../AeroQuad32/platform_aeroquad32.h ****   // Kenny default value, a real accel calibration is strongly recommended
 133:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[XAXIS] = 0.0011980000;
 2450              		.loc 12 133 0
 2451 0000 034B     		ldr	r3, .L140
 2452 0002 044A     		ldr	r2, .L140+4
 2453 0004 1A60     		str	r2, [r3, #0]	@ float
 134:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[YAXIS] = -0.0012020000;
 2454              		.loc 12 134 0
 2455 0006 044A     		ldr	r2, .L140+8
 2456 0008 5A60     		str	r2, [r3, #4]	@ float
 135:../AeroQuad32/platform_aeroquad32.h ****   accelScaleFactor[ZAXIS] = -0.0011750000;
 2457              		.loc 12 135 0
 2458 000a 044A     		ldr	r2, .L140+12
 2459 000c 9A60     		str	r2, [r3, #8]	@ float
 2460 000e 7047     		bx	lr
 2461              	.L141:
 2462              		.align	2
 2463              	.L140:
 2464 0010 00000000 		.word	.LANCHOR29
 2465 0014 36069D3A 		.word	983369270
 2466 0018 6D8C9DBA 		.word	-1164080019
 2467 001c 75029ABA 		.word	-1164311947
 2468              		.cfi_endproc
 2469              	.LFE159:
 2471              		.section	.text._Z22measureCriticalSensorsv,"ax",%progbits
 2472              		.align	1
 2473              		.global	_Z22measureCriticalSensorsv
 2474              		.thumb
 2475              		.thumb_func
 2477              	_Z22measureCriticalSensorsv:
 2478              	.LFB160:
 136:../AeroQuad32/platform_aeroquad32.h ****   #ifdef HeadingMagHold
 137:../AeroQuad32/platform_aeroquad32.h ****     magBias[XAXIS]  = 152.000000;
 138:../AeroQuad32/platform_aeroquad32.h ****     magBias[YAXIS]  = 24.000000;
 139:../AeroQuad32/platform_aeroquad32.h ****     magBias[ZAXIS]  = 16.500000;
 140:../AeroQuad32/platform_aeroquad32.h ****   #endif
 141:../AeroQuad32/platform_aeroquad32.h **** }
 142:../AeroQuad32/platform_aeroquad32.h **** 
 143:../AeroQuad32/platform_aeroquad32.h **** unsigned long previousMeasureCriticalSensorsTime = 0;
 144:../AeroQuad32/platform_aeroquad32.h **** unsigned long measureCriticalSensorsTime = 0;
 145:../AeroQuad32/platform_aeroquad32.h **** void measureCriticalSensors() {
 2479              		.loc 12 145 0
 2480              		.cfi_startproc
 2481              		@ args = 0, pretend = 0, frame = 0
 2482              		@ frame_needed = 0, uses_anonymous_args = 0
 2483 0000 38B5     		push	{r3, r4, r5, lr}
 2484              	.LCFI22:
 2485              		.cfi_def_cfa_offset 16
 2486              		.cfi_offset 3, -16
 2487              		.cfi_offset 4, -12
 2488              		.cfi_offset 5, -8
 2489              		.cfi_offset 14, -4
 146:../AeroQuad32/platform_aeroquad32.h ****   // read sensors not faster than every 1 ms
 147:../AeroQuad32/platform_aeroquad32.h ****   measureCriticalSensorsTime = micros();
 148:../AeroQuad32/platform_aeroquad32.h ****   if ((measureCriticalSensorsTime - previousMeasureCriticalSensorsTime) >= 1000) {
 2490              		.loc 12 148 0
 2491 0002 094C     		ldr	r4, .L144
 147:../AeroQuad32/platform_aeroquad32.h ****   measureCriticalSensorsTime = micros();
 2492              		.loc 12 147 0
 2493 0004 094D     		ldr	r5, .L144+4
 2494 0006 FFF7FEFF 		bl	_ZL6microsv
 2495              	.LVL164:
 2496              		.loc 12 148 0
 2497 000a 2368     		ldr	r3, [r4, #0]
 147:../AeroQuad32/platform_aeroquad32.h ****   measureCriticalSensorsTime = micros();
 2498              		.loc 12 147 0
 2499 000c 2860     		str	r0, [r5, #0]
 2500              		.loc 12 148 0
 2501 000e C01A     		subs	r0, r0, r3
 2502 0010 B0F57A7F 		cmp	r0, #1000
 2503 0014 07D3     		bcc	.L142
 2504              	.LBB197:
 2505              	.LBB198:
 149:../AeroQuad32/platform_aeroquad32.h ****     readMPU6000Sensors();
 2506              		.loc 12 149 0
 2507 0016 FFF7FEFF 		bl	_Z18readMPU6000Sensorsv
 2508              	.LVL165:
 150:../AeroQuad32/platform_aeroquad32.h ****     measureGyroSum();
 2509              		.loc 12 150 0
 2510 001a FFF7FEFF 		bl	_Z14measureGyroSumv
 2511              	.LVL166:
 151:../AeroQuad32/platform_aeroquad32.h ****     measureAccelSum();
 2512              		.loc 12 151 0
 2513 001e FFF7FEFF 		bl	_Z15measureAccelSumv
 2514              	.LVL167:
 152:../AeroQuad32/platform_aeroquad32.h ****     previousMeasureCriticalSensorsTime = measureCriticalSensorsTime;
 2515              		.loc 12 152 0
 2516 0022 2B68     		ldr	r3, [r5, #0]
 2517 0024 2360     		str	r3, [r4, #0]
 2518              	.L142:
 2519 0026 38BD     		pop	{r3, r4, r5, pc}
 2520              	.L145:
 2521              		.align	2
 2522              	.L144:
 2523 0028 00000000 		.word	.LANCHOR35
 2524 002c 00000000 		.word	.LANCHOR34
 2525              	.LBE198:
 2526              	.LBE197:
 2527              		.cfi_endproc
 2528              	.LFE160:
 2530              		.section	.text._Z29initializeBaseKinematicsParamv,"ax",%progbits
 2531              		.align	1
 2532              		.global	_Z29initializeBaseKinematicsParamv
 2533              		.thumb
 2534              		.thumb_func
 2536              	_Z29initializeBaseKinematicsParamv:
 2537              	.LFB161:
 2538              		.file 13 "../Libraries/AQ_Kinematics/Kinematics.h"
   1:../Libraries/AQ_Kinematics/Kinematics.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics.h **** #ifndef _AQ_KINEMATICS_
  22:../Libraries/AQ_Kinematics/Kinematics.h **** #define _AQ_KINEMATICS_
  23:../Libraries/AQ_Kinematics/Kinematics.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics.h **** #include "GlobalDefined.h"
  25:../Libraries/AQ_Kinematics/Kinematics.h **** 
  26:../Libraries/AQ_Kinematics/Kinematics.h **** #define CF 0
  27:../Libraries/AQ_Kinematics/Kinematics.h **** #define KF 1
  28:../Libraries/AQ_Kinematics/Kinematics.h **** #define DCM 2
  29:../Libraries/AQ_Kinematics/Kinematics.h **** #define ARG 3
  30:../Libraries/AQ_Kinematics/Kinematics.h **** #define MARG 4
  31:../Libraries/AQ_Kinematics/Kinematics.h **** 
  32:../Libraries/AQ_Kinematics/Kinematics.h **** // This class is responsible for calculating vehicle attitude
  33:../Libraries/AQ_Kinematics/Kinematics.h **** byte kinematicsType = 0;
  34:../Libraries/AQ_Kinematics/Kinematics.h **** float kinematicsAngle[3] = {0.0,0.0,0.0};
  35:../Libraries/AQ_Kinematics/Kinematics.h **** //float gyroAngle[2] = {0.0,0.0};
  36:../Libraries/AQ_Kinematics/Kinematics.h **** float correctedRateVector[3] = {0.0,0.0,0.0};
  37:../Libraries/AQ_Kinematics/Kinematics.h **** float earthAccel[3] = {0.0,0.0,0.0};
  38:../Libraries/AQ_Kinematics/Kinematics.h **** 
  39:../Libraries/AQ_Kinematics/Kinematics.h **** float accelCutoff = 0.0;
  40:../Libraries/AQ_Kinematics/Kinematics.h **** 
  41:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeBaseKinematicsParam() {
 2539              		.loc 13 41 0
 2540              		.cfi_startproc
 2541              		@ args = 0, pretend = 0, frame = 0
 2542              		@ frame_needed = 0, uses_anonymous_args = 0
 2543              		@ link register save eliminated.
 2544              	.LVL168:
 2545              	.LBB199:
  42:../Libraries/AQ_Kinematics/Kinematics.h **** 
  43:../Libraries/AQ_Kinematics/Kinematics.h ****   for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
  44:../Libraries/AQ_Kinematics/Kinematics.h ****     kinematicsAngle[axis] = 0.0;
 2546              		.loc 13 44 0
 2547 0000 024B     		ldr	r3, .L147
 2548 0002 0022     		movs	r2, #0
 2549 0004 1A60     		str	r2, [r3, #0]	@ float
 2550              	.LVL169:
 2551 0006 5A60     		str	r2, [r3, #4]	@ float
 2552              	.LVL170:
 2553 0008 9A60     		str	r2, [r3, #8]	@ float
 2554              	.LVL171:
 2555 000a 7047     		bx	lr
 2556              	.L148:
 2557              		.align	2
 2558              	.L147:
 2559 000c 00000000 		.word	.LANCHOR36
 2560              	.LBE199:
 2561              		.cfi_endproc
 2562              	.LFE161:
 2564              		.section	.text._Z27kinematicsGetDegreesHeadingh,"ax",%progbits
 2565              		.align	1
 2566              		.global	_Z27kinematicsGetDegreesHeadingh
 2567              		.thumb
 2568              		.thumb_func
 2570              	_Z27kinematicsGetDegreesHeadingh:
 2571              	.LFB162:
  45:../Libraries/AQ_Kinematics/Kinematics.h ****   }
  46:../Libraries/AQ_Kinematics/Kinematics.h **** //  gyroAngle[XAXIS] = 0;
  47:../Libraries/AQ_Kinematics/Kinematics.h **** //  gyroAngle[YAXIS] = 0;
  48:../Libraries/AQ_Kinematics/Kinematics.h **** }
  49:../Libraries/AQ_Kinematics/Kinematics.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics.h **** void initializeKinematics(float hdgX, float hdgY);
  51:../Libraries/AQ_Kinematics/Kinematics.h **** void calculateKinematics(float rollRate,           float pitchRate,     float yawRate,       
  52:../Libraries/AQ_Kinematics/Kinematics.h ****                          float longitudinalAccel,  float lateralAccel,  float verticalAccel, 
  53:../Libraries/AQ_Kinematics/Kinematics.h ****                          float G_Dt);
  54:../Libraries/AQ_Kinematics/Kinematics.h **** float getGyroUnbias(byte axis);
  55:../Libraries/AQ_Kinematics/Kinematics.h **** void calibrateKinematics();
  56:../Libraries/AQ_Kinematics/Kinematics.h ****  
  57:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns the kinematicsAngle of a specific axis in SI units (radians)
  58:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getData(byte axis) {
  59:../Libraries/AQ_Kinematics/Kinematics.h **** //    return kinematicsAngle[axis];
  60:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  61:../Libraries/AQ_Kinematics/Kinematics.h ****   // return heading as +PI/-PI
  62:../Libraries/AQ_Kinematics/Kinematics.h **** //  const float getHeading(byte axis) {
  63:../Libraries/AQ_Kinematics/Kinematics.h **** //    return(kinematicsAngle[axis]);
  64:../Libraries/AQ_Kinematics/Kinematics.h **** //  }
  65:../Libraries/AQ_Kinematics/Kinematics.h ****   
  66:../Libraries/AQ_Kinematics/Kinematics.h ****   // This really needs to be in Radians to be consistent
  67:../Libraries/AQ_Kinematics/Kinematics.h ****   // I'll fix later - AKA
  68:../Libraries/AQ_Kinematics/Kinematics.h ****   // returns heading in degrees as 0-360
  69:../Libraries/AQ_Kinematics/Kinematics.h **** const float kinematicsGetDegreesHeading(byte axis) {
 2572              		.loc 13 69 0
 2573              		.cfi_startproc
 2574              		@ args = 0, pretend = 0, frame = 0
 2575              		@ frame_needed = 0, uses_anonymous_args = 0
 2576              		@ link register save eliminated.
 2577              	.LVL172:
 2578              	.LBB200:
  70:../Libraries/AQ_Kinematics/Kinematics.h ****   float tDegrees;
  71:../Libraries/AQ_Kinematics/Kinematics.h ****     
  72:../Libraries/AQ_Kinematics/Kinematics.h ****   tDegrees = degrees(kinematicsAngle[axis]);
 2579              		.loc 13 72 0
 2580 0000 0A4B     		ldr	r3, .L153
 2581 0002 03EB8000 		add	r0, r3, r0, lsl #2
 2582              	.LVL173:
 2583 0006 90ED007A 		flds	s14, [r0, #0]
 2584 000a DFED097A 		flds	s15, .L153+4
 2585 000e 67EE277A 		fmuls	s15, s14, s15
 2586              	.LVL174:
  73:../Libraries/AQ_Kinematics/Kinematics.h ****   if (tDegrees < 0.0)
 2587              		.loc 13 73 0
 2588 0012 F5EEC07A 		fcmpezs	s15
 2589 0016 F1EE10FA 		fmstat
  74:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees + 360.0);
 2590              		.loc 13 74 0
 2591 001a 44BF     		itt	mi
 2592 001c 9FED057A 		fldsmi	s14, .L153+8
 2593 0020 77EE877A 		faddsmi	s15, s15, s14
 2594              	.LVL175:
 2595              	.LBE200:
  75:../Libraries/AQ_Kinematics/Kinematics.h ****   else
  76:../Libraries/AQ_Kinematics/Kinematics.h ****     return (tDegrees);
  77:../Libraries/AQ_Kinematics/Kinematics.h **** }
 2596              		.loc 13 77 0
 2597 0024 17EE900A 		fmrs	r0, s15
 2598              	.LVL176:
 2599 0028 7047     		bx	lr
 2600              	.L154:
 2601 002a 00BF     		.align	2
 2602              	.L153:
 2603 002c 00000000 		.word	.LANCHOR36
 2604 0030 E12E6542 		.word	1113927393
 2605 0034 0000B443 		.word	1135869952
 2606              		.cfi_endproc
 2607              	.LFE162:
 2609              		.global	__aeabi_f2d
 2610              		.global	__aeabi_d2f
 2611              		.section	.text._Z9argUpdatefffffff,"ax",%progbits
 2612              		.align	1
 2613              		.global	_Z9argUpdatefffffff
 2614              		.thumb
 2615              		.thumb_func
 2617              	_Z9argUpdatefffffff:
 2618              	.LFB163:
 2619              		.file 14 "../Libraries/AQ_Kinematics/Kinematics_ARG.h"
   1:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** /*
   2:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****  
   7:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  12:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  17:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** */
  20:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  21:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #ifndef _AQ_KINEMATICS_ARG_
  22:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #define _AQ_KINEMATICS_ARG_
  23:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  24:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  25:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // IMU.c
  26:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // S.O.H. Madgwick
  27:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // 25th September 2010
  28:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  29:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Description:
  30:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  31:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Quaternion implementation of the 'DCM filter' [Mayhony et al].
  32:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  33:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must define 'halfT' as the (sample period / 2), and the filter gains 'Kp' and 'Ki'.
  34:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  35:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Global variables 'q0', 'q1', 'q2', 'q3' are the quaternion elements representing the estimated
  36:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // orientation.  See my report for an overview of the use of quaternions in this application.
  37:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  38:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // User must call 'IMUupdate()' every sample period and parse calibrated gyroscope ('gx', 'gy', 'gz
  39:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // and accelerometer ('ax', 'ay', 'ay') data.  Gyroscope units are radians/second, accelerometer 
  40:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // units are irrelevant as the vector is normalised.
  41:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //
  42:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** //=================================================================================================
  43:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  44:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  45:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  46:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // ARG - Accelerometer, Rate Gyro
  47:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  48:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  49:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  50:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include "Kinematics.h"
  51:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  52:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** #include <AQMath.h>
  53:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  54:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Kp = 0.0;                   					// proportional gain governs rate of convergence to accelero
  55:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float Ki = 0.0;                   					// integral gain governs rate of convergence of gyroscope bi
  56:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float halfT = 0.0;                					// half the sample period
  57:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float q0 = 0.0, q1 = 0.0, q2 = 0.0, q3 = 0.0;       // quaternion elements representing the estimat
  58:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float exInt = 0.0, eyInt = 0.0, ezInt = 0.0;  		// scaled integral error
  59:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  60:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEx = 0.0;
  61:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEy = 0.0;
  62:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float previousEz = 0.0;
  63:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
  64:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  65:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // argUpdate
  66:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2620              		.loc 14 67 0
 2621              		.cfi_startproc
 2622              		@ args = 12, pretend = 0, frame = 0
 2623              		@ frame_needed = 0, uses_anonymous_args = 0
 2624              	.LVL177:
 2625 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2626              	.LCFI23:
 2627              		.cfi_def_cfa_offset 24
 2628              		.cfi_offset 3, -24
 2629              		.cfi_offset 4, -20
 2630              		.cfi_offset 5, -16
 2631              		.cfi_offset 6, -12
 2632              		.cfi_offset 7, -8
 2633              		.cfi_offset 14, -4
 2634 0002 2DED068B 		fstmfdd	sp!, {d8, d9, d10}
 2635              	.LCFI24:
 2636              		.cfi_def_cfa_offset 48
 2637              		.cfi_offset 80, -48
 2638              		.cfi_offset 82, -40
 2639              		.cfi_offset 84, -32
 2640              	.LBB201:
  68:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  69:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float norm;
  70:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float vx, vy, vz;
  71:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float q0i, q1i, q2i, q3i;
  72:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   float ex, ey, ez;
  73:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2641              		.loc 14 74 0
 2642 0006 9DED0E7A 		flds	s14, [sp, #56]
 2643 000a F6EE007A 		fconsts	s15, #96
 2644 000e 67EE277A 		fmuls	s15, s14, s15
 2645              	.LBE201:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2646              		.loc 14 67 0
 2647 0012 08EE103A 		fmsr	s16, r3
 2648 0016 9DED0C9A 		flds	s18, [sp, #48]
 2649              	.LBB202:
 2650              		.loc 14 74 0
 2651 001a 874B     		ldr	r3, .L168
 2652              	.LVL178:
  75:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
  76:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise the measurements
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
  81:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****      	
  82:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // estimated direction of gravity and flux (v and w)
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
  86:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  87:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // error is sum of cross product between reference direction of fields and direction measured by 
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
  91:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
  92:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integral error scaled integral gain
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2653              		.loc 14 93 0
 2654 001c 874C     		ldr	r4, .L168+4
 2655 001e 884E     		ldr	r6, .L168+8
  94:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEx,ex)) {
 2656              		.loc 14 94 0
 2657 0020 884D     		ldr	r5, .L168+12
  74:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   halfT = G_Dt/2;
 2658              		.loc 14 74 0
 2659 0022 C3ED007A 		fsts	s15, [r3, #0]
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2660              		.loc 14 77 0
 2661 0026 69EE097A 		fmuls	s15, s18, s18
 2662 002a 48EE087A 		fmacs	s15, s16, s16
 2663              	.LBE202:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2664              		.loc 14 67 0
 2665 002e DDED0D8A 		flds	s17, [sp, #52]
 2666              	.LBB203:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2667              		.loc 14 77 0
 2668 0032 48EEA87A 		fmacs	s15, s17, s17
 2669              	.LBE203:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2670              		.loc 14 67 0
 2671 0036 0AEE900A 		fmsr	s21, r0
 2672              	.LBB204:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2673              		.loc 14 77 0
 2674 003a 17EE900A 		fmrs	r0, s15
 2675              	.LVL179:
 2676              	.LBE204:
  67:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void argUpdate(float gx, float gy, float gz, float ax, float ay, float az, float G_Dt) {
 2677              		.loc 14 67 0
 2678 003e 09EE902A 		fmsr	s19, r2
 2679 0042 0AEE101A 		fmsr	s20, r1
 2680              	.LBB205:
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2681              		.loc 14 77 0
 2682 0046 FFF7FEFF 		bl	__aeabi_f2d
 2683              	.LVL180:
 2684 004a FFF7FEFF 		bl	sqrt
 2685              	.LVL181:
 2686 004e FFF7FEFF 		bl	__aeabi_d2f
 2687              	.LVL182:
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2688              		.loc 14 83 0
 2689 0052 7D4B     		ldr	r3, .L168+16
  77:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(ax*ax + ay*ay + az*az);       
 2690              		.loc 14 77 0
 2691 0054 07EE900A 		fmsr	s15, r0
 2692              	.LVL183:
  79:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ay = ay / norm;
 2693              		.loc 14 79 0
 2694 0058 89EE277A 		fdivs	s14, s18, s15
 2695              		.loc 14 94 0
 2696 005c 2868     		ldr	r0, [r5, #0]	@ float
 2697              	.LVL184:
  78:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ax = ax / norm;
 2698              		.loc 14 78 0
 2699 005e 88EE274A 		fdivs	s8, s16, s15
 2700              	.LVL185:
  80:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   az = az / norm;
 2701              		.loc 14 80 0
 2702 0062 C8EEA78A 		fdivs	s17, s17, s15
 2703              	.LVL186:
  83:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vx = 2*(q1*q3 - q0*q2);
 2704              		.loc 14 83 0
 2705 0066 D3ED007A 		flds	s15, [r3, #0]
 2706              	.LVL187:
 2707 006a 784B     		ldr	r3, .L168+20
 2708 006c D3ED006A 		flds	s13, [r3, #0]
 2709 0070 774B     		ldr	r3, .L168+24
 2710 0072 D3ED005A 		flds	s11, [r3, #0]
 2711 0076 774B     		ldr	r3, .L168+28
 2712 0078 93ED006A 		flds	s12, [r3, #0]
 2713 007c 65EE864A 		fmuls	s9, s11, s12
 2714 0080 57EEA64A 		fmscs	s9, s15, s13
 2715 0084 34EEA45A 		fadds	s10, s9, s9
 2716              	.LVL188:
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2717              		.loc 14 84 0
 2718 0088 66EE264A 		fmuls	s9, s12, s13
 2719 008c 45EEA74A 		fmacs	s9, s11, s15
  85:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vz = q0*q0 - q1*q1 - q2*q2 + q3*q3;
 2720              		.loc 14 85 0
 2721 0090 67EEA77A 		fmuls	s15, s15, s15
 2722 0094 55EEA57A 		fmscs	s15, s11, s11
 2723 0098 46EE467A 		fnmacs	s15, s12, s12
 2724 009c 46EEA67A 		fmacs	s15, s13, s13
  84:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   vy = 2*(q0*q1 + q2*q3);
 2725              		.loc 14 84 0
 2726 00a0 74EEA44A 		fadds	s9, s9, s9
 2727              	.LVL189:
  88:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ex = (vy*az - vz*ay);
 2728              		.loc 14 88 0
 2729 00a4 27EE879A 		fmuls	s18, s15, s14
 2730 00a8 14EEA89A 		fmscs	s18, s9, s17
 2731              	.LVL190:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 2732              		.loc 14 90 0
 2733 00ac 24EE848A 		fmuls	s16, s9, s8
  89:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ey = (vz*ax - vx*az);
 2734              		.loc 14 89 0
 2735 00b0 65EE288A 		fmuls	s17, s10, s17
 2736              	.LVL191:
 2737 00b4 57EE848A 		fmscs	s17, s15, s8
 2738              	.LVL192:
  90:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ez = (vx*ay - vy*ax);
 2739              		.loc 14 90 0
 2740 00b8 15EE078A 		fmscs	s16, s10, s14
 2741              	.LVL193:
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2742              		.loc 14 93 0
 2743 00bc D4ED007A 		flds	s15, [r4, #0]
 2744              	.LVL194:
 2745 00c0 96ED007A 		flds	s14, [r6, #0]
 2746              	.LVL195:
 2747 00c4 49EE077A 		fmacs	s15, s18, s14
 2748              		.loc 14 94 0
 2749 00c8 19EE101A 		fmrs	r1, s18
  93:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = exInt + ex*Ki;
 2750              		.loc 14 93 0
 2751 00cc C4ED007A 		fsts	s15, [r4, #0]
 2752              		.loc 14 94 0
 2753 00d0 FFF7FEFF 		bl	_Z10isSwitchedff
 2754              	.LVL196:
 2755 00d4 08B1     		cbz	r0, .L156
  95:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     exInt = 0.0;
 2756              		.loc 14 95 0
 2757 00d6 0023     		movs	r3, #0
 2758 00d8 2360     		str	r3, [r4, #0]	@ float
 2759              	.L156:
  96:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
  98:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2760              		.loc 14 99 0
 2761 00da 5F4C     		ldr	r4, .L168+32
 2762 00dc 96ED007A 		flds	s14, [r6, #0]
 2763 00e0 D4ED007A 		flds	s15, [r4, #0]
 2764 00e4 48EE877A 		fmacs	s15, s17, s14
  97:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = ex;
 2765              		.loc 14 97 0
 2766 00e8 85ED009A 		fsts	s18, [r5, #0]
 100:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEy,ey)) {
 2767              		.loc 14 100 0
 2768 00ec 5B4D     		ldr	r5, .L168+36
 2769 00ee 18EE901A 		fmrs	r1, s17
 2770 00f2 2868     		ldr	r0, [r5, #0]	@ float
  99:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = eyInt + ey*Ki;
 2771              		.loc 14 99 0
 2772 00f4 C4ED007A 		fsts	s15, [r4, #0]
 2773              		.loc 14 100 0
 2774 00f8 FFF7FEFF 		bl	_Z10isSwitchedff
 2775              	.LVL197:
 2776 00fc 08B1     		cbz	r0, .L157
 101:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     eyInt = 0.0;
 2777              		.loc 14 101 0
 2778 00fe 0023     		movs	r3, #0
 2779 0100 2360     		str	r3, [r4, #0]	@ float
 2780              	.L157:
 102:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 104:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 2781              		.loc 14 105 0
 2782 0102 574C     		ldr	r4, .L168+40
 2783 0104 4E4B     		ldr	r3, .L168+8
 2784 0106 D4ED007A 		flds	s15, [r4, #0]
 2785 010a 93ED007A 		flds	s14, [r3, #0]
 2786 010e 48EE077A 		fmacs	s15, s16, s14
 103:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = ey;
 2787              		.loc 14 103 0
 2788 0112 C5ED008A 		fsts	s17, [r5, #0]
 106:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   if (isSwitched(previousEz,ez)) {
 2789              		.loc 14 106 0
 2790 0116 534D     		ldr	r5, .L168+44
 2791 0118 18EE101A 		fmrs	r1, s16
 2792 011c 2868     		ldr	r0, [r5, #0]	@ float
 105:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = ezInt + ez*Ki;
 2793              		.loc 14 105 0
 2794 011e C4ED007A 		fsts	s15, [r4, #0]
 2795              		.loc 14 106 0
 2796 0122 FFF7FEFF 		bl	_Z10isSwitchedff
 2797              	.LVL198:
 2798 0126 08B1     		cbz	r0, .L158
 107:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     ezInt = 0.0;
 2799              		.loc 14 107 0
 2800 0128 0023     		movs	r3, #0
 2801 012a 2360     		str	r3, [r4, #0]	@ float
 2802              	.L158:
 108:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   }
 109:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = ez;
 110:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 111:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // adjusted gyroscope measurements
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2803              		.loc 14 112 0
 2804 012c 4E4B     		ldr	r3, .L168+48
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 115:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 116:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // integrate quaternion rate and normalise
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2805              		.loc 14 117 0
 2806 012e 464E     		ldr	r6, .L168+16
 2807 0130 464C     		ldr	r4, .L168+20
 118:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1i = ( q0*gx + q2*gz - q3*gy) * halfT;
 2808              		.loc 14 118 0
 2809 0132 474F     		ldr	r7, .L168+24
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2810              		.loc 14 112 0
 2811 0134 D3ED007A 		flds	s15, [r3, #0]
 2812 0138 404B     		ldr	r3, .L168+4
 2813 013a 47EE89AA 		fmacs	s21, s15, s18
 2814              	.LVL199:
 2815 013e 93ED007A 		flds	s14, [r3, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2816              		.loc 14 113 0
 2817 0142 07EEA8AA 		fmacs	s20, s15, s17
 2818              	.LVL200:
 2819 0146 444B     		ldr	r3, .L168+32
 109:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = ez;
 2820              		.loc 14 109 0
 2821 0148 85ED008A 		fsts	s16, [r5, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2822              		.loc 14 113 0
 2823 014c D3ED006A 		flds	s13, [r3, #0]
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2824              		.loc 14 117 0
 2825 0150 404D     		ldr	r5, .L168+28
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 2826              		.loc 14 114 0
 2827 0152 434B     		ldr	r3, .L168+40
 2828 0154 47EE889A 		fmacs	s19, s15, s16
 2829              	.LVL201:
 112:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gx = gx + Kp*ex + exInt;
 2830              		.loc 14 112 0
 2831 0158 3AEE875A 		fadds	s10, s21, s14
 2832              	.LVL202:
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2833              		.loc 14 117 0
 2834 015c D5ED004A 		flds	s9, [r5, #0]
 113:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gy = gy + Kp*ey + eyInt;
 2835              		.loc 14 113 0
 2836 0160 3AEE267A 		fadds	s14, s20, s13
 2837              	.LVL203:
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 2838              		.loc 14 114 0
 2839 0164 D3ED007A 		flds	s15, [r3, #0]
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2840              		.loc 14 117 0
 2841 0168 96ED003A 		flds	s6, [r6, #0]
 114:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   gz = gz + Kp*ez + ezInt;
 2842              		.loc 14 114 0
 2843 016c 39EEA74A 		fadds	s8, s19, s15
 2844              	.LVL204:
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2845              		.loc 14 117 0
 2846 0170 64EE877A 		fmuls	s15, s9, s14
 2847 0174 53EE457A 		fnmscs	s15, s6, s10
 2848 0178 94ED006A 		flds	s12, [r4, #0]
 2849 017c 2E4B     		ldr	r3, .L168
 2850 017e 46EE447A 		fnmacs	s15, s12, s8
 2851              		.loc 14 118 0
 2852 0182 D7ED003A 		flds	s7, [r7, #0]
 117:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0i = (-q1*gx - q2*gy - q3*gz) * halfT;
 2853              		.loc 14 117 0
 2854 0186 D3ED005A 		flds	s11, [r3, #0]
 2855              	.LVL205:
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2856              		.loc 14 121 0
 2857 018a F0EE632A 		fcpys	s5, s7
 2858 018e 47EEA52A 		fmacs	s5, s15, s11
 118:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1i = ( q0*gx + q2*gz - q3*gy) * halfT;
 2859              		.loc 14 118 0
 2860 0192 64EE847A 		fmuls	s15, s9, s8
 2861 0196 43EE857A 		fmacs	s15, s7, s10
 2862 019a 46EE477A 		fnmacs	s15, s12, s14
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 2863              		.loc 14 119 0
 2864 019e 63EE046A 		fmuls	s13, s6, s8
 2865 01a2 53EE876A 		fmscs	s13, s7, s14
 122:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 += q1i;
 2866              		.loc 14 122 0
 2867 01a6 B0EE432A 		fcpys	s4, s6
 2868 01aa 07EEA52A 		fmacs	s4, s15, s11
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2869              		.loc 14 120 0
 2870 01ae 23EE077A 		fmuls	s14, s6, s14
 2871              	.LVL206:
 119:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2i = ( q0*gy - q1*gz + q3*gx) * halfT;
 2872              		.loc 14 119 0
 2873 01b2 46EE056A 		fmacs	s13, s12, s10
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2874              		.loc 14 120 0
 2875 01b6 03EE847A 		fmacs	s14, s7, s8
 2876              		.loc 14 122 0
 2877 01ba F0EE427A 		fcpys	s15, s4
 120:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3i = ( q0*gz + q1*gy - q2*gx) * halfT;
 2878              		.loc 14 120 0
 2879 01be 04EEC57A 		fnmacs	s14, s9, s10
 2880              		.loc 14 122 0
 2881 01c2 86ED002A 		fsts	s4, [r6, #0]
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 2882              		.loc 14 123 0
 2883 01c6 B0EE642A 		fcpys	s4, s9
 2884 01ca 06EEA52A 		fmacs	s4, s13, s11
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 125:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 126:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   // normalise quaternion
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 2885              		.loc 14 127 0
 2886 01ce 67EEA77A 		fmuls	s15, s15, s15
 2887 01d2 42EEA27A 		fmacs	s15, s5, s5
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 2888              		.loc 14 124 0
 2889 01d6 07EE256A 		fmacs	s12, s14, s11
 2890              	.LVL207:
 2891              		.loc 14 127 0
 2892 01da 42EE027A 		fmacs	s15, s4, s4
 2893 01de 46EE067A 		fmacs	s15, s12, s12
 121:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 += q0i;
 2894              		.loc 14 121 0
 2895 01e2 C7ED002A 		fsts	s5, [r7, #0]
 2896              		.loc 14 127 0
 2897 01e6 17EE900A 		fmrs	r0, s15
 123:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 += q2i;
 2898              		.loc 14 123 0
 2899 01ea 85ED002A 		fsts	s4, [r5, #0]
 124:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 += q3i;
 2900              		.loc 14 124 0
 2901 01ee 84ED006A 		fsts	s12, [r4, #0]
 2902              		.loc 14 127 0
 2903 01f2 FFF7FEFF 		bl	__aeabi_f2d
 2904              	.LVL208:
 2905 01f6 FFF7FEFF 		bl	sqrt
 2906              	.LVL209:
 2907 01fa FFF7FEFF 		bl	__aeabi_d2f
 2908              	.LVL210:
 128:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = q0 / norm;
 2909              		.loc 14 128 0
 2910 01fe 97ED007A 		flds	s14, [r7, #0]
 127:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
 2911              		.loc 14 127 0
 2912 0202 07EE900A 		fmsr	s15, r0
 2913              	.LVL211:
 2914              		.loc 14 128 0
 2915 0206 87EE277A 		fdivs	s14, s14, s15
 2916 020a 87ED007A 		fsts	s14, [r7, #0]
 129:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = q1 / norm;
 2917              		.loc 14 129 0
 2918 020e 96ED007A 		flds	s14, [r6, #0]
 2919 0212 87EE277A 		fdivs	s14, s14, s15
 2920 0216 86ED007A 		fsts	s14, [r6, #0]
 130:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = q2 / norm;
 2921              		.loc 14 130 0
 2922 021a 95ED007A 		flds	s14, [r5, #0]
 2923 021e 87EE277A 		fdivs	s14, s14, s15
 2924 0222 85ED007A 		fsts	s14, [r5, #0]
 131:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = q3 / norm;
 2925              		.loc 14 131 0
 2926 0226 94ED007A 		flds	s14, [r4, #0]
 2927 022a C7EE277A 		fdivs	s15, s14, s15
 2928 022e C4ED007A 		fsts	s15, [r4, #0]
 2929              	.LBE205:
 132:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 2930              		.loc 14 132 0
 2931 0232 BDEC068B 		fldmfdd	sp!, {d8, d9, d10}
 2932 0236 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2933              	.L169:
 2934              		.align	2
 2935              	.L168:
 2936 0238 00000000 		.word	.LANCHOR37
 2937 023c 00000000 		.word	.LANCHOR42
 2938 0240 00000000 		.word	.LANCHOR43
 2939 0244 00000000 		.word	.LANCHOR44
 2940 0248 00000000 		.word	.LANCHOR38
 2941 024c 00000000 		.word	.LANCHOR39
 2942 0250 00000000 		.word	.LANCHOR40
 2943 0254 00000000 		.word	.LANCHOR41
 2944 0258 00000000 		.word	.LANCHOR45
 2945 025c 00000000 		.word	.LANCHOR46
 2946 0260 00000000 		.word	.LANCHOR47
 2947 0264 00000000 		.word	.LANCHOR48
 2948 0268 00000000 		.word	.LANCHOR49
 2949              		.cfi_endproc
 2950              	.LFE163:
 2952              		.section	.text._Z11eulerAnglesv,"ax",%progbits
 2953              		.align	1
 2954              		.global	_Z11eulerAnglesv
 2955              		.thumb
 2956              		.thumb_func
 2958              	_Z11eulerAnglesv:
 2959              	.LFB164:
 133:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 134:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void eulerAngles()
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 2960              		.loc 14 135 0
 2961              		.cfi_startproc
 2962              		@ args = 0, pretend = 0, frame = 0
 2963              		@ frame_needed = 0, uses_anonymous_args = 0
 2964 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, sl, lr}
 2965              	.LCFI25:
 2966              		.cfi_def_cfa_offset 32
 2967              		.cfi_offset 4, -32
 2968              		.cfi_offset 5, -28
 2969              		.cfi_offset 6, -24
 2970              		.cfi_offset 7, -20
 2971              		.cfi_offset 8, -16
 2972              		.cfi_offset 9, -12
 2973              		.cfi_offset 10, -8
 2974              		.cfi_offset 14, -4
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 2975              		.loc 14 136 0
 2976 0004 DFF8F890 		ldr	r9, .L171+8
 2977 0008 DFF8F8A0 		ldr	sl, .L171+12
 2978 000c 3A4F     		ldr	r7, .L171
 2979 000e DFF8F880 		ldr	r8, .L171+16
 2980 0012 3A4E     		ldr	r6, .L171+4
 135:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 2981              		.loc 14 135 0
 2982 0014 2DED048B 		fstmfdd	sp!, {d8, d9}
 2983              	.LCFI26:
 2984              		.cfi_def_cfa_offset 48
 2985              		.cfi_offset 80, -48
 2986              		.cfi_offset 82, -40
 2987              		.loc 14 136 0
 2988 0018 9AED007A 		flds	s14, [sl, #0]
 2989 001c D9ED008A 		flds	s17, [r9, #0]
 2990 0020 97ED008A 		flds	s16, [r7, #0]
 2991 0024 D8ED007A 		flds	s15, [r8, #0]
 2992 0028 28EE877A 		fmuls	s14, s17, s14
 2993 002c 08EE277A 		fmacs	s14, s16, s15
 2994 0030 B7EE009A 		fconsts	s18, #112
 2995 0034 37EE077A 		fadds	s14, s14, s14
 2996 0038 17EE100A 		fmrs	r0, s14
 2997 003c FFF7FEFF 		bl	__aeabi_f2d
 2998              	.LVL212:
 2999 0040 68EEA87A 		fmuls	s15, s17, s17
 3000 0044 48EE087A 		fmacs	s15, s16, s16
 3001 0048 0446     		mov	r4, r0
 3002 004a 77EEA77A 		fadds	s15, s15, s15
 3003 004e 0D46     		mov	r5, r1
 3004 0050 79EE677A 		fsubs	s15, s18, s15
 3005 0054 17EE900A 		fmrs	r0, s15
 3006 0058 FFF7FEFF 		bl	__aeabi_f2d
 3007              	.LVL213:
 3008 005c 0246     		mov	r2, r0
 3009 005e 0B46     		mov	r3, r1
 3010 0060 2046     		mov	r0, r4
 3011 0062 2946     		mov	r1, r5
 3012 0064 FFF7FEFF 		bl	atan2
 3013              	.LVL214:
 3014 0068 FFF7FEFF 		bl	__aeabi_d2f
 3015              	.LVL215:
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3016              		.loc 14 137 0
 3017 006c 97ED006A 		flds	s12, [r7, #0]
 3018 0070 DAED007A 		flds	s15, [sl, #0]
 3019 0074 D8ED006A 		flds	s13, [r8, #0]
 3020 0078 99ED007A 		flds	s14, [r9, #0]
 3021 007c 66EE277A 		fmuls	s15, s12, s15
 3022 0080 56EE877A 		fmscs	s15, s13, s14
 136:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[XAXIS]  = atan2(2 * (q0*q1 + q2*q3), 1 - 2 *(q1*q1 + q2*q2));
 3023              		.loc 14 136 0
 3024 0084 3060     		str	r0, [r6, #0]	@ float
 3025              		.loc 14 137 0
 3026 0086 77EEA77A 		fadds	s15, s15, s15
 3027 008a 17EE900A 		fmrs	r0, s15
 3028 008e FFF7FEFF 		bl	__aeabi_f2d
 3029              	.LVL216:
 3030 0092 FFF7FEFF 		bl	asin
 3031              	.LVL217:
 3032 0096 FFF7FEFF 		bl	__aeabi_d2f
 3033              	.LVL218:
 138:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[ZAXIS]   = atan2(2 * (q0*q3 + q1*q2), 1 - 2 *(q2*q2 + q3*q3));
 3034              		.loc 14 138 0
 3035 009a 99ED008A 		flds	s16, [r9, #0]
 3036 009e 97ED007A 		flds	s14, [r7, #0]
 3037 00a2 D8ED007A 		flds	s15, [r8, #0]
 3038 00a6 DAED008A 		flds	s17, [sl, #0]
 3039 00aa 28EE077A 		fmuls	s14, s16, s14
 3040 00ae 08EEA77A 		fmacs	s14, s17, s15
 137:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   kinematicsAngle[YAXIS] = asin(2 * (q0*q2 - q1*q3));
 3041              		.loc 14 137 0
 3042 00b2 7060     		str	r0, [r6, #4]	@ float
 3043              		.loc 14 138 0
 3044 00b4 37EE077A 		fadds	s14, s14, s14
 3045 00b8 17EE100A 		fmrs	r0, s14
 3046 00bc FFF7FEFF 		bl	__aeabi_f2d
 3047              	.LVL219:
 3048 00c0 68EEA87A 		fmuls	s15, s17, s17
 3049 00c4 48EE087A 		fmacs	s15, s16, s16
 3050 00c8 0446     		mov	r4, r0
 3051 00ca 77EEA77A 		fadds	s15, s15, s15
 3052 00ce 0D46     		mov	r5, r1
 3053 00d0 79EE677A 		fsubs	s15, s18, s15
 3054 00d4 17EE900A 		fmrs	r0, s15
 3055 00d8 FFF7FEFF 		bl	__aeabi_f2d
 3056              	.LVL220:
 3057 00dc 0246     		mov	r2, r0
 3058 00de 0B46     		mov	r3, r1
 3059 00e0 2046     		mov	r0, r4
 3060 00e2 2946     		mov	r1, r5
 3061 00e4 FFF7FEFF 		bl	atan2
 3062              	.LVL221:
 3063 00e8 FFF7FEFF 		bl	__aeabi_d2f
 3064              	.LVL222:
 3065 00ec B060     		str	r0, [r6, #8]	@ float
 139:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3066              		.loc 14 139 0
 3067 00ee BDEC048B 		fldmfdd	sp!, {d8, d9}
 3068 00f2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 3069              	.L172:
 3070 00f6 00BF     		.align	2
 3071              	.L171:
 3072 00f8 00000000 		.word	.LANCHOR38
 3073 00fc 00000000 		.word	.LANCHOR36
 3074 0100 00000000 		.word	.LANCHOR41
 3075 0104 00000000 		.word	.LANCHOR39
 3076 0108 00000000 		.word	.LANCHOR40
 3077              		.cfi_endproc
 3078              	.LFE164:
 3080              		.section	.text._Z20initializeKinematicsv,"ax",%progbits
 3081              		.align	1
 3082              		.global	_Z20initializeKinematicsv
 3083              		.thumb
 3084              		.thumb_func
 3086              	_Z20initializeKinematicsv:
 3087              	.LFB165:
 140:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 141:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 142:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Initialize ARG
 143:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 144:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 145:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void initializeKinematics() 
 146:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** {
 3088              		.loc 14 146 0
 3089              		.cfi_startproc
 3090              		@ args = 0, pretend = 0, frame = 0
 3091              		@ frame_needed = 0, uses_anonymous_args = 0
 3092 0000 08B5     		push	{r3, lr}
 3093              	.LCFI27:
 3094              		.cfi_def_cfa_offset 8
 3095              		.cfi_offset 3, -8
 3096              		.cfi_offset 14, -4
 147:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   initializeBaseKinematicsParam();
 3097              		.loc 14 147 0
 3098 0002 FFF7FEFF 		bl	_Z29initializeBaseKinematicsParamv
 3099              	.LVL223:
 148:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q0 = 1.0;
 3100              		.loc 14 148 0
 3101 0006 0F4B     		ldr	r3, .L174
 3102 0008 4FF07E52 		mov	r2, #1065353216
 3103 000c 1A60     		str	r2, [r3, #0]	@ float
 149:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q1 = 0.0;
 3104              		.loc 14 149 0
 3105 000e 0E4A     		ldr	r2, .L174+4
 3106 0010 0023     		movs	r3, #0
 3107 0012 1360     		str	r3, [r2, #0]	@ float
 150:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q2 = 0.0;
 3108              		.loc 14 150 0
 3109 0014 0D4A     		ldr	r2, .L174+8
 3110 0016 1360     		str	r3, [r2, #0]	@ float
 151:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   q3 = 0.0;
 3111              		.loc 14 151 0
 3112 0018 0D4A     		ldr	r2, .L174+12
 3113 001a 1360     		str	r3, [r2, #0]	@ float
 152:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   exInt = 0.0;
 3114              		.loc 14 152 0
 3115 001c 0D4A     		ldr	r2, .L174+16
 3116 001e 1360     		str	r3, [r2, #0]	@ float
 153:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eyInt = 0.0;
 3117              		.loc 14 153 0
 3118 0020 0D4A     		ldr	r2, .L174+20
 3119 0022 1360     		str	r3, [r2, #0]	@ float
 154:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   ezInt = 0.0;
 3120              		.loc 14 154 0
 3121 0024 0D4A     		ldr	r2, .L174+24
 3122 0026 1360     		str	r3, [r2, #0]	@ float
 155:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 	
 156:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEx = 0;
 3123              		.loc 14 156 0
 3124 0028 0D4A     		ldr	r2, .L174+28
 3125 002a 1360     		str	r3, [r2, #0]	@ float
 157:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEy = 0;
 3126              		.loc 14 157 0
 3127 002c 0D4A     		ldr	r2, .L174+32
 3128 002e 1360     		str	r3, [r2, #0]	@ float
 158:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   previousEz = 0;
 3129              		.loc 14 158 0
 3130 0030 0D4A     		ldr	r2, .L174+36
 3131 0032 1360     		str	r3, [r2, #0]	@ float
 159:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 
 160:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Kp = 0.2; // 2.0;
 3132              		.loc 14 160 0
 3133 0034 0D4A     		ldr	r2, .L174+40
 3134 0036 0E4B     		ldr	r3, .L174+44
 3135 0038 1A60     		str	r2, [r3, #0]	@ float
 161:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   Ki = 0.0005; //0.005;
 3136              		.loc 14 161 0
 3137 003a 0E4A     		ldr	r2, .L174+48
 3138 003c 0E4B     		ldr	r3, .L174+52
 3139 003e 1A60     		str	r2, [r3, #0]	@ float
 3140 0040 08BD     		pop	{r3, pc}
 3141              	.L175:
 3142 0042 00BF     		.align	2
 3143              	.L174:
 3144 0044 00000000 		.word	.LANCHOR40
 3145 0048 00000000 		.word	.LANCHOR38
 3146 004c 00000000 		.word	.LANCHOR41
 3147 0050 00000000 		.word	.LANCHOR39
 3148 0054 00000000 		.word	.LANCHOR42
 3149 0058 00000000 		.word	.LANCHOR45
 3150 005c 00000000 		.word	.LANCHOR47
 3151 0060 00000000 		.word	.LANCHOR44
 3152 0064 00000000 		.word	.LANCHOR46
 3153 0068 00000000 		.word	.LANCHOR48
 3154 006c CDCC4C3E 		.word	1045220557
 3155 0070 00000000 		.word	.LANCHOR49
 3156 0074 6F12033A 		.word	973279855
 3157 0078 00000000 		.word	.LANCHOR43
 3158              		.cfi_endproc
 3159              	.LFE165:
 3161              		.section	.text._Z19calculateKinematicsfffffff,"ax",%progbits
 3162              		.align	1
 3163              		.global	_Z19calculateKinematicsfffffff
 3164              		.thumb
 3165              		.thumb_func
 3167              	_Z19calculateKinematicsfffffff:
 3168              	.LFB166:
 162:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 163:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 164:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 165:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** // Calculate ARG
 166:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** ////////////////////////////////////////////////////////////////////////////////
 167:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calculateKinematics(float rollRate,          float pitchRate,    float yawRate,  
 168:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float longitudinalAccel, float lateralAccel, float verticalAccel, 
 169:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****                          float G_DT) {
 3169              		.loc 14 169 0
 3170              		.cfi_startproc
 3171              		@ args = 12, pretend = 0, frame = 0
 3172              		@ frame_needed = 0, uses_anonymous_args = 0
 3173              	.LVL224:
 3174 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 3175              	.LCFI28:
 3176              		.cfi_def_cfa_offset 24
 3177              		.cfi_offset 0, -24
 3178              		.cfi_offset 1, -20
 3179              		.cfi_offset 2, -16
 3180              		.cfi_offset 3, -12
 3181              		.cfi_offset 4, -8
 3182              		.cfi_offset 14, -4
 170:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****     
 171:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   argUpdate(rollRate,          pitchRate,    yawRate, 
 172:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****             longitudinalAccel, lateralAccel, verticalAccel,  
 173:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** 		    G_Dt);
 3183              		.loc 14 173 0
 3184 0002 069C     		ldr	r4, [sp, #24]	@ float
 3185 0004 0094     		str	r4, [sp, #0]	@ float
 3186 0006 079C     		ldr	r4, [sp, #28]	@ float
 3187 0008 0194     		str	r4, [sp, #4]	@ float
 3188 000a 054C     		ldr	r4, .L177
 3189 000c 2468     		ldr	r4, [r4, #0]	@ float
 3190 000e 0294     		str	r4, [sp, #8]	@ float
 3191 0010 FFF7FEFF 		bl	_Z9argUpdatefffffff
 3192              	.LVL225:
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 175:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3193              		.loc 14 175 0
 3194 0014 04B0     		add	sp, sp, #16
 3195 0016 BDE81040 		pop	{r4, lr}
 174:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   eulerAngles();
 3196              		.loc 14 174 0
 3197 001a FFF7FEBF 		b	_Z11eulerAnglesv
 3198              	.LVL226:
 3199              	.L178:
 3200 001e 00BF     		.align	2
 3201              	.L177:
 3202 0020 00000000 		.word	.LANCHOR50
 3203              		.cfi_endproc
 3204              	.LFE166:
 3206              		.section	.text._Z13getGyroUnbiash,"ax",%progbits
 3207              		.align	1
 3208              		.global	_Z13getGyroUnbiash
 3209              		.thumb
 3210              		.thumb_func
 3212              	_Z13getGyroUnbiash:
 3213              	.LFB167:
 176:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 177:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** float getGyroUnbias(byte axis) {
 3214              		.loc 14 177 0
 3215              		.cfi_startproc
 3216              		@ args = 0, pretend = 0, frame = 0
 3217              		@ frame_needed = 0, uses_anonymous_args = 0
 3218              		@ link register save eliminated.
 3219              	.LVL227:
 178:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   return correctedRateVector[axis];
 3220              		.loc 14 178 0
 3221 0000 024B     		ldr	r3, .L180
 3222 0002 03EB8000 		add	r0, r3, r0, lsl #2
 3223              	.LVL228:
 179:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** }
 3224              		.loc 14 179 0
 3225 0006 0068     		ldr	r0, [r0, #0]	@ float
 3226 0008 7047     		bx	lr
 3227              	.L181:
 3228 000a 00BF     		.align	2
 3229              	.L180:
 3230 000c 00000000 		.word	.LANCHOR51
 3231              		.cfi_endproc
 3232              	.LFE167:
 3234              		.section	.text._Z19calibrateKinematicsv,"ax",%progbits
 3235              		.align	1
 3236              		.global	_Z19calibrateKinematicsv
 3237              		.thumb
 3238              		.thumb_func
 3240              	_Z19calibrateKinematicsv:
 3241              	.LFB168:
 180:../Libraries/AQ_Kinematics/Kinematics_ARG.h ****   
 181:../Libraries/AQ_Kinematics/Kinematics_ARG.h **** void calibrateKinematics() {}
 3242              		.loc 14 181 0
 3243              		.cfi_startproc
 3244              		@ args = 0, pretend = 0, frame = 0
 3245              		@ frame_needed = 0, uses_anonymous_args = 0
 3246              		@ link register save eliminated.
 3247 0000 7047     		bx	lr
 3248              		.cfi_endproc
 3249              	.LFE168:
 3251              		.section	.text._Z7FrqInitiP9timer_devi,"ax",%progbits
 3252              		.align	1
 3253              		.global	_Z7FrqInitiP9timer_devi
 3254              		.thumb
 3255              		.thumb_func
 3257              	_Z7FrqInitiP9timer_devi:
 3258              	.LFB169:
  48:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3259              		.loc 3 48 0
 3260              		.cfi_startproc
 3261              		@ args = 0, pretend = 0, frame = 0
 3262              		@ frame_needed = 0, uses_anonymous_args = 0
 3263              	.LVL229:
  48:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3264              		.loc 3 48 0
 3265 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3266              	.LCFI29:
 3267              		.cfi_def_cfa_offset 24
 3268              		.cfi_offset 3, -24
 3269              		.cfi_offset 4, -20
 3270              		.cfi_offset 5, -16
 3271              		.cfi_offset 6, -12
 3272              		.cfi_offset 7, -8
 3273              		.cfi_offset 14, -4
 3274              	.LBB206:
  51:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerDev     = aTimer;
 3275              		.loc 3 51 0
 3276 0002 234D     		ldr	r5, .L186
 3277 0004 2960     		str	r1, [r5, #0]
  52:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_gen_reg_map *timer = aTimer->regs.gen;
 3278              		.loc 3 52 0
 3279 0006 0C68     		ldr	r4, [r1, #0]
  49:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   aTimerChannel--;  // transform timer channel numbering from 1-4 to 0-3
 3280              		.loc 3 49 0
 3281 0008 561E     		subs	r6, r2, #1
 3282              	.LVL230:
  55:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3283              		.loc 3 55 0
 3284 000a B300     		lsls	r3, r6, #2
  58:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   int TimerEnable = (1 << (4*aTimerChannel));
 3285              		.loc 3 58 0
 3286 000c 0127     		movs	r7, #1
 3287 000e 07FA03F7 		lsl	r7, r7, r3
 3288              	.LVL231:
  55:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3289              		.loc 3 55 0
 3290 0012 04F13402 		add	r2, r4, #52
 3291 0016 D218     		adds	r2, r2, r3
  59:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
 3292              		.loc 3 59 0
 3293 0018 7B00     		lsls	r3, r7, #1
  53:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerRegs    = timer;
 3294              		.loc 3 53 0
 3295 001a 6C60     		str	r4, [r5, #4]
  55:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.Timer_ccr    = &timer->CCR1 + aTimerChannel;
 3296              		.loc 3 55 0
 3297 001c AA60     		str	r2, [r5, #8]
  56:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.TimerChannel = aTimerChannel;
 3298              		.loc 3 56 0
 3299 001e 2E61     		str	r6, [r5, #16]
  59:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   FrqData.PolarityMask = TimerEnable << 1;
 3300              		.loc 3 59 0
 3301 0020 6B61     		str	r3, [r5, #20]
  61:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   uint32 clock_speed = rcc_dev_timer_clk_speed(FrqData.TimerDev->clk_id);
 3302              		.loc 3 61 0
 3303 0022 2B68     		ldr	r3, [r5, #0]
 3304 0024 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 3305              	.LVL232:
 3306 0026 FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 3307              	.LVL233:
  62:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->PSC	= (clock_speed/1000000)-1;
 3308              		.loc 3 62 0
 3309 002a 1A4B     		ldr	r3, .L186+4
 3310 002c B0FBF3F0 		udiv	r0, r0, r3
 3311              	.LVL234:
 3312 0030 431E     		subs	r3, r0, #1
 3313 0032 A362     		str	r3, [r4, #40]
  63:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->ARR	= 0xffff;
 3314              		.loc 3 63 0
 3315 0034 4FF6FF73 		movw	r3, #65535
 3316 0038 E362     		str	r3, [r4, #44]
  64:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1	= 0;
 3317              		.loc 3 64 0
 3318 003a 0023     		movs	r3, #0
 3319 003c 2360     		str	r3, [r4, #0]
  65:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->DIER &= ~(1);
 3320              		.loc 3 65 0
 3321 003e E368     		ldr	r3, [r4, #12]
 3322 0040 23F00103 		bic	r3, r3, #1
 3323 0044 E360     		str	r3, [r4, #12]
  67:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~TimerEnable; // Disable timer
 3324              		.loc 3 67 0
 3325 0046 236A     		ldr	r3, [r4, #32]
 3326 0048 23EA0703 		bic	r3, r3, r7
 3327 004c 2362     		str	r3, [r4, #32]
  68:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 3328              		.loc 3 68 0
 3329 004e 6A69     		ldr	r2, [r5, #20]
 3330 0050 236A     		ldr	r3, [r4, #32]
  71:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(aTimerChannel < 2) {
 3331              		.loc 3 71 0
 3332 0052 012E     		cmp	r6, #1
  68:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER &= ~(FrqData.PolarityMask);
 3333              		.loc 3 68 0
 3334 0054 23EA0203 		bic	r3, r3, r2
 3335 0058 2362     		str	r3, [r4, #32]
  72:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR1);
 3336              		.loc 3 72 0
 3337 005a D4BF     		ite	le
 3338 005c 04F11803 		addle	r3, r4, #24
 3339              	.LVL235:
  75:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     mr = &(timer->CCMR2);
 3340              		.loc 3 75 0
 3341 0060 04F11C03 		addgt	r3, r4, #28
 3342              	.LVL236:
  77:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr &= ~(0xFF << (8*(aTimerChannel&1)));	// prescaler 1
 3343              		.loc 3 77 0
 3344 0064 06F00106 		and	r6, r6, #1
 3345              	.LVL237:
 3346 0068 1968     		ldr	r1, [r3, #0]
 3347 006a F600     		lsls	r6, r6, #3
 3348 006c FF22     		movs	r2, #255
 3349 006e 02FA06F2 		lsl	r2, r2, r6
 3350 0072 21EA0202 		bic	r2, r1, r2
 3351 0076 1A60     		str	r2, [r3, #0]
  78:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   *mr |= 0x61 << (8*(aTimerChannel&1));		// 0x61 -> 6=filter, 1=inputs 1,2,3,4
 3352              		.loc 3 78 0
 3353 0078 1A68     		ldr	r2, [r3, #0]
 3354 007a 6121     		movs	r1, #97
 3355 007c 01FA06F6 		lsl	r6, r1, r6
 3356 0080 1643     		orrs	r6, r6, r2
 3357 0082 1E60     		str	r6, [r3, #0]
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 3358              		.loc 3 80 0
 3359 0084 236A     		ldr	r3, [r4, #32]
 3360              	.LVL238:
 3361 0086 1F43     		orrs	r7, r7, r3
 3362              	.LVL239:
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 3363              		.loc 3 81 0
 3364 0088 0123     		movs	r3, #1
 3365              	.LVL240:
  80:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CCER |= TimerEnable; // Enable
 3366              		.loc 3 80 0
 3367 008a 2762     		str	r7, [r4, #32]
  81:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer->CR1 = 1;
 3368              		.loc 3 81 0
 3369 008c 2360     		str	r3, [r4, #0]
 3370 008e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3371              	.L187:
 3372              		.align	2
 3373              	.L186:
 3374 0090 00000000 		.word	.LANCHOR0
 3375 0094 40420F00 		.word	1000000
 3376              	.LBE206:
 3377              		.cfi_endproc
 3378              	.LFE169:
 3380              		.section	.text._Z18InitFrqMeasurementv,"ax",%progbits
 3381              		.align	1
 3382              		.global	_Z18InitFrqMeasurementv
 3383              		.thumb
 3384              		.thumb_func
 3386              	_Z18InitFrqMeasurementv:
 3387              	.LFB171:
 106:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** {
 3388              		.loc 3 106 0
 3389              		.cfi_startproc
 3390              		@ args = 0, pretend = 0, frame = 0
 3391              		@ frame_needed = 0, uses_anonymous_args = 0
 3392              	.LVL241:
 3393 0000 38B5     		push	{r3, r4, r5, lr}
 3394              	.LCFI30:
 3395              		.cfi_def_cfa_offset 16
 3396              		.cfi_offset 3, -16
 3397              		.cfi_offset 4, -12
 3398              		.cfi_offset 5, -8
 3399              		.cfi_offset 14, -4
 3400              	.LBB207:
 108:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3401              		.loc 3 108 0
 3402 0002 0F4C     		ldr	r4, .L190
 110:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   currentChannel=8;
 3403              		.loc 3 110 0
 3404 0004 0F4B     		ldr	r3, .L190+4
 108:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   timer_dev *timer_num = PIN_MAP[pin].timer_device;
 3405              		.loc 3 108 0
 3406 0006 D4F8F453 		ldr	r5, [r4, #1012]
 3407              	.LVL242:
 110:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   currentChannel=8;
 3408              		.loc 3 110 0
 3409 000a 0822     		movs	r2, #8
 3410 000c 1A70     		strb	r2, [r3, #0]
 111:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   if(timer_num != NULL) {
 3411              		.loc 3 111 0
 3412 000e ADB1     		cbz	r5, .L188
 112:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     gpio_set_mode(PIN_MAP[pin].gpio_device, PIN_MAP[pin].gpio_bit, GPIO_AF_INPUT_PD);
 3413              		.loc 3 112 0
 3414 0010 D4F8F003 		ldr	r0, [r4, #1008]
 3415 0014 94F8FC13 		ldrb	r1, [r4, #1020]	@ zero_extendqisi2
 3416 0018 0A22     		movs	r2, #10
 3417 001a FFF7FEFF 		bl	gpio_set_mode
 3418              	.LVL243:
 113:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     FrqInit(1500, timer_num, PIN_MAP[pin].timer_channel);
 3419              		.loc 3 113 0
 3420 001e 2946     		mov	r1, r5
 3421 0020 94F8FD23 		ldrb	r2, [r4, #1021]	@ zero_extendqisi2
 3422 0024 40F2DC50 		movw	r0, #1500
 3423 0028 FFF7FEFF 		bl	_Z7FrqInitiP9timer_devi
 3424              	.LVL244:
 114:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 3425              		.loc 3 114 0
 3426 002c 94F8FD13 		ldrb	r1, [r4, #1021]	@ zero_extendqisi2
 3427 0030 054A     		ldr	r2, .L190+8
 3428 0032 2846     		mov	r0, r5
 3429              	.LBE207:
 117:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3430              		.loc 3 117 0
 3431 0034 BDE83840 		pop	{r3, r4, r5, lr}
 3432              	.LBB208:
 114:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****     timer_attach_interrupt(timer_num, PIN_MAP[pin].timer_channel, FrqChange);
 3433              		.loc 3 114 0
 3434 0038 FFF7FEBF 		b	timer_attach_interrupt
 3435              	.LVL245:
 3436              	.L188:
 3437 003c 38BD     		pop	{r3, r4, r5, pc}
 3438              	.L191:
 3439 003e 00BF     		.align	2
 3440              	.L190:
 3441 0040 00000000 		.word	PIN_MAP
 3442 0044 00000000 		.word	.LANCHOR1
 3443 0048 00000000 		.word	_Z9FrqChangev
 3444              	.LBE208:
 3445              		.cfi_endproc
 3446              	.LFE171:
 3448              		.section	.text._Z18initializeReceiveri,"ax",%progbits
 3449              		.align	1
 3450              		.global	_Z18initializeReceiveri
 3451              		.thumb
 3452              		.thumb_func
 3454              	_Z18initializeReceiveri:
 3455              	.LFB172:
 124:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void initializeReceiver(int nbChannel = 8) {
 3456              		.loc 3 124 0
 3457              		.cfi_startproc
 3458              		@ args = 0, pretend = 0, frame = 0
 3459              		@ frame_needed = 0, uses_anonymous_args = 0
 3460              	.LVL246:
 3461 0000 08B5     		push	{r3, lr}
 3462              	.LCFI31:
 3463              		.cfi_def_cfa_offset 8
 3464              		.cfi_offset 3, -8
 3465              		.cfi_offset 14, -4
 125:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   initializeReceiverParam(nbChannel);
 3466              		.loc 3 125 0
 3467 0002 FFF7FEFF 		bl	_Z23initializeReceiverParami
 3468              	.LVL247:
 127:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3469              		.loc 3 127 0
 3470 0006 BDE80840 		pop	{r3, lr}
 126:../Libraries/AQ_Receiver/Receiver_STM32PPM.h ****   InitFrqMeasurement();
 3471              		.loc 3 126 0
 3472 000a FFF7FEBF 		b	_Z18InitFrqMeasurementv
 3473              	.LVL248:
 3474              		.cfi_endproc
 3475              	.LFE172:
 3477              		.section	.text._Z18getRawChannelValueh,"ax",%progbits
 3478              		.align	1
 3479              		.global	_Z18getRawChannelValueh
 3480              		.thumb
 3481              		.thumb_func
 3483              	_Z18getRawChannelValueh:
 3484              	.LFB173:
 130:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** int getRawChannelValue(const byte channel) {
 3485              		.loc 3 130 0
 3486              		.cfi_startproc
 3487              		@ args = 0, pretend = 0, frame = 0
 3488              		@ frame_needed = 0, uses_anonymous_args = 0
 3489              		@ link register save eliminated.
 3490              	.LVL249:
 3491              		.loc 3 131 0
 3492 0000 024B     		ldr	r3, .L194
 3493 0002 1A5C     		ldrb	r2, [r3, r0]	@ zero_extendqisi2
 132:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** }
 3494              		.loc 3 132 0
 3495 0004 024B     		ldr	r3, .L194+4
 3496 0006 33F81200 		ldrh	r0, [r3, r2, lsl #1]
 3497              	.LVL250:
 3498 000a 7047     		bx	lr
 3499              	.L195:
 3500              		.align	2
 3501              	.L194:
 3502 000c 00000000 		.word	.LANCHOR10
 3503 0010 00000000 		.word	.LANCHOR2
 3504              		.cfi_endproc
 3505              	.LFE173:
 3507              		.section	.text._Z15setChannelValuehi,"ax",%progbits
 3508              		.align	1
 3509              		.global	_Z15setChannelValuehi
 3510              		.thumb
 3511              		.thumb_func
 3513              	_Z15setChannelValuehi:
 3514              	.LFB174:
 133:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 134:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** 
 135:../Libraries/AQ_Receiver/Receiver_STM32PPM.h **** void setChannelValue(byte channel,int value) {
 3515              		.loc 3 135 0
 3516              		.cfi_startproc
 3517              		@ args = 0, pretend = 0, frame = 0
 3518              		@ frame_needed = 0, uses_anonymous_args = 0
 3519              		@ link register save eliminated.
 3520              	.LVL251:
 3521 0000 7047     		bx	lr
 3522              		.cfi_endproc
 3523              	.LFE174:
 3525              		.section	.text._Z11writeMotorsv,"ax",%progbits
 3526              		.align	1
 3527              		.global	_Z11writeMotorsv
 3528              		.thumb
 3529              		.thumb_func
 3531              	_Z11writeMotorsv:
 3532              	.LFB177:
 3533              		.file 15 "../Libraries/AQ_Motors/Motors_STM32.h"
   1:../Libraries/AQ_Motors/Motors_STM32.h **** #ifndef _AEROQUAD_MOTORS_STM32_H_
   2:../Libraries/AQ_Motors/Motors_STM32.h **** #define _AEROQUAD_MOTORS_STM32_H_
   3:../Libraries/AQ_Motors/Motors_STM32.h **** 
   4:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined(AeroQuadSTM32)
   5:../Libraries/AQ_Motors/Motors_STM32.h **** 
   6:../Libraries/AQ_Motors/Motors_STM32.h **** #include "Motors.h"
   7:../Libraries/AQ_Motors/Motors_STM32.h **** 
   8:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
   9:../Libraries/AQ_Motors/Motors_STM32.h **** // definition section
  10:../Libraries/AQ_Motors/Motors_STM32.h **** 
  11:../Libraries/AQ_Motors/Motors_STM32.h **** #if defined (USE_400HZ_ESC)
  12:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_FREQUENCY 400   // in Hz
  13:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  14:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_FREQUENCY 300   // in Hz
  15:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  16:../Libraries/AQ_Motors/Motors_STM32.h **** #define PWM_PERIODE     (1000000/PWM_FREQUENCY)
  17:../Libraries/AQ_Motors/Motors_STM32.h **** 
  18:../Libraries/AQ_Motors/Motors_STM32.h **** #ifdef MOTORS_STM32_TRI
  19:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_SERVO_FREQUENCY 50 // Hz 
  20:../Libraries/AQ_Motors/Motors_STM32.h ****   #define PWM_SERVO_PERIODE   (1000000/PWM_SERVO_FREQUENCY)
  21:../Libraries/AQ_Motors/Motors_STM32.h ****   #define STM32_MOTOR_MAP stm32_motor_mapping_tri
  22:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  23:../Libraries/AQ_Motors/Motors_STM32.h ****   #define STM32_MOTOR_MAP stm32_motor_mapping
  24:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  25:../Libraries/AQ_Motors/Motors_STM32.h **** 
  26:../Libraries/AQ_Motors/Motors_STM32.h **** ////////////////////////////////////////////////////////
  27:../Libraries/AQ_Motors/Motors_STM32.h **** // code section
  28:../Libraries/AQ_Motors/Motors_STM32.h **** 
  29:../Libraries/AQ_Motors/Motors_STM32.h **** static int _stm32_motor_number;
  30:../Libraries/AQ_Motors/Motors_STM32.h **** 
  31:../Libraries/AQ_Motors/Motors_STM32.h **** // global section
  32:../Libraries/AQ_Motors/Motors_STM32.h **** 
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
  34:../Libraries/AQ_Motors/Motors_STM32.h ****  
  35:../Libraries/AQ_Motors/Motors_STM32.h ****   int motor;
  36:../Libraries/AQ_Motors/Motors_STM32.h **** 
  37:../Libraries/AQ_Motors/Motors_STM32.h ****   _stm32_motor_number = sizeof(STM32_MOTOR_MAP)/sizeof(STM32_MOTOR_MAP[0]);
  38:../Libraries/AQ_Motors/Motors_STM32.h ****   if(numbers < _stm32_motor_number) {
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     _stm32_motor_number = numbers;
  40:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  41:../Libraries/AQ_Motors/Motors_STM32.h ****   
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
  43:../Libraries/AQ_Motors/Motors_STM32.h **** 
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
  45:../Libraries/AQ_Motors/Motors_STM32.h **** 
  46:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_prescaler(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, prescaler);
  47:../Libraries/AQ_Motors/Motors_STM32.h **** 
  48:../Libraries/AQ_Motors/Motors_STM32.h **** #ifdef MOTORS_STM32_TRI
  49:../Libraries/AQ_Motors/Motors_STM32.h ****     // on Tri mode motor 0 is a servo and thus has slower update rate
  50:../Libraries/AQ_Motors/Motors_STM32.h ****     if (motor == 0) {
  51:../Libraries/AQ_Motors/Motors_STM32.h ****       timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_SERVO_PERIODE);
  52:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  53:../Libraries/AQ_Motors/Motors_STM32.h ****     else {
  54:../Libraries/AQ_Motors/Motors_STM32.h ****       timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
  55:../Libraries/AQ_Motors/Motors_STM32.h ****     }
  56:../Libraries/AQ_Motors/Motors_STM32.h **** #else
  57:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_reload(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PWM_PERIODE);
  58:../Libraries/AQ_Motors/Motors_STM32.h **** #endif
  59:../Libraries/AQ_Motors/Motors_STM32.h ****     
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
  61:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  62:../Libraries/AQ_Motors/Motors_STM32.h ****   
  63:../Libraries/AQ_Motors/Motors_STM32.h ****   // sync timer
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
  66:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  67:../Libraries/AQ_Motors/Motors_STM32.h ****   
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
  69:../Libraries/AQ_Motors/Motors_STM32.h ****   //Serial.println("motor init done\r\n");
  70:../Libraries/AQ_Motors/Motors_STM32.h **** }
  71:../Libraries/AQ_Motors/Motors_STM32.h **** 
  72:../Libraries/AQ_Motors/Motors_STM32.h **** void writeMotors(void) { // update motor commands on timers
 3534              		.loc 15 72 0
 3535              		.cfi_startproc
 3536              		@ args = 0, pretend = 0, frame = 0
 3537              		@ frame_needed = 0, uses_anonymous_args = 0
 3538              	.LVL252:
 3539              	.LBB213:
  73:../Libraries/AQ_Motors/Motors_STM32.h **** 
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3540              		.loc 15 74 0
 3541 0000 0B4B     		ldr	r3, .L200
 3542              	.LBE213:
  72:../Libraries/AQ_Motors/Motors_STM32.h **** void writeMotors(void) { // update motor commands on timers
 3543              		.loc 15 72 0
 3544 0002 F0B5     		push	{r4, r5, r6, r7, lr}
 3545              	.LCFI32:
 3546              		.cfi_def_cfa_offset 20
 3547              		.cfi_offset 4, -20
 3548              		.cfi_offset 5, -16
 3549              		.cfi_offset 6, -12
 3550              		.cfi_offset 7, -8
 3551              		.cfi_offset 14, -4
 3552              	.LBB218:
 3553              		.loc 15 74 0
 3554 0004 1868     		ldr	r0, [r3, #0]
  75:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_compare(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PIN_MAP[STM32_MOTOR_MAP[motor]]
 3555              		.loc 15 75 0
 3556 0006 0B4C     		ldr	r4, .L200+4
 3557 0008 0B4D     		ldr	r5, .L200+8
 3558 000a 0C4E     		ldr	r6, .L200+12
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3559              		.loc 15 74 0
 3560 000c 0023     		movs	r3, #0
 3561 000e 0CE0     		b	.L198
 3562              	.LVL253:
 3563              	.L199:
 3564              		.loc 15 75 0 discriminator 2
 3565 0010 1A5D     		ldrb	r2, [r3, r4]	@ zero_extendqisi2
 3566              	.LVL254:
 3567              	.LBB214:
 3568              	.LBB215:
  72:../Libraries/AQ_Motors/Motors_STM32.h **** void writeMotors(void) { // update motor commands on timers
 3569              		.loc 15 72 0 discriminator 2
 3570 0012 36F82370 		ldrh	r7, [r6, r3, lsl #2]
 3571              	.LBE215:
 3572              	.LBE214:
 3573              		.loc 15 75 0 discriminator 2
 3574 0016 05EB0212 		add	r2, r5, r2, lsl #4
 3575              	.LVL255:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3576              		.loc 15 74 0 discriminator 2
 3577 001a 0133     		adds	r3, r3, #1
 3578              	.LVL256:
 3579              	.LBB217:
 3580              	.LBB216:
 3581              		.file 16 "../Libmaple/libmaple/libmaple/timer.h"
   1:../Libmaple/libmaple/libmaple/timer.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/timer.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/timer.h ****  *
   4:../Libmaple/libmaple/libmaple/timer.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/timer.h ****  *
   6:../Libmaple/libmaple/libmaple/timer.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/timer.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/timer.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/timer.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/timer.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/timer.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/timer.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/timer.h ****  *
  14:../Libmaple/libmaple/libmaple/timer.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/timer.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/timer.h ****  *
  17:../Libmaple/libmaple/libmaple/timer.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/timer.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/timer.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/timer.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/timer.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/timer.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/timer.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/timer.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/timer.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/timer.h **** 
  27:../Libmaple/libmaple/libmaple/timer.h **** /**
  28:../Libmaple/libmaple/libmaple/timer.h ****  * @file   timer.h
  29:../Libmaple/libmaple/libmaple/timer.h ****  * @author Marti Bolivar <mbolivar@leaflabs.com>
  30:../Libmaple/libmaple/libmaple/timer.h ****  * @brief  New-style timer interface.
  31:../Libmaple/libmaple/libmaple/timer.h ****  *
  32:../Libmaple/libmaple/libmaple/timer.h ****  * Replaces old timers.h implementation.
  33:../Libmaple/libmaple/libmaple/timer.h ****  */
  34:../Libmaple/libmaple/libmaple/timer.h **** 
  35:../Libmaple/libmaple/libmaple/timer.h **** #ifndef _TIMERS_H_
  36:../Libmaple/libmaple/libmaple/timer.h **** #define _TIMERS_H_
  37:../Libmaple/libmaple/libmaple/timer.h **** 
  38:../Libmaple/libmaple/libmaple/timer.h **** #include "libmaple.h"
  39:../Libmaple/libmaple/libmaple/timer.h **** #include "rcc.h"
  40:../Libmaple/libmaple/libmaple/timer.h **** #include "nvic.h"
  41:../Libmaple/libmaple/libmaple/timer.h **** #include "bitband.h"
  42:../Libmaple/libmaple/libmaple/timer.h **** 
  43:../Libmaple/libmaple/libmaple/timer.h **** #ifdef __cplusplus
  44:../Libmaple/libmaple/libmaple/timer.h **** extern "C"{
  45:../Libmaple/libmaple/libmaple/timer.h **** #endif
  46:../Libmaple/libmaple/libmaple/timer.h **** 
  47:../Libmaple/libmaple/libmaple/timer.h **** /*
  48:../Libmaple/libmaple/libmaple/timer.h ****  * Register maps and devices
  49:../Libmaple/libmaple/libmaple/timer.h ****  */
  50:../Libmaple/libmaple/libmaple/timer.h **** 
  51:../Libmaple/libmaple/libmaple/timer.h **** /** Advanced control timer register map type */
  52:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_adv_reg_map {
  53:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  54:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  55:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  56:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  57:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  58:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  59:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  60:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  61:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  62:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  63:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  64:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  65:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 RCR;            /**< Repetition counter register */
  66:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  67:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  68:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  69:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  70:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 BDTR;           /**< Break and dead-time register */
  71:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  72:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  73:../Libmaple/libmaple/libmaple/timer.h **** } timer_adv_reg_map;
  74:../Libmaple/libmaple/libmaple/timer.h **** 
  75:../Libmaple/libmaple/libmaple/timer.h **** /** General purpose timer register map type */
  76:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_gen_reg_map {
  77:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
  78:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
  79:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SMCR;           /**< Slave mode control register */
  80:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
  81:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
  82:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
  83:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR1;          /**< Capture/compare mode register 1 */
  84:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCMR2;          /**< Capture/compare mode register 2 */
  85:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCER;           /**< Capture/compare enable register */
  86:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
  87:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
  88:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
  89:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
  90:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR1;           /**< Capture/compare register 1 */
  91:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR2;           /**< Capture/compare register 2 */
  92:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR3;           /**< Capture/compare register 3 */
  93:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CCR4;           /**< Capture/compare register 4 */
  94:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
  95:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DCR;            /**< DMA control register */
  96:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DMAR;           /**< DMA address for full transfer */
  97:../Libmaple/libmaple/libmaple/timer.h **** } timer_gen_reg_map;
  98:../Libmaple/libmaple/libmaple/timer.h **** 
  99:../Libmaple/libmaple/libmaple/timer.h **** /** Basic timer register map type */
 100:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_bas_reg_map {
 101:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR1;            /**< Control register 1 */
 102:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CR2;            /**< Control register 2 */
 103:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED1;     /**< Reserved */
 104:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 DIER;           /**< DMA/Interrupt enable register */
 105:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 SR;             /**< Status register */
 106:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 EGR;            /**< Event generation register  */
 107:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED2;     /**< Reserved */
 108:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED3;     /**< Reserved */
 109:../Libmaple/libmaple/libmaple/timer.h ****     const uint32 RESERVED4;     /**< Reserved */
 110:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 CNT;            /**< Counter */
 111:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 PSC;            /**< Prescaler */
 112:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 ARR;            /**< Auto-reload register */
 113:../Libmaple/libmaple/libmaple/timer.h **** } timer_bas_reg_map;
 114:../Libmaple/libmaple/libmaple/timer.h **** 
 115:../Libmaple/libmaple/libmaple/timer.h **** 
 116:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 117:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 118:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40010000)
 119:../Libmaple/libmaple/libmaple/timer.h **** #else
 120:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 1 register map base pointer */
 121:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER1_BASE        ((struct timer_adv_reg_map*)0x40012C00)
 122:../Libmaple/libmaple/libmaple/timer.h **** #endif
 123:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 2 register map base pointer */
 124:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER2_BASE        ((struct timer_gen_reg_map*)0x40000000)
 125:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 3 register map base pointer */
 126:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER3_BASE        ((struct timer_gen_reg_map*)0x40000400)
 127:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 4 register map base pointer */
 128:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER4_BASE        ((struct timer_gen_reg_map*)0x40000800)
 129:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 130:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 5 register map base pointer */
 131:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER5_BASE        ((struct timer_gen_reg_map*)0x40000C00)
 132:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 6 register map base pointer */
 133:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER6_BASE        ((struct timer_bas_reg_map*)0x40001000)
 134:../Libmaple/libmaple/libmaple/timer.h **** /** Timer 7 register map base pointer */
 135:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER7_BASE        ((struct timer_bas_reg_map*)0x40001400)
 136:../Libmaple/libmaple/libmaple/timer.h **** 
 137:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32F2
 138:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 139:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40010400)
 140:../Libmaple/libmaple/libmaple/timer.h **** #else
 141:../Libmaple/libmaple/libmaple/timer.h ****   /** Timer 8 register map base pointer */
 142:../Libmaple/libmaple/libmaple/timer.h ****   #define TIMER8_BASE        ((struct timer_adv_reg_map*)0x40013400)
 143:../Libmaple/libmaple/libmaple/timer.h **** #endif
 144:../Libmaple/libmaple/libmaple/timer.h **** #endif
 145:../Libmaple/libmaple/libmaple/timer.h **** 
 146:../Libmaple/libmaple/libmaple/timer.h **** /*
 147:../Libmaple/libmaple/libmaple/timer.h ****  * Timer devices
 148:../Libmaple/libmaple/libmaple/timer.h ****  */
 149:../Libmaple/libmaple/libmaple/timer.h **** 
 150:../Libmaple/libmaple/libmaple/timer.h **** /**
 151:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer register map type.
 152:../Libmaple/libmaple/libmaple/timer.h ****  *
 153:../Libmaple/libmaple/libmaple/timer.h ****  * Just holds a pointer to the correct type of register map, based on
 154:../Libmaple/libmaple/libmaple/timer.h ****  * the timer's type.
 155:../Libmaple/libmaple/libmaple/timer.h ****  */
 156:../Libmaple/libmaple/libmaple/timer.h **** typedef union timer_reg_map {
 157:../Libmaple/libmaple/libmaple/timer.h ****     timer_adv_reg_map *adv;     /**< Advanced register map */
 158:../Libmaple/libmaple/libmaple/timer.h ****     timer_gen_reg_map *gen;     /**< General purpose register map */
 159:../Libmaple/libmaple/libmaple/timer.h ****     timer_bas_reg_map *bas;     /**< Basic register map */
 160:../Libmaple/libmaple/libmaple/timer.h **** } timer_reg_map;
 161:../Libmaple/libmaple/libmaple/timer.h **** 
 162:../Libmaple/libmaple/libmaple/timer.h **** /**
 163:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer type
 164:../Libmaple/libmaple/libmaple/timer.h ****  *
 165:../Libmaple/libmaple/libmaple/timer.h ****  * Type marker for timer_dev.
 166:../Libmaple/libmaple/libmaple/timer.h ****  *
 167:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_dev
 168:../Libmaple/libmaple/libmaple/timer.h ****  */
 169:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_type {
 170:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_ADVANCED,             /**< Advanced type */
 171:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_GENERAL,              /**< General purpose type */
 172:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BASIC                 /**< Basic type */
 173:../Libmaple/libmaple/libmaple/timer.h **** } timer_type;
 174:../Libmaple/libmaple/libmaple/timer.h **** 
 175:../Libmaple/libmaple/libmaple/timer.h **** /** Timer device type */
 176:../Libmaple/libmaple/libmaple/timer.h **** typedef struct timer_dev {
 177:../Libmaple/libmaple/libmaple/timer.h ****     timer_reg_map regs;         /**< Register map */
 178:../Libmaple/libmaple/libmaple/timer.h ****     rcc_clk_id clk_id;          /**< RCC clock information */
 179:../Libmaple/libmaple/libmaple/timer.h ****     timer_type type;            /**< Timer's type */
 180:../Libmaple/libmaple/libmaple/timer.h ****     voidFuncPtr handlers[];     /**< User IRQ handlers */
 181:../Libmaple/libmaple/libmaple/timer.h **** } timer_dev;
 182:../Libmaple/libmaple/libmaple/timer.h **** 
 183:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER1;
 184:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER2;
 185:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER3;
 186:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER4;
 187:../Libmaple/libmaple/libmaple/timer.h **** #ifdef STM32_HIGH_DENSITY
 188:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER5;
 189:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER6;
 190:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER7;
 191:../Libmaple/libmaple/libmaple/timer.h **** extern timer_dev *TIMER8;
 192:../Libmaple/libmaple/libmaple/timer.h **** #endif
 193:../Libmaple/libmaple/libmaple/timer.h **** 
 194:../Libmaple/libmaple/libmaple/timer.h **** /*
 195:../Libmaple/libmaple/libmaple/timer.h ****  * Register bit definitions
 196:../Libmaple/libmaple/libmaple/timer.h ****  */
 197:../Libmaple/libmaple/libmaple/timer.h **** 
 198:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 1 (CR1) */
 199:../Libmaple/libmaple/libmaple/timer.h **** 
 200:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE_BIT              7
 201:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR_BIT               4
 202:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM_BIT               3
 203:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS_BIT               2
 204:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS_BIT              1
 205:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN_BIT               0
 206:../Libmaple/libmaple/libmaple/timer.h **** 
 207:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD                   (0x3 << 8)
 208:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_1TCKINT           (0x0 << 8)
 209:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_2TCKINT           (0x1 << 8)
 210:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_4TICKINT          (0x2 << 8)
 211:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_ARPE                  BIT(TIMER_CR1_ARPE_BIT)
 212:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS               (0x3 << 5)
 213:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_EDGE          (0x0 << 5)
 214:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER1       (0x1 << 5)
 215:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER2       (0x2 << 5)
 216:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CKD_CMS_CENTER3       (0x3 << 5)
 217:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_DIR                   BIT(TIMER_CR1_DIR_BIT)
 218:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_OPM                   BIT(TIMER_CR1_OPM_BIT)
 219:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_URS                   BIT(TIMER_CR1_URS_BIT)
 220:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_UDIS                  BIT(TIMER_CR1_UDIS_BIT)
 221:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR1_CEN                   BIT(TIMER_CR1_CEN_BIT)
 222:../Libmaple/libmaple/libmaple/timer.h **** 
 223:../Libmaple/libmaple/libmaple/timer.h **** /* Control register 2 (CR2) */
 224:../Libmaple/libmaple/libmaple/timer.h **** 
 225:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4_BIT              14
 226:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N_BIT             13
 227:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3_BIT              12
 228:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N_BIT             11
 229:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2_BIT              10
 230:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N_BIT             9
 231:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1_BIT              8
 232:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S_BIT              7 /* tills? yikes */
 233:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS_BIT              3
 234:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS_BIT              2
 235:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC_BIT              0
 236:../Libmaple/libmaple/libmaple/timer.h **** 
 237:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS4                  BIT(TIMER_CR2_OIS4_BIT)
 238:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3N                 BIT(TIMER_CR2_OIS3N_BIT)
 239:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS3                  BIT(TIMER_CR2_OIS3_BIT)
 240:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2N                 BIT(TIMER_CR2_OIS2N_BIT)
 241:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS2                  BIT(TIMER_CR2_OIS2_BIT)
 242:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1N                 BIT(TIMER_CR2_OIS1N_BIT)
 243:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_OIS1                  BIT(TIMER_CR2_OIS1_BIT)
 244:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_TI1S                  BIT(TIMER_CR2_TI1S_BIT)
 245:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS                   (0x7 << 4)
 246:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_RESET             (0x0 << 4)
 247:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_ENABLE            (0x1 << 4)
 248:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_UPDATE            (0x2 << 4)
 249:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_PULSE     (0x3 << 4)
 250:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC1REF    (0x4 << 4)
 251:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC2REF    (0x5 << 4)
 252:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC3REF    (0x6 << 4)
 253:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_MMS_COMPARE_OC4REF    (0x7 << 4)
 254:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCDS                  BIT(TIMER_CR2_CCDS_BIT)
 255:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCUS                  BIT(TIMER_CR2_CCUS_BIT)
 256:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CR2_CCPC                  BIT(TIMER_CR2_CCPC_BIT)
 257:../Libmaple/libmaple/libmaple/timer.h **** 
 258:../Libmaple/libmaple/libmaple/timer.h **** /* Slave mode control register (SMCR) */
 259:../Libmaple/libmaple/libmaple/timer.h **** 
 260:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP_BIT              15
 261:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE_BIT              14
 262:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM_BIT              7
 263:../Libmaple/libmaple/libmaple/timer.h **** 
 264:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETP                  BIT(TIMER_SMCR_ETP_BIT)
 265:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ECE                  BIT(TIMER_SMCR_ECE_BIT)
 266:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS                 (0x3 << 12)
 267:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_OFF             (0x0 << 12)
 268:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV2            (0x1 << 12)
 269:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV4            (0x2 << 12)
 270:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETPS_DIV8            (0x3 << 12)
 271:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_ETF                  (0xF << 12)
 272:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_MSM                  BIT(TIMER_SMCR_MSM_BIT)
 273:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS                   (0x3 << 4)
 274:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR0              (0x0 << 4)
 275:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR1              (0x1 << 4)
 276:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR2              (0x2 << 4)
 277:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ITR3              (0x3 << 4)
 278:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1F_ED           (0x4 << 4)
 279:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI1FP1            (0x5 << 4)
 280:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_TI2FP2            (0x6 << 4)
 281:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_TS_ETRF              (0x7 << 4)
 282:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS                  0x3
 283:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_DISABLED         0x0
 284:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER1         0x1
 285:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER2         0x2
 286:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_ENCODER3         0x3
 287:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_RESET            0x4
 288:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_GATED            0x5
 289:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_TRIGGER          0x6
 290:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SMCR_SMS_EXTERNAL         0x7
 291:../Libmaple/libmaple/libmaple/timer.h **** 
 292:../Libmaple/libmaple/libmaple/timer.h **** /* DMA/Interrupt enable register (DIER) */
 293:../Libmaple/libmaple/libmaple/timer.h **** 
 294:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE_BIT              14
 295:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE_BIT            12
 296:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE_BIT            11
 297:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE_BIT            10
 298:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE_BIT            9
 299:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE_BIT              8
 300:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE_BIT              6
 301:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE_BIT            4
 302:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE_BIT            3
 303:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE_BIT            2
 304:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE_BIT            1
 305:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE_BIT              0
 306:../Libmaple/libmaple/libmaple/timer.h **** 
 307:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TDE                  BIT(TIMER_DIER_TDE_BIT)
 308:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4DE                BIT(TIMER_DIER_CC4DE_BIT)
 309:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3DE                BIT(TIMER_DIER_CC3DE_BIT)
 310:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2DE                BIT(TIMER_DIER_CC2DE_BIT)
 311:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1DE                BIT(TIMER_DIER_CC1DE_BIT)
 312:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UDE                  BIT(TIMER_DIER_UDE_BIT)
 313:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_TIE                  BIT(TIMER_DIER_TIE_BIT)
 314:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC4IE                BIT(TIMER_DIER_CC4IE_BIT)
 315:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC3IE                BIT(TIMER_DIER_CC3IE_BIT)
 316:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC2IE                BIT(TIMER_DIER_CC2IE_BIT)
 317:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_CC1IE                BIT(TIMER_DIER_CC1IE_BIT)
 318:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DIER_UIE                  BIT(TIMER_DIER_UIE_BIT)
 319:../Libmaple/libmaple/libmaple/timer.h **** 
 320:../Libmaple/libmaple/libmaple/timer.h **** /* Status register (SR) */
 321:../Libmaple/libmaple/libmaple/timer.h **** 
 322:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF_BIT              12
 323:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF_BIT              11
 324:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF_BIT              10
 325:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF_BIT              9
 326:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF_BIT                7
 327:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF_BIT                6
 328:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF_BIT              5
 329:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF_BIT              4
 330:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF_BIT              3
 331:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF_BIT              2
 332:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF_BIT              1
 333:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF_BIT                0
 334:../Libmaple/libmaple/libmaple/timer.h **** 
 335:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4OF                  BIT(TIMER_SR_CC4OF_BIT)
 336:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3OF                  BIT(TIMER_SR_CC3OF_BIT)
 337:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2OF                  BIT(TIMER_SR_CC2OF_BIT)
 338:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1OF                  BIT(TIMER_SR_CC1OF_BIT)
 339:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_BIF                    BIT(TIMER_SR_BIF_BIT)
 340:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_TIF                    BIT(TIMER_SR_TIF_BIT)
 341:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_COMIF                  BIT(TIMER_SR_COMIF_BIT)
 342:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC4IF                  BIT(TIMER_SR_CC4IF_BIT)
 343:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC3IF                  BIT(TIMER_SR_CC3IF_BIT)
 344:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC2IF                  BIT(TIMER_SR_CC2IF_BIT)
 345:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_CC1IF                  BIT(TIMER_SR_CC1IF_BIT)
 346:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_SR_UIF                    BIT(TIMER_SR_UIF_BIT)
 347:../Libmaple/libmaple/libmaple/timer.h **** 
 348:../Libmaple/libmaple/libmaple/timer.h **** /* Event generation register (EGR) */
 349:../Libmaple/libmaple/libmaple/timer.h **** 
 350:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG_BIT                6
 351:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G_BIT              4
 352:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G_BIT              3
 353:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G_BIT              2
 354:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G_BIT              1
 355:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG_BIT                0
 356:../Libmaple/libmaple/libmaple/timer.h **** 
 357:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_TG                    BIT(TIMER_EGR_TG_BIT)
 358:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC4G                  BIT(TIMER_EGR_CC4G_BIT)
 359:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC3G                  BIT(TIMER_EGR_CC3G_BIT)
 360:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC2G                  BIT(TIMER_EGR_CC2G_BIT)
 361:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_CC1G                  BIT(TIMER_EGR_CC1G_BIT)
 362:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_EGR_UG                    BIT(TIMER_EGR_UG_BIT)
 363:../Libmaple/libmaple/libmaple/timer.h **** 
 364:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode registers, common values */
 365:../Libmaple/libmaple/libmaple/timer.h **** 
 366:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_OUTPUT           0x0
 367:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI1        0x1
 368:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TI2        0x2
 369:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR_CCS_INPUT_TRC        0x3
 370:../Libmaple/libmaple/libmaple/timer.h **** 
 371:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 1 (CCMR1) */
 372:../Libmaple/libmaple/libmaple/timer.h **** 
 373:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE_BIT           15
 374:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE_BIT           11
 375:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE_BIT           10
 376:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE_BIT           7
 377:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE_BIT           3
 378:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE_BIT           2
 379:../Libmaple/libmaple/libmaple/timer.h **** 
 380:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2CE               BIT(TIMER_CCMR1_OC2CE_BIT)
 381:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2M                (0x3 << 12)
 382:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2F                (0xF << 12)
 383:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2PE               BIT(TIMER_CCMR1_OC2PE_BIT)
 384:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC2FE               BIT(TIMER_CCMR1_OC2FE_BIT)
 385:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC2PSC              (0x3 << 10)
 386:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S                (0x3 << 8)
 387:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 388:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 389:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 390:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC2S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 391:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1CE               BIT(TIMER_CCMR1_OC1CE_BIT)
 392:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1M                (0x3 << 4)
 393:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1F                (0xF << 4)
 394:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1PE               BIT(TIMER_CCMR1_OC1PE_BIT)
 395:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_OC1FE               BIT(TIMER_CCMR1_OC1FE_BIT)
 396:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_IC1PSC              (0x3 << 2)
 397:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S                0x3
 398:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 399:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 400:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 401:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC1S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 402:../Libmaple/libmaple/libmaple/timer.h **** 
 403:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare mode register 2 (CCMR2) */
 404:../Libmaple/libmaple/libmaple/timer.h **** 
 405:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE_BIT           15
 406:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE_BIT           11
 407:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE_BIT           10
 408:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE_BIT           7
 409:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE_BIT           3
 410:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE_BIT           2
 411:../Libmaple/libmaple/libmaple/timer.h **** 
 412:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4CE               BIT(TIMER_CCMR2_OC4CE_BIT)
 413:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4M                (0x3 << 12)
 414:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2F                (0xF << 12)
 415:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4PE               BIT(TIMER_CCMR2_OC4PE_BIT)
 416:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC4FE               BIT(TIMER_CCMR2_OC4FE_BIT)
 417:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC2PSC              (0x3 << 10)
 418:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC4S                (0x3 << 8)
 419:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_OUTPUT         (TIMER_CCMR_CCS_OUTPUT << 8)
 420:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI1      (TIMER_CCMR_CCS_INPUT_TI1 << 8)
 421:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TI2      (TIMER_CCMR_CCS_INPUT_TI2 << 8)
 422:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC4S_INPUT_TRC      (TIMER_CCMR_CCS_INPUT_TRC << 8)
 423:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3CE               BIT(TIMER_CCMR2_OC3CE_BIT)
 424:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3M                (0x3 << 4)
 425:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1F                (0xF << 4)
 426:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3PE               BIT(TIMER_CCMR2_OC3PE_BIT)
 427:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_OC3FE               BIT(TIMER_CCMR2_OC3FE_BIT)
 428:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_IC1PSC              (0x3 << 2)
 429:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR2_CC3S                0x3
 430:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_OUTPUT         TIMER_CCMR_CCS_OUTPUT
 431:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI1      TIMER_CCMR_CCS_INPUT_TI1
 432:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TI2      TIMER_CCMR_CCS_INPUT_TI2
 433:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCMR1_CC3S_INPUT_TRC      TIMER_CCMR_CCS_INPUT_TRC
 434:../Libmaple/libmaple/libmaple/timer.h **** 
 435:../Libmaple/libmaple/libmaple/timer.h **** /* Capture/compare enable register (CCER) */
 436:../Libmaple/libmaple/libmaple/timer.h **** 
 437:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P_BIT             13
 438:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E_BIT             12
 439:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P_BIT             9
 440:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E_BIT             8
 441:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P_BIT             5
 442:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E_BIT             4
 443:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P_BIT             1
 444:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E_BIT             0
 445:../Libmaple/libmaple/libmaple/timer.h **** 
 446:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4P                 BIT(TIMER_CCER_CC4P_BIT)
 447:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC4E                 BIT(TIMER_CCER_CC4E_BIT)
 448:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3P                 BIT(TIMER_CCER_CC3P_BIT)
 449:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC3E                 BIT(TIMER_CCER_CC3E_BIT)
 450:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2P                 BIT(TIMER_CCER_CC2P_BIT)
 451:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC2E                 BIT(TIMER_CCER_CC2E_BIT)
 452:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1P                 BIT(TIMER_CCER_CC1P_BIT)
 453:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_CCER_CC1E                 BIT(TIMER_CCER_CC1E_BIT)
 454:../Libmaple/libmaple/libmaple/timer.h **** 
 455:../Libmaple/libmaple/libmaple/timer.h **** /* Break and dead-time register (BDTR) */
 456:../Libmaple/libmaple/libmaple/timer.h **** 
 457:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE_BIT              15
 458:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE_BIT              14
 459:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP_BIT              13
 460:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE_BIT              12
 461:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR_BIT             11
 462:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI_BIT             10
 463:../Libmaple/libmaple/libmaple/timer.h **** 
 464:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_MOE                  BIT(TIMER_BDTR_MOE_BIT)
 465:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_AOE                  BIT(TIMER_BDTR_AOE_BIT)
 466:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKP                  BIT(TIMER_BDTR_BKP_BIT)
 467:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_BKE                  BIT(TIMER_BDTR_BKE_BIT)
 468:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSR                 BIT(TIMER_BDTR_OSSR_BIT)
 469:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_OSSI                 BIT(TIMER_BDTR_OSSI_BIT)
 470:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK                 (0x3 << 8)
 471:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_OFF             (0x0 << 8)
 472:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL1          (0x1 << 8)
 473:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL2          (0x2 << 8)
 474:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_LOCK_LEVEL3          (0x3 << 8)
 475:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_BDTR_DTG                  0xFF
 476:../Libmaple/libmaple/libmaple/timer.h **** 
 477:../Libmaple/libmaple/libmaple/timer.h **** /* DMA control register (DCR) */
 478:../Libmaple/libmaple/libmaple/timer.h **** 
 479:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL                   (0x1F << 8)
 480:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_1BYTE             (0x0 << 8)
 481:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_2BYTE             (0x1 << 8)
 482:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_3BYTE             (0x2 << 8)
 483:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_4BYTE             (0x3 << 8)
 484:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_5BYTE             (0x4 << 8)
 485:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_6BYTE             (0x5 << 8)
 486:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_7BYTE             (0x6 << 8)
 487:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_8BYTE             (0x7 << 8)
 488:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_9BYTE             (0x8 << 8)
 489:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_10BYTE            (0x9 << 8)
 490:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_11BYTE            (0xA << 8)
 491:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_12BYTE            (0xB << 8)
 492:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_13BYTE            (0xC << 8)
 493:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_14BYTE            (0xD << 8)
 494:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_15BYTE            (0xE << 8)
 495:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_16BYTE            (0xF << 8)
 496:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_17BYTE            (0x10 << 8)
 497:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBL_18BYTE            (0x11 << 8)
 498:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA                   0x1F
 499:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR1               0x0
 500:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CR2               0x1
 501:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SMCR              0x2
 502:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DIER              0x3
 503:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_SR                0x4
 504:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_EGR               0x5
 505:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR1             0x6
 506:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCMR2             0x7
 507:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCER              0x8
 508:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CNT               0x9
 509:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_PSC               0xA
 510:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_ARR               0xB
 511:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_RCR               0xC
 512:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR1              0xD
 513:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR2              0xE
 514:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR3              0xF
 515:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_CCR4              0x10
 516:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_BDTR              0x11
 517:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DCR               0x12
 518:../Libmaple/libmaple/libmaple/timer.h **** #define TIMER_DCR_DBA_DMAR              0x13
 519:../Libmaple/libmaple/libmaple/timer.h **** 
 520:../Libmaple/libmaple/libmaple/timer.h **** /*
 521:../Libmaple/libmaple/libmaple/timer.h ****  * Convenience routines
 522:../Libmaple/libmaple/libmaple/timer.h ****  */
 523:../Libmaple/libmaple/libmaple/timer.h **** 
 524:../Libmaple/libmaple/libmaple/timer.h **** /**
 525:../Libmaple/libmaple/libmaple/timer.h ****  * Used to configure the behavior of a timer channel.  Note that not
 526:../Libmaple/libmaple/libmaple/timer.h ****  * all timers can be configured in every mode.
 527:../Libmaple/libmaple/libmaple/timer.h ****  */
 528:../Libmaple/libmaple/libmaple/timer.h **** /* TODO TIMER_PWM_CENTER_ALIGNED, TIMER_INPUT_CAPTURE, TIMER_ONE_PULSE */
 529:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_mode {
 530:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_DISABLED, /**< In this mode, the timer stops counting,
 531:../Libmaple/libmaple/libmaple/timer.h ****                          channel interrupts are detached, and no state
 532:../Libmaple/libmaple/libmaple/timer.h ****                          changes are output. */
 533:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_PWM, /**< PWM output mode. This is the default mode for pins
 534:../Libmaple/libmaple/libmaple/timer.h ****                     after initialization. */
 535:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_PWM_CENTER_ALIGNED, /\**< Center-aligned PWM output mode. *\/ */
 536:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_OUTPUT_COMPARE, /**< In this mode, the timer counts from 0
 537:../Libmaple/libmaple/libmaple/timer.h ****                                to its reload value repeatedly; every
 538:../Libmaple/libmaple/libmaple/timer.h ****                                time the counter value reaches one of
 539:../Libmaple/libmaple/libmaple/timer.h ****                                the channel compare values, the
 540:../Libmaple/libmaple/libmaple/timer.h ****                                corresponding interrupt is fired. */
 541:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_INPUT_CAPTURE, /\**< In this mode, the timer can measure the */
 542:../Libmaple/libmaple/libmaple/timer.h ****     /*                           pulse lengths of input signals. *\/ */
 543:../Libmaple/libmaple/libmaple/timer.h ****     /* TIMER_ONE_PULSE /\**< In this mode, the timer can generate a single */
 544:../Libmaple/libmaple/libmaple/timer.h ****     /*                      pulse on a GPIO pin for a specified amount of */
 545:../Libmaple/libmaple/libmaple/timer.h ****     /*                      time. *\/ */
 546:../Libmaple/libmaple/libmaple/timer.h **** } timer_mode;
 547:../Libmaple/libmaple/libmaple/timer.h **** 
 548:../Libmaple/libmaple/libmaple/timer.h **** /** Timer channel numbers */
 549:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_channel {
 550:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH1 = 1, /**< Channel 1 */
 551:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH2 = 2, /**< Channel 2 */
 552:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH3 = 3, /**< Channel 3 */
 553:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CH4 = 4  /**< Channel 4 */
 554:../Libmaple/libmaple/libmaple/timer.h **** } timer_channel;
 555:../Libmaple/libmaple/libmaple/timer.h **** 
 556:../Libmaple/libmaple/libmaple/timer.h **** /*
 557:../Libmaple/libmaple/libmaple/timer.h ****  * Note: Don't require timer_channel arguments! We want to be able to say
 558:../Libmaple/libmaple/libmaple/timer.h ****  *
 559:../Libmaple/libmaple/libmaple/timer.h ****  * for (int channel = 1; channel <= 4; channel++) {
 560:../Libmaple/libmaple/libmaple/timer.h ****  *    ...
 561:../Libmaple/libmaple/libmaple/timer.h ****  * }
 562:../Libmaple/libmaple/libmaple/timer.h ****  *
 563:../Libmaple/libmaple/libmaple/timer.h ****  * without the compiler yelling at us.
 564:../Libmaple/libmaple/libmaple/timer.h ****  */
 565:../Libmaple/libmaple/libmaple/timer.h **** 
 566:../Libmaple/libmaple/libmaple/timer.h **** void timer_init(timer_dev *dev);
 567:../Libmaple/libmaple/libmaple/timer.h **** void timer_disable(timer_dev *dev);
 568:../Libmaple/libmaple/libmaple/timer.h **** void timer_set_mode(timer_dev *dev, uint8 channel, timer_mode mode);
 569:../Libmaple/libmaple/libmaple/timer.h **** void timer_foreach(void (*fn)(timer_dev*));
 570:../Libmaple/libmaple/libmaple/timer.h **** 
 571:../Libmaple/libmaple/libmaple/timer.h **** /**
 572:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Timer interrupt number.
 573:../Libmaple/libmaple/libmaple/timer.h ****  *
 574:../Libmaple/libmaple/libmaple/timer.h ****  * Not all timers support all of these values; see the descriptions
 575:../Libmaple/libmaple/libmaple/timer.h ****  * for each value.
 576:../Libmaple/libmaple/libmaple/timer.h ****  */
 577:../Libmaple/libmaple/libmaple/timer.h **** typedef enum timer_interrupt_id {
 578:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_UPDATE_INTERRUPT, /**< Update interrupt, available on all timers. */
 579:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC1_INTERRUPT, /**< Capture/compare 1 interrupt, available
 580:../Libmaple/libmaple/libmaple/timer.h ****                               on general and advanced timers only. */
 581:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC2_INTERRUPT, /**< Capture/compare 2 interrupt, general and
 582:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 583:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC3_INTERRUPT, /**< Capture/compare 3 interrupt, general and
 584:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 585:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_CC4_INTERRUPT, /**< Capture/compare 4 interrupt, general and
 586:../Libmaple/libmaple/libmaple/timer.h ****                               advanced timers only. */
 587:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_COM_INTERRUPT, /**< COM interrupt, advanced timers only */
 588:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_TRG_INTERRUPT, /**< Trigger interrupt, general and advanced
 589:../Libmaple/libmaple/libmaple/timer.h ****                               timers only */
 590:../Libmaple/libmaple/libmaple/timer.h ****     TIMER_BREAK_INTERRUPT /**< Break interrupt, advanced timers only. */
 591:../Libmaple/libmaple/libmaple/timer.h **** } timer_interrupt_id;
 592:../Libmaple/libmaple/libmaple/timer.h **** 
 593:../Libmaple/libmaple/libmaple/timer.h **** void timer_attach_interrupt(timer_dev *dev,
 594:../Libmaple/libmaple/libmaple/timer.h ****                             uint8 interrupt,
 595:../Libmaple/libmaple/libmaple/timer.h ****                             voidFuncPtr handler);
 596:../Libmaple/libmaple/libmaple/timer.h **** void timer_detach_interrupt(timer_dev *dev, uint8 interrupt);
 597:../Libmaple/libmaple/libmaple/timer.h **** 
 598:../Libmaple/libmaple/libmaple/timer.h **** /**
 599:../Libmaple/libmaple/libmaple/timer.h ****  * Initialize all timer devices on the chip.
 600:../Libmaple/libmaple/libmaple/timer.h ****  */
 601:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_init_all(void) {
 602:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_init);
 603:../Libmaple/libmaple/libmaple/timer.h **** }
 604:../Libmaple/libmaple/libmaple/timer.h **** 
 605:../Libmaple/libmaple/libmaple/timer.h **** /**
 606:../Libmaple/libmaple/libmaple/timer.h ****  * Disables all timers on the device.
 607:../Libmaple/libmaple/libmaple/timer.h ****  */
 608:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_disable_all(void) {
 609:../Libmaple/libmaple/libmaple/timer.h ****     timer_foreach(timer_disable);
 610:../Libmaple/libmaple/libmaple/timer.h **** }
 611:../Libmaple/libmaple/libmaple/timer.h **** 
 612:../Libmaple/libmaple/libmaple/timer.h **** /**
 613:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Stop a timer's counter from changing.
 614:../Libmaple/libmaple/libmaple/timer.h ****  *
 615:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 616:../Libmaple/libmaple/libmaple/timer.h ****  *
 617:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to pause.
 618:../Libmaple/libmaple/libmaple/timer.h ****  */
 619:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_pause(timer_dev *dev) {
 620:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 0;
 621:../Libmaple/libmaple/libmaple/timer.h **** }
 622:../Libmaple/libmaple/libmaple/timer.h **** 
 623:../Libmaple/libmaple/libmaple/timer.h **** /**
 624:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Start a timer's counter.
 625:../Libmaple/libmaple/libmaple/timer.h ****  *
 626:../Libmaple/libmaple/libmaple/timer.h ****  * Does not affect the timer's mode or other settings.
 627:../Libmaple/libmaple/libmaple/timer.h ****  *
 628:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Device whose counter to resume
 629:../Libmaple/libmaple/libmaple/timer.h ****  */
 630:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_resume(timer_dev *dev) {
 631:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->CR1, TIMER_CR1_CEN_BIT) = 1;
 632:../Libmaple/libmaple/libmaple/timer.h **** }
 633:../Libmaple/libmaple/libmaple/timer.h **** 
 634:../Libmaple/libmaple/libmaple/timer.h **** /**
 635:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the timer's counter value.
 636:../Libmaple/libmaple/libmaple/timer.h ****  *
 637:../Libmaple/libmaple/libmaple/timer.h ****  * This value is likely to be inaccurate if the counter is running
 638:../Libmaple/libmaple/libmaple/timer.h ****  * with a low prescaler.
 639:../Libmaple/libmaple/libmaple/timer.h ****  *
 640:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to return
 641:../Libmaple/libmaple/libmaple/timer.h ****  */
 642:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_count(timer_dev *dev) {
 643:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->CNT;
 644:../Libmaple/libmaple/libmaple/timer.h **** }
 645:../Libmaple/libmaple/libmaple/timer.h **** 
 646:../Libmaple/libmaple/libmaple/timer.h **** /**
 647:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Sets the counter value for the given timer.
 648:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose counter to set
 649:../Libmaple/libmaple/libmaple/timer.h ****  * @param value New counter value
 650:../Libmaple/libmaple/libmaple/timer.h ****  */
 651:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_count(timer_dev *dev, uint16 value) {
 652:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->CNT = value;
 653:../Libmaple/libmaple/libmaple/timer.h **** }
 654:../Libmaple/libmaple/libmaple/timer.h **** 
 655:../Libmaple/libmaple/libmaple/timer.h **** /**
 656:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns the given timer's prescaler.
 657:../Libmaple/libmaple/libmaple/timer.h ****  *
 658:../Libmaple/libmaple/libmaple/timer.h ****  * Note that if the timer's prescaler is set (e.g. via
 659:../Libmaple/libmaple/libmaple/timer.h ****  * timer_set_prescaler() or accessing a TIMx_PSC register), the value
 660:../Libmaple/libmaple/libmaple/timer.h ****  * returned by this function will reflect the new setting, but the
 661:../Libmaple/libmaple/libmaple/timer.h ****  * timer's counter will only reflect the new prescaler at the next
 662:../Libmaple/libmaple/libmaple/timer.h ****  * update event.
 663:../Libmaple/libmaple/libmaple/timer.h ****  *
 664:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to return
 665:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 666:../Libmaple/libmaple/libmaple/timer.h ****  */
 667:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_prescaler(timer_dev *dev) {
 668:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->PSC;
 669:../Libmaple/libmaple/libmaple/timer.h **** }
 670:../Libmaple/libmaple/libmaple/timer.h **** 
 671:../Libmaple/libmaple/libmaple/timer.h **** /**
 672:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's prescale value.
 673:../Libmaple/libmaple/libmaple/timer.h ****  *
 674:../Libmaple/libmaple/libmaple/timer.h ****  * Divides the input clock by (PSC+1).  The new value will not take
 675:../Libmaple/libmaple/libmaple/timer.h ****  * effect until the next update event.
 676:../Libmaple/libmaple/libmaple/timer.h ****  *
 677:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose prescaler to set
 678:../Libmaple/libmaple/libmaple/timer.h ****  * @param psc New prescaler value
 679:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 680:../Libmaple/libmaple/libmaple/timer.h ****  */
 681:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_prescaler(timer_dev *dev, uint16 psc) {
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 683:../Libmaple/libmaple/libmaple/timer.h **** }
 684:../Libmaple/libmaple/libmaple/timer.h **** 
 685:../Libmaple/libmaple/libmaple/timer.h **** /**
 686:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Returns a timer's reload value.
 687:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to return
 688:../Libmaple/libmaple/libmaple/timer.h ****  */
 689:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_reload(timer_dev *dev) {
 690:../Libmaple/libmaple/libmaple/timer.h ****     return (uint16)(dev->regs).bas->ARR;
 691:../Libmaple/libmaple/libmaple/timer.h **** }
 692:../Libmaple/libmaple/libmaple/timer.h **** 
 693:../Libmaple/libmaple/libmaple/timer.h **** /**
 694:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set a timer's reload value.
 695:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer whose reload value to set
 696:../Libmaple/libmaple/libmaple/timer.h ****  * @param arr New reload value to use.  Takes effect at next update event.
 697:../Libmaple/libmaple/libmaple/timer.h ****  * @see timer_generate_update()
 698:../Libmaple/libmaple/libmaple/timer.h ****  */
 699:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_reload(timer_dev *dev, uint16 arr) {
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 701:../Libmaple/libmaple/libmaple/timer.h **** }
 702:../Libmaple/libmaple/libmaple/timer.h **** 
 703:../Libmaple/libmaple/libmaple/timer.h **** /**
 704:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Get the compare value for the given timer channel.
 705:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 706:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to get.
 707:../Libmaple/libmaple/libmaple/timer.h ****  */
 708:../Libmaple/libmaple/libmaple/timer.h **** static inline uint16 timer_get_compare(timer_dev *dev, uint8 channel) {
 709:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 710:../Libmaple/libmaple/libmaple/timer.h ****     return *ccr;
 711:../Libmaple/libmaple/libmaple/timer.h **** }
 712:../Libmaple/libmaple/libmaple/timer.h **** 
 713:../Libmaple/libmaple/libmaple/timer.h **** /**
 714:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Set the compare value for the given timer channel.
 715:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device, must have type TIMER_ADVANCED or TIMER_GENERAL.
 716:../Libmaple/libmaple/libmaple/timer.h ****  * @param channel Channel whose compare value to set.
 717:../Libmaple/libmaple/libmaple/timer.h ****  * @param value   New compare value.
 718:../Libmaple/libmaple/libmaple/timer.h ****  */
 719:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_set_compare(timer_dev *dev,
 720:../Libmaple/libmaple/libmaple/timer.h ****                                      uint8 channel,
 721:../Libmaple/libmaple/libmaple/timer.h ****                                      uint16 value) {
 722:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 3582              		.loc 16 722 0 discriminator 2
 3583 001c 5168     		ldr	r1, [r2, #4]
 3584 001e 527B     		ldrb	r2, [r2, #13]	@ zero_extendqisi2
 3585 0020 0968     		ldr	r1, [r1, #0]
 3586 0022 013A     		subs	r2, r2, #1
 3587 0024 3431     		adds	r1, r1, #52
 3588              	.LVL257:
 723:../Libmaple/libmaple/libmaple/timer.h ****     *ccr = value;
 3589              		.loc 16 723 0 discriminator 2
 3590 0026 41F82270 		str	r7, [r1, r2, lsl #2]
 3591              	.LVL258:
 3592              	.L198:
 3593              	.LBE216:
 3594              	.LBE217:
  74:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3595              		.loc 15 74 0 discriminator 1
 3596 002a 8342     		cmp	r3, r0
 3597 002c F0DB     		blt	.L199
 3598              	.LBE218:
  76:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  77:../Libraries/AQ_Motors/Motors_STM32.h **** }
 3599              		.loc 15 77 0
 3600 002e F0BD     		pop	{r4, r5, r6, r7, pc}
 3601              	.L201:
 3602              		.align	2
 3603              	.L200:
 3604 0030 00000000 		.word	.LANCHOR52
 3605 0034 00000000 		.word	.LANCHOR53
 3606 0038 00000000 		.word	PIN_MAP
 3607 003c 00000000 		.word	.LANCHOR54
 3608              		.cfi_endproc
 3609              	.LFE177:
 3611              		.section	.text._Z16commandAllMotorsi,"ax",%progbits
 3612              		.align	1
 3613              		.global	_Z16commandAllMotorsi
 3614              		.thumb
 3615              		.thumb_func
 3617              	_Z16commandAllMotorsi:
 3618              	.LFB178:
  78:../Libraries/AQ_Motors/Motors_STM32.h **** 
  79:../Libraries/AQ_Motors/Motors_STM32.h **** void commandAllMotors(int _motorCommand) {   // Send same command to all motors
 3619              		.loc 15 79 0
 3620              		.cfi_startproc
 3621              		@ args = 0, pretend = 0, frame = 0
 3622              		@ frame_needed = 0, uses_anonymous_args = 0
 3623              	.LVL259:
 3624              	.LBB223:
  80:../Libraries/AQ_Motors/Motors_STM32.h **** 
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3625              		.loc 15 81 0
 3626 0000 0A4B     		ldr	r3, .L205
 3627              	.LBE223:
  79:../Libraries/AQ_Motors/Motors_STM32.h **** void commandAllMotors(int _motorCommand) {   // Send same command to all motors
 3628              		.loc 15 79 0
 3629 0002 70B5     		push	{r4, r5, r6, lr}
 3630              	.LCFI33:
 3631              		.cfi_def_cfa_offset 16
 3632              		.cfi_offset 4, -16
 3633              		.cfi_offset 5, -12
 3634              		.cfi_offset 6, -8
 3635              		.cfi_offset 14, -4
 3636              	.LBB228:
 3637              	.LBB224:
 3638              	.LBB225:
  79:../Libraries/AQ_Motors/Motors_STM32.h **** void commandAllMotors(int _motorCommand) {   // Send same command to all motors
 3639              		.loc 15 79 0
 3640 0004 80B2     		uxth	r0, r0
 3641              	.LVL260:
 3642              	.LBE225:
 3643              	.LBE224:
 3644              		.loc 15 81 0
 3645 0006 1C68     		ldr	r4, [r3, #0]
  82:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_set_compare(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device, PIN_MAP[STM32_MOTOR_MAP[motor]]
 3646              		.loc 15 82 0
 3647 0008 094D     		ldr	r5, .L205+4
 3648 000a 0A4E     		ldr	r6, .L205+8
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3649              		.loc 15 81 0
 3650 000c 0023     		movs	r3, #0
 3651 000e 0AE0     		b	.L203
 3652              	.LVL261:
 3653              	.L204:
 3654              		.loc 15 82 0 discriminator 2
 3655 0010 5A5D     		ldrb	r2, [r3, r5]	@ zero_extendqisi2
 3656              	.LVL262:
 3657 0012 06EB0212 		add	r2, r6, r2, lsl #4
 3658              	.LVL263:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3659              		.loc 15 81 0 discriminator 2
 3660 0016 0133     		adds	r3, r3, #1
 3661              	.LVL264:
 3662              	.LBB227:
 3663              	.LBB226:
 722:../Libmaple/libmaple/libmaple/timer.h ****     __io uint32 *ccr = &(dev->regs).gen->CCR1 + (channel - 1);
 3664              		.loc 16 722 0 discriminator 2
 3665 0018 5168     		ldr	r1, [r2, #4]
 3666 001a 527B     		ldrb	r2, [r2, #13]	@ zero_extendqisi2
 3667 001c 0968     		ldr	r1, [r1, #0]
 3668 001e 013A     		subs	r2, r2, #1
 3669 0020 3431     		adds	r1, r1, #52
 3670              	.LVL265:
 3671              		.loc 16 723 0 discriminator 2
 3672 0022 41F82200 		str	r0, [r1, r2, lsl #2]
 3673              	.LVL266:
 3674              	.L203:
 3675              	.LBE226:
 3676              	.LBE227:
  81:../Libraries/AQ_Motors/Motors_STM32.h ****   for(int motor=0; motor < _stm32_motor_number; motor++) {
 3677              		.loc 15 81 0 discriminator 1
 3678 0026 A342     		cmp	r3, r4
 3679 0028 F2DB     		blt	.L204
 3680              	.LBE228:
  83:../Libraries/AQ_Motors/Motors_STM32.h ****   }
  84:../Libraries/AQ_Motors/Motors_STM32.h **** }
 3681              		.loc 15 84 0
 3682 002a 70BD     		pop	{r4, r5, r6, pc}
 3683              	.L206:
 3684              		.align	2
 3685              	.L205:
 3686 002c 00000000 		.word	.LANCHOR52
 3687 0030 00000000 		.word	.LANCHOR53
 3688 0034 00000000 		.word	PIN_MAP
 3689              		.cfi_endproc
 3690              	.LFE178:
 3692              		.section	.text._Z16initializeMotors9NB_Motors,"ax",%progbits
 3693              		.align	1
 3694              		.global	_Z16initializeMotors9NB_Motors
 3695              		.thumb
 3696              		.thumb_func
 3698              	_Z16initializeMotors9NB_Motors:
 3699              	.LFB176:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 3700              		.loc 15 33 0
 3701              		.cfi_startproc
 3702              		@ args = 0, pretend = 0, frame = 0
 3703              		@ frame_needed = 0, uses_anonymous_args = 0
 3704              	.LVL267:
 3705              	.LBB242:
  38:../Libraries/AQ_Motors/Motors_STM32.h ****   if(numbers < _stm32_motor_number) {
 3706              		.loc 15 38 0
 3707 0000 0728     		cmp	r0, #7
 3708              	.LBE242:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 3709              		.loc 15 33 0
 3710 0002 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 3711              	.LCFI34:
 3712              		.cfi_def_cfa_offset 32
 3713              		.cfi_offset 3, -32
 3714              		.cfi_offset 4, -28
 3715              		.cfi_offset 5, -24
 3716              		.cfi_offset 6, -20
 3717              		.cfi_offset 7, -16
 3718              		.cfi_offset 8, -12
 3719              		.cfi_offset 9, -8
 3720              		.cfi_offset 14, -4
 3721 0006 204B     		ldr	r3, .L214
 3722              	.LBB262:
  38:../Libraries/AQ_Motors/Motors_STM32.h ****   if(numbers < _stm32_motor_number) {
 3723              		.loc 15 38 0
 3724 0008 02DD     		ble	.L208
  37:../Libraries/AQ_Motors/Motors_STM32.h ****   _stm32_motor_number = sizeof(STM32_MOTOR_MAP)/sizeof(STM32_MOTOR_MAP[0]);
 3725              		.loc 15 37 0
 3726 000a 0822     		movs	r2, #8
 3727 000c 1A60     		str	r2, [r3, #0]
 3728 000e 00E0     		b	.L209
 3729              	.L208:
  39:../Libraries/AQ_Motors/Motors_STM32.h ****     _stm32_motor_number = numbers;
 3730              		.loc 15 39 0
 3731 0010 1860     		str	r0, [r3, #0]
 3732              	.L209:
 3733              	.LBE262:
  33:../Libraries/AQ_Motors/Motors_STM32.h **** void initializeMotors(NB_Motors numbers) {
 3734              		.loc 15 33 0 discriminator 1
 3735 0012 0024     		movs	r4, #0
 3736              	.LBB263:
 3737              	.LBB243:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 3738              		.loc 15 42 0 discriminator 1
 3739 0014 1C4F     		ldr	r7, .L214
 3740              	.LBB244:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 3741              		.loc 15 44 0 discriminator 1
 3742 0016 DFF87C80 		ldr	r8, .L214+12
 3743 001a DFF87490 		ldr	r9, .L214+8
 3744 001e 17E0     		b	.L210
 3745              	.LVL268:
 3746              	.L211:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 3747              		.loc 15 44 0 is_stmt 0 discriminator 2
 3748 0020 14F80850 		ldrb	r5, [r4, r8]	@ zero_extendqisi2
 3749 0024 09EB0516 		add	r6, r9, r5, lsl #4
 3750              	.LBE244:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 3751              		.loc 15 42 0 is_stmt 1 discriminator 2
 3752 0028 0134     		adds	r4, r4, #1
 3753              	.LVL269:
 3754              	.LBB253:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 3755              		.loc 15 44 0 discriminator 2
 3756 002a 7368     		ldr	r3, [r6, #4]
 3757 002c 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 3758 002e FFF7FEFF 		bl	rcc_dev_timer_clk_speed
 3759              	.LVL270:
 3760 0032 164A     		ldr	r2, .L214+4
 3761              	.LBB245:
 3762              	.LBB246:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 3763              		.loc 16 682 0 discriminator 2
 3764 0034 7368     		ldr	r3, [r6, #4]
 3765              	.LBE246:
 3766              	.LBE245:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 3767              		.loc 15 44 0 discriminator 2
 3768 0036 B0FBF2F0 		udiv	r0, r0, r2
 3769              	.LVL271:
 3770              	.LBB249:
 3771              	.LBB247:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 3772              		.loc 16 682 0 discriminator 2
 3773 003a 1B68     		ldr	r3, [r3, #0]
 3774              	.LBE247:
 3775              	.LBE249:
  44:../Libraries/AQ_Motors/Motors_STM32.h ****     int prescaler = rcc_dev_timer_clk_speed(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device->clk_id)/1
 3776              		.loc 15 44 0 discriminator 2
 3777 003c 421E     		subs	r2, r0, #1
 3778              	.LVL272:
 3779              	.LBB250:
 3780              	.LBB248:
 682:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->PSC = psc;
 3781              		.loc 16 682 0 discriminator 2
 3782 003e 92B2     		uxth	r2, r2
 3783              	.LVL273:
 3784 0040 9A62     		str	r2, [r3, #40]
 3785              	.LVL274:
 3786              	.LBE248:
 3787              	.LBE250:
 3788              	.LBB251:
 3789              	.LBB252:
 700:../Libmaple/libmaple/libmaple/timer.h ****     (dev->regs).bas->ARR = arr;
 3790              		.loc 16 700 0 discriminator 2
 3791 0042 40F6C412 		movw	r2, #2500
 3792 0046 DA62     		str	r2, [r3, #44]
 3793              	.LBE252:
 3794              	.LBE251:
  60:../Libraries/AQ_Motors/Motors_STM32.h ****     pinMode(STM32_MOTOR_MAP[motor], PWM);
 3795              		.loc 15 60 0 discriminator 2
 3796 0048 2846     		mov	r0, r5
 3797 004a 0721     		movs	r1, #7
 3798 004c FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 3799              	.LVL275:
 3800              	.L210:
 3801              	.LBE253:
  42:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 3802              		.loc 15 42 0 discriminator 1
 3803 0050 3A68     		ldr	r2, [r7, #0]
 3804 0052 9442     		cmp	r4, r2
 3805 0054 E4DB     		blt	.L211
 3806 0056 0023     		movs	r3, #0
 3807              	.LBE243:
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
 3808              		.loc 15 65 0 discriminator 1
 3809 0058 0D49     		ldr	r1, .L214+8
 3810 005a 0E48     		ldr	r0, .L214+12
 3811              	.LBB254:
 3812              	.LBB255:
 724:../Libmaple/libmaple/libmaple/timer.h **** }
 725:../Libmaple/libmaple/libmaple/timer.h **** 
 726:../Libmaple/libmaple/libmaple/timer.h **** /**
 727:../Libmaple/libmaple/libmaple/timer.h ****  * @brief Generate an update event for the given timer.
 728:../Libmaple/libmaple/libmaple/timer.h ****  *
 729:../Libmaple/libmaple/libmaple/timer.h ****  * Normally, this will cause the prescaler and auto-reload values in
 730:../Libmaple/libmaple/libmaple/timer.h ****  * the PSC and ARR registers to take immediate effect.  However, this
 731:../Libmaple/libmaple/libmaple/timer.h ****  * function will do nothing if the UDIS bit is set in the timer's CR1
 732:../Libmaple/libmaple/libmaple/timer.h ****  * register (UDIS is cleared by default).
 733:../Libmaple/libmaple/libmaple/timer.h ****  *
 734:../Libmaple/libmaple/libmaple/timer.h ****  * @param dev Timer device to generate an update for.
 735:../Libmaple/libmaple/libmaple/timer.h ****  */
 736:../Libmaple/libmaple/libmaple/timer.h **** static inline void timer_generate_update(timer_dev *dev) {
 737:../Libmaple/libmaple/libmaple/timer.h ****     *bb_perip(&(dev->regs).bas->EGR, TIMER_EGR_UG_BIT) = 1;
 3813              		.loc 16 737 0 discriminator 1
 3814 005c 0124     		movs	r4, #1
 3815              	.LVL276:
 3816 005e 0AE0     		b	.L212
 3817              	.LVL277:
 3818              	.L213:
 3819              	.LBE255:
 3820              	.LBE254:
  65:../Libraries/AQ_Motors/Motors_STM32.h ****     timer_generate_update(PIN_MAP[STM32_MOTOR_MAP[motor]].timer_device);
 3821              		.loc 15 65 0 discriminator 2
 3822 0060 1D5C     		ldrb	r5, [r3, r0]	@ zero_extendqisi2
 3823 0062 01EB0515 		add	r5, r1, r5, lsl #4
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 3824              		.loc 15 64 0 discriminator 2
 3825 0066 0133     		adds	r3, r3, #1
 3826              	.LVL278:
 3827              	.LBB261:
 3828              	.LBB260:
 3829              		.loc 16 737 0 discriminator 2
 3830 0068 6D68     		ldr	r5, [r5, #4]
 3831 006a 2D68     		ldr	r5, [r5, #0]
 3832 006c 1435     		adds	r5, r5, #20
 3833              	.LBB256:
 3834              	.LBB257:
 3835              	.LBB258:
 3836              	.LBB259:
 3837              		.file 17 "../Libmaple/libmaple/libmaple/bitband.h"
   1:../Libmaple/libmaple/libmaple/bitband.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/bitband.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/bitband.h ****  *
   4:../Libmaple/libmaple/libmaple/bitband.h ****  * Copyright (c) 2011 LeafLabs, LLC.
   5:../Libmaple/libmaple/libmaple/bitband.h ****  *
   6:../Libmaple/libmaple/libmaple/bitband.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/bitband.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/bitband.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/bitband.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/bitband.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/bitband.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/bitband.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/bitband.h ****  *
  14:../Libmaple/libmaple/libmaple/bitband.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/bitband.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/bitband.h ****  *
  17:../Libmaple/libmaple/libmaple/bitband.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/bitband.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/bitband.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/bitband.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/bitband.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/bitband.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/bitband.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/bitband.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/bitband.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/bitband.h **** 
  27:../Libmaple/libmaple/libmaple/bitband.h **** /**
  28:../Libmaple/libmaple/libmaple/bitband.h ****  * @file bitband.h
  29:../Libmaple/libmaple/libmaple/bitband.h ****  *
  30:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Bit-banding utility functions
  31:../Libmaple/libmaple/libmaple/bitband.h ****  */
  32:../Libmaple/libmaple/libmaple/bitband.h **** 
  33:../Libmaple/libmaple/libmaple/bitband.h **** #include "libmaple_types.h"
  34:../Libmaple/libmaple/libmaple/bitband.h **** 
  35:../Libmaple/libmaple/libmaple/bitband.h **** #ifndef _BITBAND_H_
  36:../Libmaple/libmaple/libmaple/bitband.h **** #define _BITBAND_H_
  37:../Libmaple/libmaple/libmaple/bitband.h **** 
  38:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_REF      0x20000000
  39:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_SRAM_BASE     0x22000000
  40:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_REF      0x40000000
  41:../Libmaple/libmaple/libmaple/bitband.h **** #define BB_PERI_BASE     0x42000000
  42:../Libmaple/libmaple/libmaple/bitband.h **** 
  43:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void*,
  44:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  45:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32,
  46:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32);
  47:../Libmaple/libmaple/libmaple/bitband.h **** 
  48:../Libmaple/libmaple/libmaple/bitband.h **** /**
  49:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  50:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a volatile SRAM address.
  51:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded SRAM region
  52:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  53:../Libmaple/libmaple/libmaple/bitband.h ****  */
  54:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_sramp(volatile void *address, uint32 bit) {
  55:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_SRAM_BASE, BB_SRAM_REF);
  56:../Libmaple/libmaple/libmaple/bitband.h **** }
  57:../Libmaple/libmaple/libmaple/bitband.h **** 
  58:../Libmaple/libmaple/libmaple/bitband.h **** /**
  59:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the SRAM bit-band region.
  60:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to read from
  61:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  62:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  63:../Libmaple/libmaple/libmaple/bitband.h ****  */
  64:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_sram_get_bit(volatile void *address, uint32 bit) {
  65:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_sramp(address, bit);
  66:../Libmaple/libmaple/libmaple/bitband.h **** }
  67:../Libmaple/libmaple/libmaple/bitband.h **** 
  68:../Libmaple/libmaple/libmaple/bitband.h **** /**
  69:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the SRAM bit-band region.
  70:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the SRAM bit-band region to write to
  71:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
  72:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
  73:../Libmaple/libmaple/libmaple/bitband.h ****  */
  74:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_sram_set_bit(volatile void *address,
  75:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
  76:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
  77:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_sramp(address, bit) = val;
  78:../Libmaple/libmaple/libmaple/bitband.h **** }
  79:../Libmaple/libmaple/libmaple/bitband.h **** 
  80:../Libmaple/libmaple/libmaple/bitband.h **** /**
  81:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Obtain a pointer to the bit-band address corresponding to a
  82:../Libmaple/libmaple/libmaple/bitband.h ****  * bit in a peripheral address.
  83:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the bit-banded peripheral region
  84:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit     Bit in address to bit-band
  85:../Libmaple/libmaple/libmaple/bitband.h ****  */
  86:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* bb_perip(volatile void *address, uint32 bit) {
  87:../Libmaple/libmaple/libmaple/bitband.h ****     return __bb_addr(address, bit, BB_PERI_BASE, BB_PERI_REF);
  88:../Libmaple/libmaple/libmaple/bitband.h **** }
  89:../Libmaple/libmaple/libmaple/bitband.h **** 
  90:../Libmaple/libmaple/libmaple/bitband.h **** /**
  91:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Get a bit from an address in the peripheral bit-band region.
  92:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to read from
  93:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to read
  94:../Libmaple/libmaple/libmaple/bitband.h ****  * @return bit's value in address.
  95:../Libmaple/libmaple/libmaple/bitband.h ****  */
  96:../Libmaple/libmaple/libmaple/bitband.h **** static inline uint8 bb_peri_get_bit(volatile void *address, uint32 bit) {
  97:../Libmaple/libmaple/libmaple/bitband.h ****     return *bb_perip(address, bit);
  98:../Libmaple/libmaple/libmaple/bitband.h **** }
  99:../Libmaple/libmaple/libmaple/bitband.h **** 
 100:../Libmaple/libmaple/libmaple/bitband.h **** /**
 101:../Libmaple/libmaple/libmaple/bitband.h ****  * @brief Set a bit in an address in the peripheral bit-band region.
 102:../Libmaple/libmaple/libmaple/bitband.h ****  * @param address Address in the peripheral bit-band region to write to
 103:../Libmaple/libmaple/libmaple/bitband.h ****  * @param bit Bit in address to write to
 104:../Libmaple/libmaple/libmaple/bitband.h ****  * @param val Value to write for bit, either 0 or 1.
 105:../Libmaple/libmaple/libmaple/bitband.h ****  */
 106:../Libmaple/libmaple/libmaple/bitband.h **** static inline void bb_peri_set_bit(volatile void *address,
 107:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint32 bit,
 108:../Libmaple/libmaple/libmaple/bitband.h ****                                    uint8 val) {
 109:../Libmaple/libmaple/libmaple/bitband.h ****     *bb_perip(address, bit) = val;
 110:../Libmaple/libmaple/libmaple/bitband.h **** }
 111:../Libmaple/libmaple/libmaple/bitband.h **** 
 112:../Libmaple/libmaple/libmaple/bitband.h **** static inline volatile uint32* __bb_addr(volatile void *address,
 113:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bit,
 114:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_base,
 115:../Libmaple/libmaple/libmaple/bitband.h ****                                          uint32 bb_ref) {
 116:../Libmaple/libmaple/libmaple/bitband.h ****     return (volatile uint32*)(bb_base + ((uint32)address - bb_ref) * 32 +
 117:../Libmaple/libmaple/libmaple/bitband.h ****                               bit * 4);
 3838              		.loc 17 117 0 discriminator 2
 3839 006e 6D01     		lsls	r5, r5, #5
 3840 0070 05F18445 		add	r5, r5, #1107296256
 3841              	.LBE259:
 3842              	.LBE258:
 3843              	.LBE257:
 3844              	.LBE256:
 3845              		.loc 16 737 0 discriminator 2
 3846 0074 2C60     		str	r4, [r5, #0]
 3847              	.LVL279:
 3848              	.L212:
 3849              	.LBE260:
 3850              	.LBE261:
  64:../Libraries/AQ_Motors/Motors_STM32.h ****   for(motor=0; motor < _stm32_motor_number; motor++) {
 3851              		.loc 15 64 0 discriminator 1
 3852 0076 9342     		cmp	r3, r2
 3853 0078 F2DB     		blt	.L213
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
 3854              		.loc 15 68 0
 3855 007a 4FF47A70 		mov	r0, #1000
 3856              	.LBE263:
  70:../Libraries/AQ_Motors/Motors_STM32.h **** }
 3857              		.loc 15 70 0
 3858 007e BDE8F843 		pop	{r3, r4, r5, r6, r7, r8, r9, lr}
 3859              	.LBB264:
  68:../Libraries/AQ_Motors/Motors_STM32.h ****   commandAllMotors(1000);
 3860              		.loc 15 68 0
 3861 0082 FFF7FEBF 		b	_Z16commandAllMotorsi
 3862              	.LVL280:
 3863              	.L215:
 3864 0086 00BF     		.align	2
 3865              	.L214:
 3866 0088 00000000 		.word	.LANCHOR52
 3867 008c 40420F00 		.word	1000000
 3868 0090 00000000 		.word	PIN_MAP
 3869 0094 00000000 		.word	.LANCHOR53
 3870              	.LBE264:
 3871              		.cfi_endproc
 3872              	.LFE176:
 3874              		.section	.text._Z11pulseMotorsh,"ax",%progbits
 3875              		.align	1
 3876              		.global	_Z11pulseMotorsh
 3877              		.thumb
 3878              		.thumb_func
 3880              	_Z11pulseMotorsh:
 3881              	.LFB175:
 3882              		.file 18 "../Libraries/AQ_Motors/Motors.h"
   1:../Libraries/AQ_Motors/Motors.h **** /*
   2:../Libraries/AQ_Motors/Motors.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_Motors/Motors.h ****   www.AeroQuad.com
   4:../Libraries/AQ_Motors/Motors.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_Motors/Motors.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_Motors/Motors.h ****  
   7:../Libraries/AQ_Motors/Motors.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_Motors/Motors.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_Motors/Motors.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_Motors/Motors.h ****   (at your option) any later version. 
  11:../Libraries/AQ_Motors/Motors.h **** 
  12:../Libraries/AQ_Motors/Motors.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_Motors/Motors.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_Motors/Motors.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_Motors/Motors.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_Motors/Motors.h **** 
  17:../Libraries/AQ_Motors/Motors.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_Motors/Motors.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_Motors/Motors.h **** */
  20:../Libraries/AQ_Motors/Motors.h **** 
  21:../Libraries/AQ_Motors/Motors.h **** 
  22:../Libraries/AQ_Motors/Motors.h **** #ifndef _AEROQUAD_MOTORS_H_
  23:../Libraries/AQ_Motors/Motors.h **** #define _AEROQUAD_MOTORS_H_
  24:../Libraries/AQ_Motors/Motors.h **** 
  25:../Libraries/AQ_Motors/Motors.h **** #include "Arduino.h"
  26:../Libraries/AQ_Motors/Motors.h **** 
  27:../Libraries/AQ_Motors/Motors.h **** #define MOTOR1 0
  28:../Libraries/AQ_Motors/Motors.h **** #define MOTOR2 1
  29:../Libraries/AQ_Motors/Motors.h **** #define MOTOR3 2
  30:../Libraries/AQ_Motors/Motors.h **** #define MOTOR4 3
  31:../Libraries/AQ_Motors/Motors.h **** #define MOTOR5 4
  32:../Libraries/AQ_Motors/Motors.h **** #define MOTOR6 5
  33:../Libraries/AQ_Motors/Motors.h **** #define MOTOR7 6
  34:../Libraries/AQ_Motors/Motors.h **** #define MOTOR8 7
  35:../Libraries/AQ_Motors/Motors.h **** #define MINCOMMAND 1000
  36:../Libraries/AQ_Motors/Motors.h **** #define MAXCOMMAND 2000
  37:../Libraries/AQ_Motors/Motors.h **** 
  38:../Libraries/AQ_Motors/Motors.h **** enum NB_Motors{
  39:../Libraries/AQ_Motors/Motors.h ****   FOUR_Motors = 4,
  40:../Libraries/AQ_Motors/Motors.h ****   SIX_Motors = 6,
  41:../Libraries/AQ_Motors/Motors.h ****   EIGHT_Motors = 8
  42:../Libraries/AQ_Motors/Motors.h **** };
  43:../Libraries/AQ_Motors/Motors.h **** 
  44:../Libraries/AQ_Motors/Motors.h **** NB_Motors numberOfMotors = FOUR_Motors;
  45:../Libraries/AQ_Motors/Motors.h **** int motorCommand[8] = {0,0,0,0,0,0,0,0};  // LASTMOTOR not know here, so, default at 8 @todo : Kenn
  46:../Libraries/AQ_Motors/Motors.h ****   
  47:../Libraries/AQ_Motors/Motors.h **** void initializeMotors(NB_Motors numbers = FOUR_Motors);
  48:../Libraries/AQ_Motors/Motors.h **** void writeMotors();
  49:../Libraries/AQ_Motors/Motors.h **** void commandAllMotors(int command);
  50:../Libraries/AQ_Motors/Motors.h **** 
  51:../Libraries/AQ_Motors/Motors.h **** void pulseMotors(byte nbPulse) {
 3883              		.loc 18 51 0
 3884              		.cfi_startproc
 3885              		@ args = 0, pretend = 0, frame = 0
 3886              		@ frame_needed = 0, uses_anonymous_args = 0
 3887              	.LVL281:
 3888 0000 38B5     		push	{r3, r4, r5, lr}
 3889              	.LCFI35:
 3890              		.cfi_def_cfa_offset 16
 3891              		.cfi_offset 3, -16
 3892              		.cfi_offset 4, -12
 3893              		.cfi_offset 5, -8
 3894              		.cfi_offset 14, -4
 3895              		.loc 18 51 0
 3896 0002 0546     		mov	r5, r0
 3897              	.LBB265:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 3898              		.loc 18 52 0
 3899 0004 0024     		movs	r4, #0
 3900 0006 0FE0     		b	.L217
 3901              	.LVL282:
 3902              	.L218:
  53:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND + 100);
 3903              		.loc 18 53 0 discriminator 2
 3904 0008 40F24C40 		movw	r0, #1100
 3905 000c FFF7FEFF 		bl	_Z16commandAllMotorsi
 3906              	.LVL283:
  54:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 3907              		.loc 18 54 0 discriminator 2
 3908 0010 FA20     		movs	r0, #250
 3909 0012 FFF7FEFF 		bl	_Z5delaym
 3910              	.LVL284:
  55:../Libraries/AQ_Motors/Motors.h ****     commandAllMotors(MINCOMMAND);
 3911              		.loc 18 55 0 discriminator 2
 3912 0016 4FF47A70 		mov	r0, #1000
 3913 001a FFF7FEFF 		bl	_Z16commandAllMotorsi
 3914              	.LVL285:
  56:../Libraries/AQ_Motors/Motors.h ****     delay(250);
 3915              		.loc 18 56 0 discriminator 2
 3916 001e FA20     		movs	r0, #250
 3917 0020 FFF7FEFF 		bl	_Z5delaym
 3918              	.LVL286:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 3919              		.loc 18 52 0 discriminator 2
 3920 0024 0134     		adds	r4, r4, #1
 3921              	.LVL287:
 3922 0026 E4B2     		uxtb	r4, r4
 3923              	.LVL288:
 3924              	.L217:
  52:../Libraries/AQ_Motors/Motors.h ****   for (byte i = 0; i < nbPulse; i++) {
 3925              		.loc 18 52 0 is_stmt 0 discriminator 1
 3926 0028 AC42     		cmp	r4, r5
 3927 002a EDD1     		bne	.L218
 3928              	.LBE265:
  57:../Libraries/AQ_Motors/Motors.h ****   }
  58:../Libraries/AQ_Motors/Motors.h **** }
 3929              		.loc 18 58 0 is_stmt 1
 3930 002c 38BD     		pop	{r3, r4, r5, pc}
 3931              		.cfi_endproc
 3932              	.LFE175:
 3934              		.section	.text._Z17applyMotorCommandv,"ax",%progbits
 3935              		.align	1
 3936              		.global	_Z17applyMotorCommandv
 3937              		.thumb
 3938              		.thumb_func
 3940              	_Z17applyMotorCommandv:
 3941              	.LFB179:
 3942              		.file 19 "../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h"
   1:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
   2:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   AeroQuad v3.0.1 - February 2012
   3:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   www.AeroQuad.com
   4:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   An Open Source Arduino based multicopter.
   6:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
   7:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is free software: you can redistribute it and/or modify 
   8:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   it under the terms of the GNU General Public License as published by 
   9:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   (at your option) any later version. 
  11:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  12:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   This program is distributed in the hope that it will be useful, 
  13:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   GNU General Public License for more details. 
  16:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****  
  17:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   You should have received a copy of the GNU General Public License 
  18:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  20:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  21:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  22:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_X_MODE_H_
  23:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  24:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** /*
  25:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****        CW  0....Front....0 CCW
  26:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  27:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  28:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****            ......***......    
  29:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****       CCW  0....Back.....0  CW
  30:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** */
  31:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  32:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #include "FlightControlVariable.h"
  33:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  34:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #ifdef OLD_MOTOR_NUMBERING  
  35:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  36:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR2
  37:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR3
  38:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  39:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #else
  40:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_LEFT  MOTOR1
  41:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define FRONT_RIGHT MOTOR2
  42:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_RIGHT  MOTOR3
  43:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   #define REAR_LEFT   MOTOR4
  44:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #endif
  45:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** #define LASTMOTOR   (MOTOR4+1)
  46:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  47:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMaxCommand[4] = {0,0,0,0};
  48:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorMinCommand[4] = {0,0,0,0};
  49:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** int motorConfiguratorCommand[4] = {0,0,0,0};
  50:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** 
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 3943              		.loc 19 51 0
 3944              		.cfi_startproc
 3945              		@ args = 0, pretend = 0, frame = 0
 3946              		@ frame_needed = 0, uses_anonymous_args = 0
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 3947              		.loc 19 52 0
 3948 0000 0C4B     		ldr	r3, .L220
  51:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h **** void applyMotorCommand() {
 3949              		.loc 19 51 0
 3950 0002 70B5     		push	{r4, r5, r6, lr}
 3951              	.LCFI36:
 3952              		.cfi_def_cfa_offset 16
 3953              		.cfi_offset 4, -16
 3954              		.cfi_offset 5, -12
 3955              		.cfi_offset 6, -8
 3956              		.cfi_offset 14, -4
 3957              		.loc 19 52 0
 3958 0004 1C68     		ldr	r4, [r3, #0]
 3959 0006 0C4B     		ldr	r3, .L220+4
 3960 0008 1868     		ldr	r0, [r3, #0]
 3961 000a 0C4B     		ldr	r3, .L220+8
 3962 000c 1968     		ldr	r1, [r3, #0]
 3963 000e 0C4B     		ldr	r3, .L220+12
 3964 0010 251A     		subs	r5, r4, r0
 3965 0012 1A68     		ldr	r2, [r3, #0]
 3966 0014 0B4B     		ldr	r3, .L220+16
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 3967              		.loc 19 54 0
 3968 0016 2018     		adds	r0, r4, r0
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 3969              		.loc 19 52 0
 3970 0018 6E18     		adds	r6, r5, r1
 3971              		.loc 19 54 0
 3972 001a 4418     		adds	r4, r0, r1
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 3973              		.loc 19 53 0
 3974 001c 6D1A     		subs	r5, r5, r1
  55:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_RIGHT]  = throttle + motorAxisCommandPitch - motorAxisCommandRoll - (YAW_DIRECT
 3975              		.loc 19 55 0
 3976 001e 411A     		subs	r1, r0, r1
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 3977              		.loc 19 52 0
 3978 0020 B61A     		subs	r6, r6, r2
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 3979              		.loc 19 53 0
 3980 0022 AD18     		adds	r5, r5, r2
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 3981              		.loc 19 54 0
 3982 0024 A418     		adds	r4, r4, r2
 3983              		.loc 19 55 0
 3984 0026 8A1A     		subs	r2, r1, r2
  52:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_LEFT]  = throttle - motorAxisCommandPitch + motorAxisCommandRoll - (YAW_DIRECT
 3985              		.loc 19 52 0
 3986 0028 1E60     		str	r6, [r3, #0]
  53:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[FRONT_RIGHT] = throttle - motorAxisCommandPitch - motorAxisCommandRoll + (YAW_DIRECT
 3987              		.loc 19 53 0
 3988 002a 5D60     		str	r5, [r3, #4]
  54:../Libraries/AQ_FlightControlProcessor/FlightControlQuadX.h ****   motorCommand[REAR_LEFT]   = throttle + motorAxisCommandPitch + motorAxisCommandRoll + (YAW_DIRECT
 3989              		.loc 19 54 0
 3990 002c DC60     		str	r4, [r3, #12]
 3991              		.loc 19 55 0
 3992 002e 9A60     		str	r2, [r3, #8]
 3993 0030 70BD     		pop	{r4, r5, r6, pc}
 3994              	.L221:
 3995 0032 00BF     		.align	2
 3996              	.L220:
 3997 0034 00000000 		.word	.LANCHOR55
 3998 0038 00000000 		.word	.LANCHOR56
 3999 003c 00000000 		.word	.LANCHOR57
 4000 0040 00000000 		.word	.LANCHOR58
 4001 0044 00000000 		.word	.LANCHOR54
 4002              		.cfi_endproc
 4003              	.LFE179:
 4005              		.section	.text._Z20calculateFlightErrorv,"ax",%progbits
 4006              		.align	1
 4007              		.global	_Z20calculateFlightErrorv
 4008              		.thumb
 4009              		.thumb_func
 4011              	_Z20calculateFlightErrorv:
 4012              	.LFB180:
 4013              		.file 20 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/FlightControlProcessor.h"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   (at your option) any later version. 
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   GNU General Public License for more details. 
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** // FlightControl.pde is responsible for combining sensor measurements and
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** // transmitter commands into motor commands for the defined flight configuration (X, +, etc.)
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #ifndef _AQ_PROCESS_FLIGHT_CONTROL_H_
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #define _AQ_PROCESS_FLIGHT_CONTROL_H_
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #define ATTITUDE_SCALING (0.75 * PWM2RAD)
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * calculateFlightError
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Calculate roll/pitch axis error with gyro/accel data to
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * compute motor command thrust so used command are executed
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void calculateFlightError()
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 4014              		.loc 20 38 0
 4015              		.cfi_startproc
 4016              		@ args = 0, pretend = 0, frame = 0
 4017              		@ frame_needed = 0, uses_anonymous_args = 0
 4018 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4019              	.LCFI37:
 4020              		.cfi_def_cfa_offset 24
 4021              		.cfi_offset 3, -24
 4022              		.cfi_offset 4, -20
 4023              		.cfi_offset 5, -16
 4024              		.cfi_offset 6, -12
 4025              		.cfi_offset 7, -8
 4026              		.cfi_offset 14, -4
 4027 0002 2DED028B 		fstmfdd	sp!, {d8}
 4028              	.LCFI38:
 4029              		.cfi_def_cfa_offset 32
 4030              		.cfi_offset 80, -32
 4031              	.LBB266:
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined (UseGPSNavigator)
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS] + gpsRollAxi
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS] + gpsPitchAx
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAX
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     else
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (flightMode == ATTITUDE_FLIGHT_MODE) {
 4032              		.loc 20 48 0
 4033 0006 364B     		ldr	r3, .L226
 4034 0008 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4035 000a 012B     		cmp	r3, #1
 4036 000c 39D1     		bne	.L223
 4037              	.LBB267:
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 4038              		.loc 20 49 0
 4039 000e 354D     		ldr	r5, .L226+4
 4040 0010 354E     		ldr	r6, .L226+8
 4041 0012 2B68     		ldr	r3, [r5, #0]
 4042 0014 3268     		ldr	r2, [r6, #0]
 4043 0016 354C     		ldr	r4, .L226+12
 4044 0018 D31A     		subs	r3, r2, r3
 4045 001a 07EE103A 		fmsr	s14, r3	@ int
 4046 001e 9FED348A 		flds	s16, .L226+16
 4047 0022 F8EEC77A 		fsitos	s15, s14
 4048 0026 2168     		ldr	r1, [r4, #0]	@ float
 4049 0028 324A     		ldr	r2, .L226+20
 4050 002a 67EE887A 		fmuls	s15, s15, s16
 4051 002e 17EE900A 		fmrs	r0, s15
 4052 0032 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4053              	.LVL289:
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 4054              		.loc 20 50 0
 4055 0036 7268     		ldr	r2, [r6, #4]
 4056 0038 6B68     		ldr	r3, [r5, #4]
 4057 003a 6168     		ldr	r1, [r4, #4]	@ float
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 4058              		.loc 20 51 0
 4059 003c 2E4C     		ldr	r4, .L226+24
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 4060              		.loc 20 50 0
 4061 003e D31A     		subs	r3, r2, r3
 4062 0040 07EE103A 		fmsr	s14, r3	@ int
 4063 0044 F8EEC77A 		fsitos	s15, s14
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float rollAttitudeCmd  = updatePID((receiverCommand[XAXIS] - receiverZero[XAXIS]) * ATTITUDE_SC
 4064              		.loc 20 49 0
 4065 0048 0746     		mov	r7, r0	@ float
 4066              	.LVL290:
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 4067              		.loc 20 50 0
 4068 004a 67EE887A 		fmuls	s15, s15, s16
 4069 004e 81F00041 		eor	r1, r1, #-2147483648
 4070 0052 17EE900A 		fmrs	r0, s15
 4071              	.LVL291:
 4072 0056 294A     		ldr	r2, .L226+28
 4073 0058 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4074              	.LVL292:
 4075              		.loc 20 51 0
 4076 005c 2168     		ldr	r1, [r4, #0]	@ float
 4077 005e 284A     		ldr	r2, .L226+32
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     float pitchAttitudeCmd = updatePID((receiverCommand[YAXIS] - receiverZero[YAXIS]) * ATTITUDE_SC
 4078              		.loc 20 50 0
 4079 0060 0546     		mov	r5, r0	@ float
 4080              	.LVL293:
 4081              		.loc 20 51 0
 4082 0062 3846     		mov	r0, r7	@ float
 4083              	.LVL294:
 4084 0064 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4085              	.LVL295:
 4086 0068 07EE100A 		fmsr	s14, r0
 4087 006c 254B     		ldr	r3, .L226+36
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandPitch  = updatePID(pitchAttitudeCmd, -gyroRate[YAXIS], &PID[ATTITUDE_GYRO_YAXIS
 4088              		.loc 20 52 0
 4089 006e 6168     		ldr	r1, [r4, #4]	@ float
 4090 0070 254A     		ldr	r2, .L226+40
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 4091              		.loc 20 51 0
 4092 0072 FDEEC77A 		ftosizs	s15, s14
 4093              		.loc 20 52 0
 4094 0076 2846     		mov	r0, r5	@ float
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll   = updatePID(rollAttitudeCmd, gyroRate[XAXIS], &PID[ATTITUDE_GYRO_XAXIS_P
 4095              		.loc 20 51 0
 4096 0078 C3ED007A 		fsts	s15, [r3, #0]	@ int
 4097              		.loc 20 52 0
 4098 007c 81F00041 		eor	r1, r1, #-2147483648
 4099 0080 22E0     		b	.L225
 4100              	.LVL296:
 4101              	.L223:
 4102              	.LBE267:
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   else {
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 4103              		.loc 20 55 0
 4104 0082 1D4D     		ldr	r5, .L226+24
 4105 0084 214C     		ldr	r4, .L226+44
 4106 0086 0020     		movs	r0, #0
 4107 0088 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 4108              	.LVL297:
 4109 008c 95ED007A 		flds	s14, [r5, #0]
 4110 0090 D4ED007A 		flds	s15, [r4, #0]
 4111 0094 67EE277A 		fmuls	s15, s14, s15
 4112 0098 1D4A     		ldr	r2, .L226+48
 4113 009a 17EE901A 		fmrs	r1, s15
 4114 009e FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4115              	.LVL298:
 4116 00a2 07EE100A 		fmsr	s14, r0
 4117 00a6 174B     		ldr	r3, .L226+36
 4118 00a8 FDEEC77A 		ftosizs	s15, s14
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandPitch = updatePID(getReceiverSIData(YAXIS), -gyroRate[YAXIS]*rotationSpeedFacto
 4119              		.loc 20 56 0
 4120 00ac 0120     		movs	r0, #1
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorAxisCommandRoll = updatePID(getReceiverSIData(XAXIS), gyroRate[XAXIS]*rotationSpeedFactor,
 4121              		.loc 20 55 0
 4122 00ae C3ED007A 		fsts	s15, [r3, #0]	@ int
 4123              		.loc 20 56 0
 4124 00b2 FFF7FEFF 		bl	_Z17getReceiverSIDatah
 4125              	.LVL299:
 4126 00b6 95ED017A 		flds	s14, [r5, #4]
 4127 00ba D4ED007A 		flds	s15, [r4, #0]
 4128 00be 67EE677A 		fnmuls	s15, s14, s15
 4129 00c2 144A     		ldr	r2, .L226+52
 4130 00c4 17EE901A 		fmrs	r1, s15
 4131              	.L225:
 4132 00c8 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4133              	.LVL300:
 4134 00cc 07EE100A 		fmsr	s14, r0
 4135 00d0 114B     		ldr	r3, .L226+56
 4136 00d2 FDEEC77A 		ftosizs	s15, s14
 4137 00d6 C3ED007A 		fsts	s15, [r3, #0]	@ int
 4138              	.LBE266:
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 4139              		.loc 20 58 0
 4140 00da BDEC028B 		fldmfdd	sp!, {d8}
 4141 00de F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4142              	.L227:
 4143              		.align	2
 4144              	.L226:
 4145 00e0 00000000 		.word	.LANCHOR59
 4146 00e4 00000000 		.word	.LANCHOR6
 4147 00e8 00000000 		.word	.LANCHOR4
 4148 00ec 00000000 		.word	.LANCHOR36
 4149 00f0 A69BC43A 		.word	985963430
 4150 00f4 48000000 		.word	.LANCHOR15+72
 4151 00f8 00000000 		.word	.LANCHOR21
 4152 00fc 60000000 		.word	.LANCHOR15+96
 4153 0100 90000000 		.word	.LANCHOR15+144
 4154 0104 00000000 		.word	.LANCHOR57
 4155 0108 A8000000 		.word	.LANCHOR15+168
 4156 010c 00000000 		.word	.LANCHOR60
 4157 0110 00000000 		.word	.LANCHOR15
 4158 0114 18000000 		.word	.LANCHOR15+24
 4159 0118 00000000 		.word	.LANCHOR56
 4160              		.cfi_endproc
 4161              	.LFE180:
 4163              		.section	.text._Z19processCalibrateESCv,"ax",%progbits
 4164              		.align	1
 4165              		.global	_Z19processCalibrateESCv
 4166              		.thumb
 4167              		.thumb_func
 4169              	_Z19processCalibrateESCv:
 4170              	.LFB181:
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processCalibrateESC
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Proces esc calibration command with the help of the configurator
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processCalibrateESC()
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 4171              		.loc 20 66 0
 4172              		.cfi_startproc
 4173              		@ args = 0, pretend = 0, frame = 0
 4174              		@ frame_needed = 0, uses_anonymous_args = 0
 4175 0000 10B5     		push	{r4, lr}
 4176              	.LCFI39:
 4177              		.cfi_def_cfa_offset 8
 4178              		.cfi_offset 4, -8
 4179              		.cfi_offset 14, -4
 4180              	.LBB268:
 4181              	.LBB269:
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 4182              		.loc 20 67 0
 4183 0002 1D4B     		ldr	r3, .L242
 4184 0004 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4185 0006 1D4B     		ldr	r3, .L242+4
 4186 0008 032A     		cmp	r2, #3
 4187 000a 0CD0     		beq	.L231
 4188 000c 052A     		cmp	r2, #5
 4189 000e 19D0     		beq	.L237
 4190 0010 012A     		cmp	r2, #1
 4191              	.LVL301:
 4192              	.LBB270:
 4193              	.LBB271:
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 1:
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = MAXCOMMAND;
 4194              		.loc 20 70 0
 4195 0012 0CBF     		ite	eq
 4196 0014 4FF4FA62 		moveq	r2, #2000
 4197              	.LVL302:
 4198              	.LBE271:
 4199              	.LBB272:
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 3:
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   case 5:
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     safetyCheck = ON;
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     break;
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   default:
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = MINCOMMAND;
 4200              		.loc 20 83 0
 4201 0018 4FF47A72 		movne	r2, #1000
 4202              	.LVL303:
 4203              	.L241:
 4204              		.loc 20 83 0 is_stmt 0 discriminator 1
 4205 001c 1A60     		str	r2, [r3, #0]
 4206              	.LVL304:
 4207 001e 5A60     		str	r2, [r3, #4]
 4208              	.LVL305:
 4209 0020 9A60     		str	r2, [r3, #8]
 4210              	.LVL306:
 4211 0022 DA60     		str	r2, [r3, #12]
 4212              	.LVL307:
 4213 0024 24E0     		b	.L233
 4214              	.LVL308:
 4215              	.L231:
 4216              	.LBE272:
 4217              	.LBB273:
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(testCommand, 1000, 1200);
 4218              		.loc 20 74 0 is_stmt 1
 4219 0026 164A     		ldr	r2, .L242+8
 4220 0028 1268     		ldr	r2, [r2, #0]
 4221 002a B2F5966F 		cmp	r2, #1200
 4222 002e B4BF     		ite	lt
 4223 0030 1146     		movlt	r1, r2
 4224 0032 4FF49661 		movge	r1, #1200
 4225 0036 B2F57A7F 		cmp	r2, #1000
 4226 003a ACBF     		ite	ge
 4227 003c 0A46     		movge	r2, r1
 4228 003e 4FF47A72 		movlt	r2, #1000
 4229 0042 EBE7     		b	.L241
 4230              	.L237:
 4231              	.LBE273:
 4232              	.LBB274:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 4233              		.loc 20 78 0
 4234 0044 0F48     		ldr	r0, .L242+12
 4235              	.LBE274:
 4236              	.LBE270:
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   switch (calibrateESC) { // used for calibrating ESC's
 4237              		.loc 20 67 0
 4238 0046 0022     		movs	r2, #0
 4239              	.LBB276:
 4240              	.LBB275:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 4241              		.loc 20 78 0
 4242 0048 40F2E734 		movw	r4, #999
 4243              	.L232:
 4244 004c 1158     		ldr	r1, [r2, r0]
 4245 004e A142     		cmp	r1, r4
 4246 0050 05DD     		ble	.L238
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 4247              		.loc 20 78 0 is_stmt 0 discriminator 1
 4248 0052 B1F5966F 		cmp	r1, #1200
 4249 0056 A8BF     		it	ge
 4250 0058 4FF49661 		movge	r1, #1200
 4251 005c 01E0     		b	.L236
 4252              	.L238:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 4253              		.loc 20 78 0
 4254 005e 4FF47A71 		mov	r1, #1000
 4255              	.L236:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] = constrain(motorConfiguratorCommand[motor], 1000, 1200);
 4256              		.loc 20 78 0 discriminator 3
 4257 0062 D150     		str	r1, [r2, r3]
 4258              	.LVL309:
 4259 0064 0432     		adds	r2, r2, #4
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++)
 4260              		.loc 20 77 0 is_stmt 1 discriminator 3
 4261 0066 102A     		cmp	r2, #16
 4262 0068 F0D1     		bne	.L232
 4263              	.LBE275:
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     safetyCheck = ON;
 4264              		.loc 20 79 0
 4265 006a 074B     		ldr	r3, .L242+16
 4266 006c 0122     		movs	r2, #1
 4267 006e 1A70     		strb	r2, [r3, #0]
 4268              	.L233:
 4269              	.LBE276:
 4270              	.LBE269:
 4271              	.LBE268:
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // Send calibration commands to motors
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 4272              		.loc 20 87 0
 4273 0070 BDE81040 		pop	{r4, lr}
 4274              	.LBB277:
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   writeMotors(); // Defined in Motors.h
 4275              		.loc 20 86 0
 4276 0074 FFF7FEBF 		b	_Z11writeMotorsv
 4277              	.LVL310:
 4278              	.L243:
 4279              		.align	2
 4280              	.L242:
 4281 0078 00000000 		.word	.LANCHOR61
 4282 007c 00000000 		.word	.LANCHOR54
 4283 0080 00000000 		.word	.LANCHOR62
 4284 0084 00000000 		.word	.LANCHOR63
 4285 0088 00000000 		.word	.LANCHOR64
 4286              	.LBE277:
 4287              		.cfi_endproc
 4288              	.LFE181:
 4290              		.section	.text._Z25processThrottleCorrectionv,"ax",%progbits
 4291              		.align	1
 4292              		.global	_Z25processThrottleCorrectionv
 4293              		.thumb
 4294              		.thumb_func
 4296              	_Z25processThrottleCorrectionv:
 4297              	.LFB182:
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processBatteryMonitorThrottleAdjustment
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Check battery alarm and if in alarm, increment a counter
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * When this counter reach BATTERY_MONITOR_MAX_ALARM_COUNT, then
  94:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * we are now in auto-descent mode.
  95:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
  96:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * When in auto-descent mode, the user can pass throttle keep when the
  97:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * alarm was reach, and the throttle is slowly decrease for a minute til
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * batteryMonitorThrottle that is configurable with the configurator
  99:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #if defined BattMonitor && defined BattMonitorAutoDescent
 101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   void processBatteryMonitorThrottleAdjustment() {
 102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (batteryMonitorAlarmCounter < BATTERY_MONITOR_MAX_ALARM_COUNT) {
 104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (batteryAlarm) {
 105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         batteryMonitorAlarmCounter++;
 106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     else {
 109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (altitudeHoldState == ON) {
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #if defined AltitudeHoldBaro
 112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             baroAltitudeToHoldTarget -= 0.01;
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #endif
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #if defined AltitudeHoldRangeFinder
 115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             if (sonarAltitudeToHoldTarget != INVALID_RANGE) {
 116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               sonarAltitudeToHoldTarget -= 0.01;
 117:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           #endif
 119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         else {
 121:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif
 122:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (batteryMonitorStartThrottle == 0) {  // init battery monitor throttle correction!
 123:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteryMonitorStartTime = millis();
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             if (throttle < batteryMonitorThrottleTarget) {
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               batteryMonitorStartThrottle = batteryMonitorThrottleTarget;
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             else {
 128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****               batteryMonitorStartThrottle = throttle; 
 129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             }
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           int batteryMonitorThrottle = map(millis()-batteryMonitorStartTime, 0, batteryMonitorGoing
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (batteryMonitorThrottle < batteryMonitorThrottleTarget) {
 133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteryMonitorThrottle = batteryMonitorThrottleTarget;
 134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           if (throttle < batteryMonitorThrottle) {
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = 0;
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           else {
 139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****             batteyMonitorThrottleCorrection = batteryMonitorThrottle - throttle;
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           }
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 143:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif
 144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #endif  
 147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #if defined AutoLanding
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #define BARO_AUTO_LANDING_DESCENT_SPEED 0.008
 151:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #define SONAR_AUTO_LANDING_DESCENT_SPEED 0.005
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   void processAutoLandingAltitudeCorrection() {
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (autoLandingState != OFF) {   
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (autoLandingState == BARO_AUTO_DESCENT_STATE) {
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (isOnRangerRange(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX])) { 
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           autoLandingState = SONAR_AUTO_DESCENT_STATE;
 159:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 160:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 161:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else if (autoLandingState == SONAR_AUTO_DESCENT_STATE) {
 162:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 163:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] < 0.5) {
 165:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           autoLandingState = MOTOR_AUTO_DESCENT_STATE;
 166:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 167:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 168:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else {
 169:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         autoLandingThrottleCorrection -= 1;
 170:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         baroAltitudeToHoldTarget -= BARO_AUTO_LANDING_DESCENT_SPEED;
 171:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         sonarAltitudeToHoldTarget -= SONAR_AUTO_LANDING_DESCENT_SPEED;
 172:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 173:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         if (((throttle + autoLandingThrottleCorrection) < 1000) || (rangeFinderRange[ALTITUDE_RANGE
 174:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           commandAllMotors(MINCOMMAND);
 175:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****           motorArmed = OFF;
 176:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         }
 177:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 178:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 179:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  }
 180:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** #endif
 181:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 182:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 183:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 184:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processThrottleCorrection
 185:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
 186:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * This function will add some throttle imput if the craft is angled
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * this prevent the craft to loose altitude when angled.
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * it also add the battery throttle correction in case
 189:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * of we are in auto-descent.
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * 
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Special thank to Ziojo for this.
 192:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 193:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processThrottleCorrection() {
 4298              		.loc 20 193 0
 4299              		.cfi_startproc
 4300              		@ args = 0, pretend = 0, frame = 0
 4301              		@ frame_needed = 0, uses_anonymous_args = 0
 4302              		@ link register save eliminated.
 4303              	.LVL311:
 4304              	.LBB278:
 194:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  
 195:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   int throttleAdjust = 0;
 196:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined UseGPSNavigator
 197:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (navigationState == ON || positionHoldState == ON) {
 198:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust = throttle / (cos (kinematicsAngle[XAXIS]*0.55) * cos (kinematicsAngle[YAXIS]*
 199:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust = constrain ((throttleAdjust - throttle), 0, 50); //compensate max  +/- 25 deg
 200:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 201:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 202:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined BattMonitorAutoDescent
 203:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     throttleAdjust += batteyMonitorThrottleCorrection;
 204:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 205:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #if defined (AutoLanding)
 206:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined BattMonitorAutoDescent
 207:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (batteyMonitorThrottleCorrection != 0) { // don't auto land in the same time that the batt
 208:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         throttleAdjust += autoLandingThrottleCorrection;
 209:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 210:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #else
 211:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttleAdjust += autoLandingThrottleCorrection;
 212:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 213:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   #endif
 214:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 215:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   throttle = constrain((throttle + throttleAdjust),MINCOMMAND,MAXCOMMAND-150);  // limmit throttle 
 4305              		.loc 20 215 0
 4306 0000 074A     		ldr	r2, .L247
 4307 0002 1368     		ldr	r3, [r2, #0]
 4308 0004 B3F57A7F 		cmp	r3, #1000
 4309 0008 05DB     		blt	.L246
 4310              		.loc 20 215 0 is_stmt 0 discriminator 1
 4311 000a 40F23A71 		movw	r1, #1850
 4312 000e 8B42     		cmp	r3, r1
 4313 0010 A8BF     		it	ge
 4314 0012 0B46     		movge	r3, r1
 4315 0014 01E0     		b	.L245
 4316              	.L246:
 4317              		.loc 20 215 0
 4318 0016 4FF47A73 		mov	r3, #1000
 4319              	.L245:
 4320              		.loc 20 215 0 discriminator 3
 4321 001a 1360     		str	r3, [r2, #0]
 4322 001c 7047     		bx	lr
 4323              	.L248:
 4324 001e 00BF     		.align	2
 4325              	.L247:
 4326 0020 00000000 		.word	.LANCHOR55
 4327              	.LBE278:
 4328              		.cfi_endproc
 4329              	.LFE182:
 4331              		.section	.text._Z20processHardManueversv,"ax",%progbits
 4332              		.align	1
 4333              		.global	_Z20processHardManueversv
 4334              		.thumb
 4335              		.thumb_func
 4337              	_Z20processHardManueversv:
 4338              	.LFB183:
 216:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 217:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 218:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 219:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 220:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processHardManuevers
 221:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 222:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * In case of a roll/pitch stick at one edge to do a loop, this function
 223:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * will prevent the lower throttle motor side to have too much low throtte.
 224:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 225:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processHardManuevers() {
 4339              		.loc 20 225 0 is_stmt 1
 4340              		.cfi_startproc
 4341              		@ args = 0, pretend = 0, frame = 0
 4342              		@ frame_needed = 0, uses_anonymous_args = 0
 4343              		@ link register save eliminated.
 4344              	.LBB279:
 226:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 4345              		.loc 20 227 0
 4346 0000 0F4B     		ldr	r3, .L253
 4347 0002 1A68     		ldr	r2, [r3, #0]
 4348 0004 A2F24C42 		subw	r2, r2, #1100
 4349 0008 B2F5487F 		cmp	r2, #800
 4350 000c 04D8     		bhi	.L250
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[XAXIS] > MAXCHECK) ||
 229:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[YAXIS] < MINCHECK) ||
 4351              		.loc 20 229 0 discriminator 1
 4352 000e 5B68     		ldr	r3, [r3, #4]
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 4353              		.loc 20 227 0 discriminator 1
 4354 0010 40F24B42 		movw	r2, #1099
 4355 0014 9342     		cmp	r3, r2
 4356 0016 0EDC     		bgt	.L251
 4357              	.L250:
 4358              	.LBB280:
 230:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       (receiverCommand[YAXIS] > MAXCHECK)) {  
 231:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         
 232:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (int motor = 0; motor < LASTMOTOR; motor++) {
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4359              		.loc 20 233 0 discriminator 2
 4360 0018 0A4B     		ldr	r3, .L253+4
 4361 001a 0B49     		ldr	r1, .L253+8
 4362 001c 1868     		ldr	r0, [r3, #0]
 234:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMaxCommand[motor] = MAXCOMMAND;
 4363              		.loc 20 234 0 discriminator 2
 4364 001e 0B4B     		ldr	r3, .L253+12
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4365              		.loc 20 233 0 discriminator 2
 4366 0020 0860     		str	r0, [r1, #0]
 4367              		.loc 20 234 0 discriminator 2
 4368 0022 4FF4FA62 		mov	r2, #2000
 4369 0026 1A60     		str	r2, [r3, #0]
 4370              	.LVL312:
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4371              		.loc 20 233 0 discriminator 2
 4372 0028 4860     		str	r0, [r1, #4]
 4373              		.loc 20 234 0 discriminator 2
 4374 002a 5A60     		str	r2, [r3, #4]
 4375              	.LVL313:
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4376              		.loc 20 233 0 discriminator 2
 4377 002c 8860     		str	r0, [r1, #8]
 4378              		.loc 20 234 0 discriminator 2
 4379 002e 9A60     		str	r2, [r3, #8]
 4380              	.LVL314:
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4381              		.loc 20 233 0 discriminator 2
 4382 0030 C860     		str	r0, [r1, #12]
 4383              		.loc 20 234 0 discriminator 2
 4384 0032 DA60     		str	r2, [r3, #12]
 4385              	.LVL315:
 4386 0034 7047     		bx	lr
 4387              	.LVL316:
 4388              	.L251:
 4389              	.LBE280:
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if ((receiverCommand[XAXIS] < MINCHECK) ||
 4390              		.loc 20 227 0 discriminator 2
 4391 0036 40F26C72 		movw	r2, #1900
 4392 003a 9342     		cmp	r3, r2
 4393 003c ECDC     		bgt	.L250
 4394 003e 7047     		bx	lr
 4395              	.L254:
 4396              		.align	2
 4397              	.L253:
 4398 0040 00000000 		.word	.LANCHOR4
 4399 0044 00000000 		.word	.LANCHOR65
 4400 0048 00000000 		.word	.LANCHOR66
 4401 004c 00000000 		.word	.LANCHOR67
 4402              	.LBE279:
 4403              		.cfi_endproc
 4404              	.LFE183:
 4406              		.section	.text._Z20processMinMaxCommandv,"ax",%progbits
 4407              		.align	1
 4408              		.global	_Z20processMinMaxCommandv
 4409              		.thumb
 4410              		.thumb_func
 4412              	_Z20processMinMaxCommandv:
 4413              	.LFB184:
 235:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 236:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 237:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 238:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 239:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 240:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processMinMaxCommand
 241:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 242:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * This function correct too low/max throttle when manuevering
 243:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * preventing some wobbling behavior
 244:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 245:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processMinMaxCommand()
 246:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 4414              		.loc 20 246 0
 4415              		.cfi_startproc
 4416              		@ args = 0, pretend = 0, frame = 0
 4417              		@ frame_needed = 0, uses_anonymous_args = 0
 4418              	.LVL317:
 4419              	.LBB281:
 4420              	.LBB282:
 247:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++)
 248:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   {
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 4421              		.loc 20 249 0
 4422 0000 144B     		ldr	r3, .L259
 4423 0002 1549     		ldr	r1, .L259+4
 4424 0004 1868     		ldr	r0, [r3, #0]
 250:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMaxCommand[motor] = MAXCOMMAND;
 4425              		.loc 20 250 0
 4426 0006 154B     		ldr	r3, .L259+8
 4427 0008 4FF4FA62 		mov	r2, #2000
 4428              	.LBE282:
 4429              	.LBE281:
 246:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** {
 4430              		.loc 20 246 0
 4431 000c 10B5     		push	{r4, lr}
 4432              	.LCFI40:
 4433              		.cfi_def_cfa_offset 8
 4434              		.cfi_offset 4, -8
 4435              		.cfi_offset 14, -4
 4436              	.LBB290:
 4437              	.LBB283:
 4438              		.loc 20 250 0
 4439 000e 1A60     		str	r2, [r3, #0]
 4440              	.LVL318:
 4441 0010 5A60     		str	r2, [r3, #4]
 4442              	.LVL319:
 4443 0012 9A60     		str	r2, [r3, #8]
 4444              	.LVL320:
 4445 0014 DA60     		str	r2, [r3, #12]
 4446              	.LVL321:
 4447              	.LBE283:
 251:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 252:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 253:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   int maxMotor = motorCommand[0];
 4448              		.loc 20 253 0
 4449 0016 124A     		ldr	r2, .L259+12
 4450              	.LBB284:
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 4451              		.loc 20 249 0
 4452 0018 0860     		str	r0, [r1, #0]
 4453              	.LBE284:
 4454              		.loc 20 253 0
 4455 001a 1368     		ldr	r3, [r2, #0]
 4456              	.LVL322:
 4457              	.LBB285:
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorMinCommand[motor] = minArmedThrottle;
 4458              		.loc 20 249 0
 4459 001c 4860     		str	r0, [r1, #4]
 4460 001e 8860     		str	r0, [r1, #8]
 4461 0020 C860     		str	r0, [r1, #12]
 4462              	.LBE285:
 4463              	.LBB286:
 254:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor=1; motor < LASTMOTOR; motor++) {
 256:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (motorCommand[motor] > maxMotor) {
 4464              		.loc 20 256 0
 4465 0022 5168     		ldr	r1, [r2, #4]
 4466 0024 9942     		cmp	r1, r3
 4467 0026 B8BF     		it	lt
 4468 0028 1946     		movlt	r1, r3
 4469              	.LVL323:
 4470 002a 9368     		ldr	r3, [r2, #8]
 4471 002c 9942     		cmp	r1, r3
 4472 002e B8BF     		it	lt
 4473 0030 1946     		movlt	r1, r3
 4474              	.LVL324:
 4475 0032 D368     		ldr	r3, [r2, #12]
 4476 0034 9942     		cmp	r1, r3
 4477 0036 B8BF     		it	lt
 4478 0038 1946     		movlt	r1, r3
 4479              	.LVL325:
 4480              	.LBE286:
 4481              	.LBB287:
 257:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       maxMotor = motorCommand[motor];
 258:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 259:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 260:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 261:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (maxMotor > MAXCOMMAND) {
 263:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorCommand[motor] =  motorCommand[motor] - (maxMotor - MAXCOMMAND);
 4482              		.loc 20 263 0
 4483 003a C1F5FA64 		rsb	r4, r1, #2000
 4484              	.LBE287:
 4485              	.LBB288:
 256:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (motorCommand[motor] > maxMotor) {
 4486              		.loc 20 256 0
 4487 003e 0023     		movs	r3, #0
 4488              	.LVL326:
 4489              	.L257:
 4490              	.LBE288:
 4491              	.LBB289:
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     if (maxMotor > MAXCOMMAND) {
 4492              		.loc 20 262 0
 4493 0040 B1F5FA6F 		cmp	r1, #2000
 4494 0044 02DD     		ble	.L256
 4495              		.loc 20 263 0
 4496 0046 9858     		ldr	r0, [r3, r2]
 4497 0048 0019     		adds	r0, r0, r4
 4498 004a 9850     		str	r0, [r3, r2]
 4499              	.L256:
 4500 004c 0433     		adds	r3, r3, #4
 261:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 4501              		.loc 20 261 0
 4502 004e 102B     		cmp	r3, #16
 4503 0050 F6D1     		bne	.L257
 4504              	.LBE289:
 4505              	.LBE290:
 264:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 265:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 4506              		.loc 20 266 0
 4507 0052 10BD     		pop	{r4, pc}
 4508              	.L260:
 4509              		.align	2
 4510              	.L259:
 4511 0054 00000000 		.word	.LANCHOR65
 4512 0058 00000000 		.word	.LANCHOR66
 4513 005c 00000000 		.word	.LANCHOR67
 4514 0060 00000000 		.word	.LANCHOR54
 4515              		.cfi_endproc
 4516              	.LFE184:
 4518              		.section	.text._Z14processHeadingv,"ax",%progbits
 4519              		.align	1
 4520              		.global	_Z14processHeadingv
 4521              		.thumb
 4522              		.thumb_func
 4524              	_Z14processHeadingv:
 4525              	.LFB188:
 4526              		.file 21 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/HeadingHoldProcessor.h"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   This program is free software: you can redistribute it and/or modify 
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   it under the terms of the GNU General Public License as published by 
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   the Free Software Foundation, either version 3 of the License, or 
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   (at your option) any later version. 
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   This program is distributed in the hope that it will be useful, 
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   GNU General Public License for more details. 
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   You should have received a copy of the GNU General Public License 
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** #ifndef _AQ_HEADING_CONTROL_PROCESSOR_H_
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** #define _AQ_HEADING_CONTROL_PROCESSOR_H_
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** float setHeading          = 0;
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** unsigned long headingTime = micros();
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** /**
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * processHeading
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  *
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * This function will calculate the craft heading correction depending 
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * of the users command. Heading correction is process with the gyro
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  * or a magnetometer
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****  */
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** void processHeading()
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** {
 4527              		.loc 21 38 0
 4528              		.cfi_startproc
 4529              		@ args = 0, pretend = 0, frame = 0
 4530              		@ frame_needed = 0, uses_anonymous_args = 0
 4531 0000 10B5     		push	{r4, lr}
 4532              	.LCFI41:
 4533              		.cfi_def_cfa_offset 8
 4534              		.cfi_offset 4, -8
 4535              		.cfi_offset 14, -4
 4536              	.LBB291:
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   if (headingHoldConfig == ON) {
 4537              		.loc 21 39 0
 4538 0002 614B     		ldr	r3, .L284
 4539 0004 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4540 0006 012B     		cmp	r3, #1
 4541 0008 40F08780 		bne	.L263
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #if defined(HeadingMagHold)
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(trueNorthHeading);
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #else
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 4542              		.loc 21 44 0
 4543 000c 5F4B     		ldr	r3, .L284+4
 4544 000e DFED607A 		flds	s15, .L284+8
 4545 0012 93ED007A 		flds	s14, [r3, #0]
 4546 0016 5F4B     		ldr	r3, .L284+12
 4547 0018 67EE277A 		fmuls	s15, s14, s15
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     #endif
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Always center relative heading around absolute heading chosen during yaw command
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // This assumes that an incorrect yaw can't be forced on the AeroQuad >180 or <-180 degrees
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // This is done so that AeroQuad does not accidentally hit transition between 0 and 360 or -180
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // AKA - THERE IS A BUG HERE - if relative heading is greater than 180 degrees, the PID will sw
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Doubt that will happen as it would have to be uncommanded.
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (heading <= (setHeading - 180)) {
 4548              		.loc 21 53 0
 4549 001c 9FED5E6A 		flds	s12, .L284+16
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       heading = degrees(gyroHeading);
 4550              		.loc 21 44 0
 4551 0020 C3ED007A 		fsts	s15, [r3, #0]
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 4552              		.loc 21 52 0
 4553 0024 5D4B     		ldr	r3, .L284+20
 4554 0026 93ED007A 		flds	s14, [r3, #0]
 4555              		.loc 21 53 0
 4556 002a 77EE465A 		fsubs	s11, s14, s12
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     relativeHeading = heading - setHeading;
 4557              		.loc 21 52 0
 4558 002e 77EEC76A 		fsubs	s13, s15, s14
 4559              		.loc 21 53 0
 4560 0032 F4EEE57A 		fcmpes	s15, s11
 4561 0036 F1EE10FA 		fmstat
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading += 360;
 4562              		.loc 21 54 0
 4563 003a 98BF     		it	ls
 4564 003c DFED585A 		fldsls	s11, .L284+24
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (heading >= (setHeading + 180)) {
 4565              		.loc 21 56 0
 4566 0040 37EE067A 		fadds	s14, s14, s12
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading += 360;
 4567              		.loc 21 54 0
 4568 0044 98BF     		it	ls
 4569 0046 76EEA56A 		faddsls	s13, s13, s11
 4570 004a 564B     		ldr	r3, .L284+28
 4571              		.loc 21 56 0
 4572 004c F4EEC77A 		fcmpes	s15, s14
 4573 0050 F1EE10FA 		fmstat
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading += 360;
 4574              		.loc 21 54 0
 4575 0054 C3ED006A 		fsts	s13, [r3, #0]
 4576              		.loc 21 56 0
 4577 0058 08DB     		blt	.L266
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       relativeHeading -= 360;
 4578              		.loc 21 57 0
 4579 005a 524B     		ldr	r3, .L284+28
 4580 005c 9FED507A 		flds	s14, .L284+24
 4581 0060 D3ED006A 		flds	s13, [r3, #0]
 4582 0064 36EEC77A 		fsubs	s14, s13, s14
 4583 0068 83ED007A 		fsts	s14, [r3, #0]
 4584              	.L266:
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** 
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     // Apply heading hold only when throttle high enough to start flight
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     if (receiverCommand[THROTTLE] > MINCHECK ) { 
 4585              		.loc 21 61 0
 4586 006c 4E4A     		ldr	r2, .L284+32
 4587 006e D368     		ldr	r3, [r2, #12]
 4588 0070 40F24C41 		movw	r1, #1100
 4589 0074 8B42     		cmp	r3, r1
 4590 0076 4D4B     		ldr	r3, .L284+36
 4591 0078 47DD     		ble	.L268
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #if defined (UseGPSNavigator)
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if (( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) > (MIDCOMMAND + 25)) || 
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             ( (receiverCommand[ZAXIS] + gpsYawAxisCorrection) < (MIDCOMMAND - 25))) {
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #else
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if ((receiverCommand[ZAXIS] > (MIDCOMMAND + 25)) || 
 4592              		.loc 21 67 0
 4593 007a 9268     		ldr	r2, [r2, #8]
 4594 007c A2F2C352 		subw	r2, r2, #1475
 4595 0080 322A     		cmp	r2, #50
 4596 0082 0FD9     		bls	.L269
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             (receiverCommand[ZAXIS] < (MIDCOMMAND - 25))) {
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       #endif
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // If commanding yaw, turn off heading hold and store latest heading
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         setHeading = heading;
 4597              		.loc 21 73 0
 4598 0084 454A     		ldr	r2, .L284+20
 4599 0086 C2ED007A 		fsts	s15, [r2, #0]
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHold = 0;
 4600              		.loc 21 74 0
 4601 008a 0022     		movs	r2, #0
 4602 008c 1A60     		str	r2, [r3, #0]	@ float
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 4603              		.loc 21 75 0
 4604 008e 484B     		ldr	r3, .L284+40
 4605 0090 C3F88C20 		str	r2, [r3, #140]	@ float
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingHoldState = OFF;
 4606              		.loc 21 76 0
 4607 0094 474B     		ldr	r3, .L284+44
 4608 0096 0022     		movs	r2, #0
 4609 0098 1A70     		strb	r2, [r3, #0]
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         headingTime = currentTime;
 4610              		.loc 21 77 0
 4611 009a 474B     		ldr	r3, .L284+48
 4612 009c 1A68     		ldr	r2, [r3, #0]
 4613 009e 474B     		ldr	r3, .L284+52
 4614 00a0 1A60     		str	r2, [r3, #0]
 4615 00a2 3AE0     		b	.L263
 4616              	.L269:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       }
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       else {
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         if (relativeHeading < 0.25 && relativeHeading > -0.25) {
 4617              		.loc 21 80 0
 4618 00a4 3F4A     		ldr	r2, .L284+28
 4619 00a6 92ED007A 		flds	s14, [r2, #0]
 4620 00aa F5EE006A 		fconsts	s13, #80
 4621 00ae B4EEE67A 		fcmpes	s14, s13
 4622 00b2 F1EE10FA 		fmstat
 4623 00b6 07D5     		bpl	.L270
 4624              		.loc 21 80 0 is_stmt 0 discriminator 1
 4625 00b8 FDEE006A 		fconsts	s13, #208
 4626 00bc B4EEE67A 		fcmpes	s14, s13
 4627 00c0 F1EE10FA 		fmstat
 4628 00c4 00DD     		ble	.L270
 4629 00c6 23E0     		b	.L283
 4630              	.L270:
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = 0;
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           PID[HEADING_HOLD_PID_IDX].integratedError = 0;
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         else if (headingHoldState == OFF) { // quick fix to soften heading hold on new heading
 4631              		.loc 21 84 0 is_stmt 1
 4632 00c8 3A4A     		ldr	r2, .L284+44
 4633 00ca 3C4C     		ldr	r4, .L284+52
 4634 00cc 1378     		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 4635 00ce 83B9     		cbnz	r3, .L273
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           if ((currentTime - headingTime) > 500000) {
 4636              		.loc 21 85 0
 4637 00d0 394B     		ldr	r3, .L284+48
 4638 00d2 2168     		ldr	r1, [r4, #0]
 4639 00d4 1B68     		ldr	r3, [r3, #0]
 4640 00d6 3A48     		ldr	r0, .L284+56
 4641 00d8 591A     		subs	r1, r3, r1
 4642 00da 8142     		cmp	r1, r0
 4643 00dc 1DD9     		bls	.L263
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingTime = currentTime;
 4644              		.loc 21 87 0
 4645 00de 2360     		str	r3, [r4, #0]
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             setHeading = heading;
 4646              		.loc 21 88 0
 4647 00e0 2E4B     		ldr	r3, .L284+20
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
 4648              		.loc 21 86 0
 4649 00e2 0121     		movs	r1, #1
 4650              		.loc 21 88 0
 4651 00e4 C3ED007A 		fsts	s15, [r3, #0]
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHold = 0;
 4652              		.loc 21 89 0
 4653 00e8 304B     		ldr	r3, .L284+36
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****             headingHoldState = ON;
 4654              		.loc 21 86 0
 4655 00ea 1170     		strb	r1, [r2, #0]
 4656              		.loc 21 89 0
 4657 00ec 0022     		movs	r2, #0
 4658 00ee 1A60     		str	r2, [r3, #0]	@ float
 4659 00f0 13E0     		b	.L263
 4660              	.L273:
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           }
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         else {
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // No new yaw input, calculate current heading vs. desired heading heading hold
  94:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         // Relative heading is always centered around zero
  95:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingHold = updatePID(0, relativeHeading, &PID[HEADING_HOLD_PID_IDX]);
 4661              		.loc 21 95 0
 4662 00f2 0020     		movs	r0, #0
 4663 00f4 17EE101A 		fmrs	r1, s14
 4664 00f8 324A     		ldr	r2, .L284+60
 4665 00fa FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4666              	.LVL327:
 4667 00fe 2B4B     		ldr	r3, .L284+36
 4668 0100 1860     		str	r0, [r3, #0]	@ float
  96:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****           headingTime = currentTime; // quick fix to soften heading hold, wait 100ms before applyin
 4669              		.loc 21 96 0
 4670 0102 2D4B     		ldr	r3, .L284+48
 4671 0104 1B68     		ldr	r3, [r3, #0]
 4672 0106 2360     		str	r3, [r4, #0]
 4673 0108 07E0     		b	.L263
 4674              	.L268:
  97:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****         }
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       }
  99:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
 100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     else {
 101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       // minimum throttle not reached, use off settings
 102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       setHeading = heading;
 4675              		.loc 21 102 0
 4676 010a 244A     		ldr	r2, .L284+20
 4677 010c C2ED007A 		fsts	s15, [r2, #0]
 4678              	.L283:
 103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       headingHold = 0;
 4679              		.loc 21 103 0
 4680 0110 0022     		movs	r2, #0
 4681 0112 1A60     		str	r2, [r3, #0]	@ float
 104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****       PID[HEADING_HOLD_PID_IDX].integratedError = 0;
 4682              		.loc 21 104 0
 4683 0114 264B     		ldr	r3, .L284+40
 4684 0116 C3F88C20 		str	r2, [r3, #140]	@ float
 4685              	.L263:
 4686              	.LVL328:
 105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     }
 106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   }
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   // NEW SI Version
 108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #if defined (UseGPSNavigator) 
 109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS] + gpsYawAxisCorrection) * 
 110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #else
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 4687              		.loc 21 111 0
 4688 011a 234B     		ldr	r3, .L284+32
 4689 011c 9A68     		ldr	r2, [r3, #8]
 4690 011e 2A4B     		ldr	r3, .L284+64
 4691 0120 9B68     		ldr	r3, [r3, #8]
 4692 0122 D31A     		subs	r3, r2, r3
 4693 0124 07EE103A 		fmsr	s14, r3	@ int
 112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   #endif
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   const float commandedYaw = constrain(receiverSiData + radians(headingHold), -PI, PI);
 4694              		.loc 21 114 0
 4695 0128 204B     		ldr	r3, .L284+36
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****     float receiverSiData = (receiverCommand[ZAXIS] - receiverZero[ZAXIS]) * (2.5 * PWM2RAD);
 4696              		.loc 21 111 0
 4697 012a F8EEC76A 		fsitos	s13, s14
 4698              		.loc 21 114 0
 4699 012e DFED277A 		flds	s15, .L284+68
 4700 0132 93ED007A 		flds	s14, [r3, #0]
 4701 0136 67EE277A 		fmuls	s15, s14, s15
 4702 013a 9FED257A 		flds	s14, .L284+72
 4703 013e 46EE877A 		fmacs	s15, s13, s14
 4704 0142 9FED247A 		flds	s14, .L284+76
 4705 0146 F4EEC77A 		fcmpes	s15, s14
 4706 014a F1EE10FA 		fmstat
 4707 014e 09D4     		bmi	.L277
 4708              		.loc 21 114 0 is_stmt 0 discriminator 2
 4709 0150 9FED217A 		flds	s14, .L284+80
 4710 0154 F4EE477A 		fcmps	s15, s14
 4711 0158 F1EE10FA 		fmstat
 4712 015c C8BF     		it	gt
 4713 015e F0EE477A 		fcpysgt	s15, s14
 4714 0162 01E0     		b	.L275
 4715              	.L277:
 4716              		.loc 21 114 0
 4717 0164 F0EE477A 		fcpys	s15, s14
 4718              	.L275:
 4719              	.LVL329:
 115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h ****   motorAxisCommandYaw = updatePID(commandedYaw, gyroRate[ZAXIS], &PID[ZAXIS_PID_IDX]);
 4720              		.loc 21 115 0 is_stmt 1 discriminator 6
 4721 0168 1C4B     		ldr	r3, .L284+84
 4722 016a 1D4A     		ldr	r2, .L284+88
 4723 016c 9968     		ldr	r1, [r3, #8]	@ float
 4724 016e 17EE900A 		fmrs	r0, s15
 4725 0172 FFF7FEFF 		bl	_Z9updatePIDffP7PIDdata
 4726              	.LVL330:
 4727 0176 07EE100A 		fmsr	s14, r0
 4728 017a 1A4B     		ldr	r3, .L284+92
 4729 017c FDEEC77A 		ftosizs	s15, s14
 4730 0180 C3ED007A 		fsts	s15, [r3, #0]	@ int
 4731 0184 10BD     		pop	{r4, pc}
 4732              	.L285:
 4733 0186 00BF     		.align	2
 4734              	.L284:
 4735 0188 00000000 		.word	.LANCHOR68
 4736 018c 00000000 		.word	.LANCHOR22
 4737 0190 E12E6542 		.word	1113927393
 4738 0194 00000000 		.word	.LANCHOR69
 4739 0198 00003443 		.word	1127481344
 4740 019c 00000000 		.word	.LANCHOR70
 4741 01a0 0000B443 		.word	1135869952
 4742 01a4 00000000 		.word	.LANCHOR71
 4743 01a8 00000000 		.word	.LANCHOR4
 4744 01ac 00000000 		.word	.LANCHOR72
 4745 01b0 00000000 		.word	.LANCHOR15
 4746 01b4 00000000 		.word	.LANCHOR73
 4747 01b8 00000000 		.word	.LANCHOR13
 4748 01bc 00000000 		.word	.LANCHOR74
 4749 01c0 20A10700 		.word	500000
 4750 01c4 78000000 		.word	.LANCHOR15+120
 4751 01c8 00000000 		.word	.LANCHOR6
 4752 01cc 35FA8E3C 		.word	1016003125
 4753 01d0 0BD7A33B 		.word	1000593163
 4754 01d4 DB0F49C0 		.word	-1068953637
 4755 01d8 DB0F4940 		.word	1078530011
 4756 01dc 00000000 		.word	.LANCHOR21
 4757 01e0 30000000 		.word	.LANCHOR15+48
 4758 01e4 00000000 		.word	.LANCHOR58
 4759              	.LBE291:
 4760              		.cfi_endproc
 4761              	.LFE188:
 4763              		.section	.text._Z20processFlightControlv,"ax",%progbits
 4764              		.align	1
 4765              		.global	_Z20processFlightControlv
 4766              		.thumb
 4767              		.thumb_func
 4769              	_Z20processFlightControlv:
 4770              	.LFB185:
 267:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 268:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** /**
 269:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * processFlightControl
 270:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  *
 271:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  * Main flight control processos function
 272:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****  */
 273:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** void processFlightControl() {
 4771              		.loc 20 273 0
 4772              		.cfi_startproc
 4773              		@ args = 0, pretend = 0, frame = 0
 4774              		@ frame_needed = 0, uses_anonymous_args = 0
 4775 0000 70B5     		push	{r4, r5, r6, lr}
 4776              	.LCFI42:
 4777              		.cfi_def_cfa_offset 16
 4778              		.cfi_offset 4, -16
 4779              		.cfi_offset 5, -12
 4780              		.cfi_offset 6, -8
 4781              		.cfi_offset 14, -4
 4782              	.LBB292:
 274:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 275:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Calculate Flight Error ***************************
 276:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   calculateFlightError();
 4783              		.loc 20 276 0
 4784 0002 FFF7FEFF 		bl	_Z20calculateFlightErrorv
 4785              	.LVL331:
 277:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 278:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Update Yaw ***************************************
 279:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   processHeading();
 4786              		.loc 20 279 0
 4787 0006 FFF7FEFF 		bl	_Z14processHeadingv
 4788              	.LVL332:
 280:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 281:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  // 50hz task
 4789              		.loc 20 281 0
 4790 000a 294B     		ldr	r3, .L309
 4791 000c 1B68     		ldr	r3, [r3, #0]
 4792 000e DA07     		lsls	r2, r3, #31
 4793 0010 05D4     		bmi	.L287
 282:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 283:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process position hold or navigation **************************
 284:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined (UseGPS)
 285:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #if defined (UseGPSNavigator)
 286:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         processGpsNavigation();
 287:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       #endif  
 288:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 289:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 290:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Altitude hold **************************
 291:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 292:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processAltitudeHold();
 293:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #else
 294:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       throttle = receiverCommand[THROTTLE];
 4794              		.loc 20 294 0
 4795 0012 284B     		ldr	r3, .L309+4
 4796 0014 DA68     		ldr	r2, [r3, #12]
 4797 0016 284B     		ldr	r3, .L309+8
 4798 0018 1A60     		str	r2, [r3, #0]
 295:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 296:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 297:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Battery monitor hold **************************
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined BattMonitor && defined BattMonitorAutoDescent
 299:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processBatteryMonitorThrottleAdjustment();
 300:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 301:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 302:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process Auto-Descent  **************************
 303:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #if defined AutoLanding
 304:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       processAutoLandingAltitudeCorrection();
 305:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     #endif
 306:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     
 307:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     // ********************** Process throttle correction ********************
 308:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     processThrottleCorrection();
 4799              		.loc 20 308 0
 4800 001a FFF7FEFF 		bl	_Z25processThrottleCorrectionv
 4801              	.LVL333:
 4802              	.L287:
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 310:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 311:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ********************** Calculate Motor Commands *************************
 312:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed && safetyCheck) {
 4803              		.loc 20 312 0
 4804 001e 274B     		ldr	r3, .L309+12
 4805 0020 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4806 0022 23B1     		cbz	r3, .L288
 4807              		.loc 20 312 0 is_stmt 0 discriminator 1
 4808 0024 264B     		ldr	r3, .L309+16
 4809 0026 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4810 0028 0BB1     		cbz	r3, .L288
 313:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     applyMotorCommand();
 4811              		.loc 20 313 0 is_stmt 1
 4812 002a FFF7FEFF 		bl	_Z17applyMotorCommandv
 4813              	.LVL334:
 4814              	.L288:
 314:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   } 
 315:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 316:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // *********************** process min max motor command *******************
 317:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   processMinMaxCommand();
 4815              		.loc 20 317 0
 4816 002e FFF7FEFF 		bl	_Z20processMinMaxCommandv
 4817              	.LVL335:
 4818              	.LBB293:
 318:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 319:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // If throttle in minimum position, don't apply yaw
 320:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 4819              		.loc 20 320 0
 4820 0032 204B     		ldr	r3, .L309+4
 4821 0034 DA68     		ldr	r2, [r3, #12]
 4822 0036 40F24B43 		movw	r3, #1099
 4823 003a 9A42     		cmp	r2, r3
 4824 003c 05DD     		ble	.L289
 4825              	.L294:
 4826              	.LVL336:
 4827              	.LBE293:
 4828              	.LBB295:
 321:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 324:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 325:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 326:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       else {
 327:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = minArmedThrottle;
 328:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       }
 329:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     }
 330:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 331:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 332:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // Apply limits to motor commands
 333:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 334:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     motorCommand[motor] = constrain(motorCommand[motor], motorMinCommand[motor], motorMaxCommand[mo
 4829              		.loc 20 334 0
 4830 003e 2149     		ldr	r1, .L309+20
 4831 0040 214D     		ldr	r5, .L309+24
 4832 0042 224E     		ldr	r6, .L309+28
 4833              	.LBE295:
 4834              	.LBB296:
 4835              	.LBB294:
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 4836              		.loc 20 323 0
 4837 0044 0023     		movs	r3, #0
 4838 0046 0C46     		mov	r4, r1
 4839 0048 14E0     		b	.L290
 4840              	.LVL337:
 4841              	.L289:
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4842              		.loc 20 322 0
 4843 004a 214B     		ldr	r3, .L309+32
 4844 004c 1E4D     		ldr	r5, .L309+24
 4845 004e 1A68     		ldr	r2, [r3, #0]
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 4846              		.loc 20 323 0
 4847 0050 204B     		ldr	r3, .L309+36
 4848 0052 1E49     		ldr	r1, .L309+28
 4849 0054 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 4850 0056 204B     		ldr	r3, .L309+40
 324:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 4851              		.loc 20 324 0
 4852 0058 4FF4FA66 		mov	r6, #2000
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 4853              		.loc 20 323 0
 4854 005c 1C78     		ldrb	r4, [r3, #0]	@ zero_extendqisi2
 4855 005e 0023     		movs	r3, #0
 4856              	.L293:
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       motorMinCommand[motor] = minArmedThrottle;
 4857              		.loc 20 322 0
 4858 0060 5A51     		str	r2, [r3, r5]
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 4859              		.loc 20 323 0
 4860 0062 10B1     		cbz	r0, .L291
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****       if (inFlight && flightMode == RATE_FLIGHT_MODE) {
 4861              		.loc 20 323 0 is_stmt 0 discriminator 1
 4862 0064 0CB9     		cbnz	r4, .L291
 324:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = MAXCOMMAND;
 4863              		.loc 20 324 0 is_stmt 1
 4864 0066 CE50     		str	r6, [r1, r3]
 4865 0068 00E0     		b	.L292
 4866              	.L291:
 327:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****         motorMaxCommand[motor] = minArmedThrottle;
 4867              		.loc 20 327 0
 4868 006a CA50     		str	r2, [r1, r3]
 4869              	.L292:
 4870              	.LVL338:
 4871 006c 0433     		adds	r3, r3, #4
 321:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 4872              		.loc 20 321 0
 4873 006e 102B     		cmp	r3, #16
 4874 0070 F6D1     		bne	.L293
 4875 0072 E4E7     		b	.L294
 4876              	.L290:
 4877              	.LBE294:
 4878              	.LBE296:
 4879              	.LBB297:
 4880              		.loc 20 334 0
 4881 0074 5858     		ldr	r0, [r3, r1]
 4882 0076 5A59     		ldr	r2, [r3, r5]
 4883 0078 9042     		cmp	r0, r2
 4884 007a 03DB     		blt	.L295
 4885              		.loc 20 334 0 is_stmt 0 discriminator 2
 4886 007c 9A59     		ldr	r2, [r3, r6]
 4887 007e 8242     		cmp	r2, r0
 4888 0080 A8BF     		it	ge
 4889 0082 0246     		movge	r2, r0
 4890              	.L295:
 4891              		.loc 20 334 0 discriminator 6
 4892 0084 E250     		str	r2, [r4, r3]
 4893 0086 0433     		adds	r3, r3, #4
 333:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   for (byte motor = 0; motor < LASTMOTOR; motor++) {
 4894              		.loc 20 333 0 is_stmt 1 discriminator 6
 4895 0088 102B     		cmp	r3, #16
 4896 008a F3D1     		bne	.L290
 4897              	.LBE297:
 335:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 337:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** 
 338:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // ESC Calibration
 339:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed == OFF) {
 4898              		.loc 20 339 0
 4899 008c 0B4B     		ldr	r3, .L309+12
 4900 008e 1A78     		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 4901 0090 1C46     		mov	r4, r3
 4902 0092 0AB9     		cbnz	r2, .L296
 340:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     processCalibrateESC();
 4903              		.loc 20 340 0
 4904 0094 FFF7FEFF 		bl	_Z19processCalibrateESCv
 4905              	.LVL339:
 4906              	.L296:
 341:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 342:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   
 343:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   // *********************** Command Motors **********************
 344:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   if (motorArmed == ON && safetyCheck == ON) {
 4907              		.loc 20 344 0
 4908 0098 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 4909 009a 012B     		cmp	r3, #1
 4910 009c 07D1     		bne	.L286
 4911              		.loc 20 344 0 is_stmt 0 discriminator 1
 4912 009e 084B     		ldr	r3, .L309+16
 4913 00a0 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 4914 00a2 012B     		cmp	r3, #1
 4915 00a4 03D1     		bne	.L286
 4916              	.LBE292:
 345:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     writeMotors();
 346:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****   }
 347:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h **** }
 4917              		.loc 20 347 0 is_stmt 1
 4918 00a6 BDE87040 		pop	{r4, r5, r6, lr}
 4919              	.LBB298:
 345:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightControlProcessor.h ****     writeMotors();
 4920              		.loc 20 345 0
 4921 00aa FFF7FEBF 		b	_Z11writeMotorsv
 4922              	.LVL340:
 4923              	.L286:
 4924 00ae 70BD     		pop	{r4, r5, r6, pc}
 4925              	.L310:
 4926              		.align	2
 4927              	.L309:
 4928 00b0 00000000 		.word	.LANCHOR75
 4929 00b4 00000000 		.word	.LANCHOR4
 4930 00b8 00000000 		.word	.LANCHOR55
 4931 00bc 00000000 		.word	.LANCHOR76
 4932 00c0 00000000 		.word	.LANCHOR64
 4933 00c4 00000000 		.word	.LANCHOR54
 4934 00c8 00000000 		.word	.LANCHOR66
 4935 00cc 00000000 		.word	.LANCHOR67
 4936 00d0 00000000 		.word	.LANCHOR65
 4937 00d4 00000000 		.word	.LANCHOR14
 4938 00d8 00000000 		.word	.LANCHOR59
 4939              	.LBE298:
 4940              		.cfi_endproc
 4941              	.LFE185:
 4943              		.section	.text._Z12nvrReadFloati,"ax",%progbits
 4944              		.align	1
 4945              		.global	_Z12nvrReadFloati
 4946              		.thumb
 4947              		.thumb_func
 4949              	_Z12nvrReadFloati:
 4950              	.LFB189:
 4951              		.file 22 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/DataStorage.h"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   This program is free software: you can redistribute it and/or modify
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   it under the terms of the GNU General Public License as published by
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   the Free Software Foundation, either version 3 of the License, or
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   (at your option) any later version.
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   This program is distributed in the hope that it will be useful,
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   GNU General Public License for more details.
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   You should have received a copy of the GNU General Public License
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** // Special thanks for 1k space optimization update from Ala42
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** // http://aeroquad.com/showthread.php?1369-The-big-enhancement-addition-to-2.0-code&p=13359&viewful
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #ifndef _AQ_DATA_STORAGE_H_
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #define _AQ_DATA_STORAGE_H_
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** // Utilities for writing and reading from the EEPROM
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** float nvrReadFloat(int address) {
 4952              		.loc 22 28 0
 4953              		.cfi_startproc
 4954              		@ args = 0, pretend = 0, frame = 0
 4955              		@ frame_needed = 0, uses_anonymous_args = 0
 4956              	.LVL341:
 4957 0000 70B5     		push	{r4, r5, r6, lr}
 4958              	.LCFI43:
 4959              		.cfi_def_cfa_offset 16
 4960              		.cfi_offset 4, -16
 4961              		.cfi_offset 5, -12
 4962              		.cfi_offset 6, -8
 4963              		.cfi_offset 14, -4
 4964              	.LBB299:
 4965              	.LBB300:
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   union floatStore {
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     byte floatByte[4];
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short floatUShort[2];
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     float floatVal;
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   } floatOut;
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     floatOut.floatUShort[i] = EEPROM.read(address + 2*i);
 4966              		.loc 22 37 0
 4967 0002 094D     		ldr	r5, .L312
 4968 0004 86B2     		uxth	r6, r0
 4969 0006 3146     		mov	r1, r6
 4970 0008 2846     		mov	r0, r5
 4971              	.LVL342:
 4972 000a FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 4973              	.LVL343:
 4974 000e 0024     		movs	r4, #0
 4975              	.LVL344:
 4976 0010 B11C     		adds	r1, r6, #2
 4977 0012 60F30F04 		bfi	r4, r0, #0, #16
 4978              	.LVL345:
 4979 0016 89B2     		uxth	r1, r1
 4980 0018 2846     		mov	r0, r5
 4981 001a FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 4982              	.LVL346:
 4983 001e 60F31F44 		bfi	r4, r0, #16, #16
 4984              	.LVL347:
 4985              	.LBE300:
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     floatOut.floatByte[i] = EEPROM.read(address + i);
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   return floatOut.floatVal;
 4986              		.loc 22 45 0
 4987 0022 2046     		mov	r0, r4	@ float
 4988              	.LBE299:
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 4989              		.loc 22 46 0
 4990 0024 70BD     		pop	{r4, r5, r6, pc}
 4991              	.L313:
 4992 0026 00BF     		.align	2
 4993              	.L312:
 4994 0028 00000000 		.word	EEPROM
 4995              		.cfi_endproc
 4996              	.LFE189:
 4998              		.section	.text._Z13nvrWriteFloatfi,"ax",%progbits
 4999              		.align	1
 5000              		.global	_Z13nvrWriteFloatfi
 5001              		.thumb
 5002              		.thumb_func
 5004              	_Z13nvrWriteFloatfi:
 5005              	.LFB190:
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteFloat(float value, int address) {
 5006              		.loc 22 48 0
 5007              		.cfi_startproc
 5008              		@ args = 0, pretend = 0, frame = 0
 5009              		@ frame_needed = 0, uses_anonymous_args = 0
 5010              	.LVL348:
 5011 0000 70B5     		push	{r4, r5, r6, lr}
 5012              	.LCFI44:
 5013              		.cfi_def_cfa_offset 16
 5014              		.cfi_offset 4, -16
 5015              		.cfi_offset 5, -12
 5016              		.cfi_offset 6, -8
 5017              		.cfi_offset 14, -4
 5018              	.LBB301:
 5019              	.LBB302:
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   union floatStore {
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     byte floatByte[4];
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short floatUShort[2];
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     float floatVal;
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   } floatIn;
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   floatIn.floatVal = value;
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 5020              		.loc 22 58 0
 5021 0002 084D     		ldr	r5, .L315
 5022              	.LBE302:
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   floatIn.floatVal = value;
 5023              		.loc 22 55 0
 5024 0004 0446     		mov	r4, r0	@ float
 5025              	.LVL349:
 5026              	.LBB303:
 5027              		.loc 22 58 0
 5028 0006 8EB2     		uxth	r6, r1
 5029 0008 3146     		mov	r1, r6
 5030              	.LVL350:
 5031 000a A2B2     		uxth	r2, r4
 5032 000c 2846     		mov	r0, r5
 5033              	.LVL351:
 5034 000e FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 5035              	.LVL352:
 5036 0012 B11C     		adds	r1, r6, #2
 5037 0014 2846     		mov	r0, r5
 5038 0016 89B2     		uxth	r1, r1
 5039 0018 220C     		lsrs	r2, r4, #16
 5040              	.LBE303:
 5041              	.LBE301:
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + i, floatIn.floatByte[i]);
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 5042              		.loc 22 65 0
 5043 001a BDE87040 		pop	{r4, r5, r6, lr}
 5044              	.LBB305:
 5045              	.LBB304:
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, floatIn.floatUShort[i]);
 5046              		.loc 22 58 0
 5047 001e FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 5048              	.LVL353:
 5049              	.L316:
 5050 0022 00BF     		.align	2
 5051              	.L315:
 5052 0024 00000000 		.word	EEPROM
 5053              	.LBE304:
 5054              	.LBE305:
 5055              		.cfi_endproc
 5056              	.LFE190:
 5058              		.section	.text._Z11nvrReadLongi,"ax",%progbits
 5059              		.align	1
 5060              		.global	_Z11nvrReadLongi
 5061              		.thumb
 5062              		.thumb_func
 5064              	_Z11nvrReadLongi:
 5065              	.LFB191:
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** long nvrReadLong(int address) {
 5066              		.loc 22 67 0
 5067              		.cfi_startproc
 5068              		@ args = 0, pretend = 0, frame = 0
 5069              		@ frame_needed = 0, uses_anonymous_args = 0
 5070              	.LVL354:
 5071 0000 70B5     		push	{r4, r5, r6, lr}
 5072              	.LCFI45:
 5073              		.cfi_def_cfa_offset 16
 5074              		.cfi_offset 4, -16
 5075              		.cfi_offset 5, -12
 5076              		.cfi_offset 6, -8
 5077              		.cfi_offset 14, -4
 5078              	.LBB306:
 5079              	.LBB307:
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   union longStore {
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     byte longByte[4];
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short longUShort[2];
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     long longVal;
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   } longOut;  
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     longOut.longUShort[i] = EEPROM.read(address + 2*i);
 5080              		.loc 22 76 0
 5081 0002 094D     		ldr	r5, .L318
 5082 0004 86B2     		uxth	r6, r0
 5083 0006 3146     		mov	r1, r6
 5084 0008 2846     		mov	r0, r5
 5085              	.LVL355:
 5086 000a FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 5087              	.LVL356:
 5088 000e 0024     		movs	r4, #0
 5089              	.LVL357:
 5090 0010 B11C     		adds	r1, r6, #2
 5091 0012 60F30F04 		bfi	r4, r0, #0, #16
 5092              	.LVL358:
 5093 0016 89B2     		uxth	r1, r1
 5094 0018 2846     		mov	r0, r5
 5095 001a FFF7FEFF 		bl	_ZN11EEPROMClass4readEt
 5096              	.LVL359:
 5097 001e 60F31F44 		bfi	r4, r0, #16, #16
 5098              	.LVL360:
 5099              	.LBE307:
 5100              	.LBE306:
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #else
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte i = 0; i < 4; i++) {
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     longOut.longByte[i] = EEPROM.read(address + i);
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   return longOut.longVal;
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 5101              		.loc 22 85 0
 5102 0022 2046     		mov	r0, r4
 5103 0024 70BD     		pop	{r4, r5, r6, pc}
 5104              	.L319:
 5105 0026 00BF     		.align	2
 5106              	.L318:
 5107 0028 00000000 		.word	EEPROM
 5108              		.cfi_endproc
 5109              	.LFE191:
 5111              		.section	.text._Z12nvrWriteLongli,"ax",%progbits
 5112              		.align	1
 5113              		.global	_Z12nvrWriteLongli
 5114              		.thumb
 5115              		.thumb_func
 5117              	_Z12nvrWriteLongli:
 5118              	.LFB192:
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteLong(long value, int address) {
 5119              		.loc 22 87 0
 5120              		.cfi_startproc
 5121              		@ args = 0, pretend = 0, frame = 0
 5122              		@ frame_needed = 0, uses_anonymous_args = 0
 5123              	.LVL361:
 5124 0000 70B5     		push	{r4, r5, r6, lr}
 5125              	.LCFI46:
 5126              		.cfi_def_cfa_offset 16
 5127              		.cfi_offset 4, -16
 5128              		.cfi_offset 5, -12
 5129              		.cfi_offset 6, -8
 5130              		.cfi_offset 14, -4
 5131              	.LBB308:
 5132              	.LBB309:
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   union longStore {
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     byte longByte[4];
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     unsigned short longUShort[2];
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     long longVal;
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   } longIn;  
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
  94:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   longIn.longVal = value;
  95:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
  96:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #ifdef EEPROM_USES_16BIT_WORDS
  97:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 2; i++) {
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 5133              		.loc 22 98 0
 5134 0002 084D     		ldr	r5, .L321
 5135              	.LBE309:
 5136              	.LBE308:
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWriteLong(long value, int address) {
 5137              		.loc 22 87 0
 5138 0004 0446     		mov	r4, r0
 5139              	.LBB312:
 5140              	.LBB310:
 5141              		.loc 22 98 0
 5142 0006 8EB2     		uxth	r6, r1
 5143 0008 3146     		mov	r1, r6
 5144              	.LVL362:
 5145 000a A2B2     		uxth	r2, r4
 5146 000c 2846     		mov	r0, r5
 5147              	.LVL363:
 5148 000e FFF7FEFF 		bl	_ZN11EEPROMClass5writeEtt
 5149              	.LVL364:
 5150 0012 B11C     		adds	r1, r6, #2
 5151 0014 2846     		mov	r0, r5
 5152 0016 89B2     		uxth	r1, r1
 5153 0018 220C     		lsrs	r2, r4, #16
 5154              	.LBE310:
 5155              	.LBE312:
  99:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #else
 101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (int i = 0; i < 4; i++) {
 102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + i, longIn.longByte[i]);
 103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** #endif
 105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 5156              		.loc 22 105 0
 5157 001a BDE87040 		pop	{r4, r5, r6, lr}
 5158              	.LBB313:
 5159              	.LBB311:
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     EEPROM.write(address + 2*i, longIn.longUShort[i]);
 5160              		.loc 22 98 0
 5161 001e FFF7FEBF 		b	_ZN11EEPROMClass5writeEtt
 5162              	.LVL365:
 5163              	.L322:
 5164 0022 00BF     		.align	2
 5165              	.L321:
 5166 0024 00000000 		.word	EEPROM
 5167              	.LBE311:
 5168              	.LBE313:
 5169              		.cfi_endproc
 5170              	.LFE192:
 5172              		.section	.text._Z10nvrReadPIDhj,"ax",%progbits
 5173              		.align	1
 5174              		.global	_Z10nvrReadPIDhj
 5175              		.thumb
 5176              		.thumb_func
 5178              	_Z10nvrReadPIDhj:
 5179              	.LFB193:
 106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 5180              		.loc 22 107 0
 5181              		.cfi_startproc
 5182              		@ args = 0, pretend = 0, frame = 0
 5183              		@ frame_needed = 0, uses_anonymous_args = 0
 5184              	.LVL366:
 5185 0000 38B5     		push	{r3, r4, r5, lr}
 5186              	.LCFI47:
 5187              		.cfi_def_cfa_offset 16
 5188              		.cfi_offset 3, -16
 5189              		.cfi_offset 4, -12
 5190              		.cfi_offset 5, -8
 5191              		.cfi_offset 14, -4
 5192              	.LBB314:
 108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 5193              		.loc 22 108 0
 5194 0002 0B4B     		ldr	r3, .L324
 5195 0004 1824     		movs	r4, #24
 5196 0006 04FB0034 		mla	r4, r4, r0, r3
 5197              	.LVL367:
 109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->P = nvrReadFloat(IDEeprom);
 5198              		.loc 22 109 0
 5199 000a 0846     		mov	r0, r1
 5200              	.LVL368:
 5201              	.LBE314:
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrReadPID(unsigned char IDPid, unsigned int IDEeprom) {
 5202              		.loc 22 107 0
 5203 000c 0D46     		mov	r5, r1
 5204              	.LBB315:
 5205              		.loc 22 109 0
 5206 000e FFF7FEFF 		bl	_Z12nvrReadFloati
 5207              	.LVL369:
 5208 0012 2060     		str	r0, [r4, #0]	@ float
 110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->I = nvrReadFloat(IDEeprom+4);
 5209              		.loc 22 110 0
 5210 0014 281D     		adds	r0, r5, #4
 5211 0016 FFF7FEFF 		bl	_Z12nvrReadFloati
 5212              	.LVL370:
 5213 001a 6060     		str	r0, [r4, #4]	@ float
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 5214              		.loc 22 111 0
 5215 001c 05F10800 		add	r0, r5, #8
 5216 0020 FFF7FEFF 		bl	_Z12nvrReadFloati
 5217              	.LVL371:
 112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->lastError = 0;
 5218              		.loc 22 112 0
 5219 0024 0023     		movs	r3, #0
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->D = nvrReadFloat(IDEeprom+8);
 5220              		.loc 22 111 0
 5221 0026 A060     		str	r0, [r4, #8]	@ float
 5222              		.loc 22 112 0
 5223 0028 E360     		str	r3, [r4, #12]	@ float
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   pid->integratedError = 0;
 5224              		.loc 22 113 0
 5225 002a 6361     		str	r3, [r4, #20]	@ float
 5226 002c 38BD     		pop	{r3, r4, r5, pc}
 5227              	.L325:
 5228 002e 00BF     		.align	2
 5229              	.L324:
 5230 0030 00000000 		.word	.LANCHOR15
 5231              	.LBE315:
 5232              		.cfi_endproc
 5233              	.LFE193:
 5235              		.section	.text._Z11nvrWritePIDhj,"ax",%progbits
 5236              		.align	1
 5237              		.global	_Z11nvrWritePIDhj
 5238              		.thumb
 5239              		.thumb_func
 5241              	_Z11nvrWritePIDhj:
 5242              	.LFB194:
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 5243              		.loc 22 116 0
 5244              		.cfi_startproc
 5245              		@ args = 0, pretend = 0, frame = 0
 5246              		@ frame_needed = 0, uses_anonymous_args = 0
 5247              	.LVL372:
 5248 0000 38B5     		push	{r3, r4, r5, lr}
 5249              	.LCFI48:
 5250              		.cfi_def_cfa_offset 16
 5251              		.cfi_offset 3, -16
 5252              		.cfi_offset 4, -12
 5253              		.cfi_offset 5, -8
 5254              		.cfi_offset 14, -4
 5255              	.LBB316:
 117:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   struct PIDdata* pid = &PID[IDPid];
 5256              		.loc 22 117 0
 5257 0002 094B     		ldr	r3, .L327
 5258 0004 1824     		movs	r4, #24
 5259 0006 04FB0034 		mla	r4, r4, r0, r3
 5260              	.LVL373:
 5261              	.LBE316:
 116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void nvrWritePID(unsigned char IDPid, unsigned int IDEeprom) {
 5262              		.loc 22 116 0
 5263 000a 0D46     		mov	r5, r1
 5264              	.LBB317:
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->P, IDEeprom);
 5265              		.loc 22 118 0
 5266 000c 2068     		ldr	r0, [r4, #0]	@ float
 5267              	.LVL374:
 5268 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5269              	.LVL375:
 119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->I, IDEeprom+4);
 5270              		.loc 22 119 0
 5271 0012 6068     		ldr	r0, [r4, #4]	@ float
 5272 0014 291D     		adds	r1, r5, #4
 5273 0016 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5274              	.LVL376:
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 5275              		.loc 22 120 0
 5276 001a A068     		ldr	r0, [r4, #8]	@ float
 5277 001c 05F10801 		add	r1, r5, #8
 5278              	.LBE317:
 121:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 5279              		.loc 22 121 0
 5280 0020 BDE83840 		pop	{r3, r4, r5, lr}
 5281              	.LBB318:
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   nvrWriteFloat(pid->D, IDEeprom+8);
 5282              		.loc 22 120 0
 5283 0024 FFF7FEBF 		b	_Z13nvrWriteFloatfi
 5284              	.LVL377:
 5285              	.L328:
 5286              		.align	2
 5287              	.L327:
 5288 0028 00000000 		.word	.LANCHOR15
 5289              	.LBE318:
 5290              		.cfi_endproc
 5291              	.LFE194:
 5293              		.section	.text._Z10readEEPROMv,"ax",%progbits
 5294              		.align	1
 5295              		.global	_Z10readEEPROMv
 5296              		.thumb
 5297              		.thumb_func
 5299              	_Z10readEEPROMv:
 5300              	.LFB196:
 122:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 123:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** // contains all default values when re-writing EEPROM
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 150.0;
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -350.0;
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 3.5;
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 143:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA PID experiements
 144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -350.0;
 147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -350.0;
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = 1.0;
 151:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0;
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = 1.0;
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = 0;
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = 1.0;
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = 0;
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   storeSensorsZeroToEEPROM();
 159:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 160:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldBaro)
 161:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].P = 25.0;
 162:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 163:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[BARO_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].P = 0.0;
 165:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].I = 0.0;
 166:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[ZDAMPENING_PID_IDX].D = 0.0;
 167:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 168:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 169:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = 50.0;
 170:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = 0.6;
 171:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = 0.0;
 172:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 173:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 174:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 175:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 176:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = -50.0;
 177:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = 50.0; //we don't want it to be able to take over totally
 178:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 179:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = 0.1;
 180:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 181:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = 90;
 182:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = 250;
 183:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 184:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 185:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   initializePlatformSpecificAccelCalibration();
 186:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = 1.0;
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 189:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // AKA - old setOneG not in SI - accel->setOneG(500);
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = -9.80665; // AKA set one G to 9.8 m/s^2
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 192:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = 1.0;
 193:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = 0.0;
 194:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = 1.0;
 195:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 196:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 197:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 198:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = RATE_FLIGHT_MODE;
 199:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = ON;
 200:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 201:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 202:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 203:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 204:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorAlarmVoltage = 3.33;
 205:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = 1450;
 206:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorGoingDownTime = 60000;
 207:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 208:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 209:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 210:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 211:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     maxRangeFinderRange = 4.5;
 212:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     minRangeFinderRange = 0.0;
 213:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 214:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 215:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 216:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     missionNbPoint = 0;
 217:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].P = 0.8;
 218:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].I = 0.0;
 219:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSROLL_PID_IDX].D = 0.0;
 220:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].P = 0.8;
 221:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].I = 0.0;
 222:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSPITCH_PID_IDX].D = 0.0;
 223:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].P = 50.0;
 224:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].I = 0.0;
 225:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     PID[GPSYAW_PID_IDX].D = 0.0;
 226:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].longitude = GPS_INVALID_ANGLE;
 229:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].latitude = GPS_INVALID_ANGLE;
 230:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].altitude = GPS_INVALID_ALTITUDE;
 231:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     }
 232:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 234:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Camera Control
 235:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 236:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     cameraMode = 1;
 237:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraPitch = 1273.2;    
 238:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraRoll = 636.6;    
 239:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraYaw = 318.3;
 240:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterPitch = 1500;
 241:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterRoll = 1500;
 242:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterYaw = 1500;
 243:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinPitch = 1000;
 244:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinRoll = 1000;
 245:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinYaw = 1000;
 246:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxPitch = 2000;
 247:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxRoll = 2000;
 248:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxYaw = 2000;
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #ifdef CameraTXControl
 250:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       servoTXChannels = 1;
 251:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 252:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 253:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 254:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void readEEPROM() {
 5301              		.loc 22 255 0
 5302              		.cfi_startproc
 5303              		@ args = 0, pretend = 0, frame = 0
 5304              		@ frame_needed = 0, uses_anonymous_args = 0
 256:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(XAXIS, ROLL_PID_GAIN_ADR);
 5305              		.loc 22 256 0
 5306 0000 0020     		movs	r0, #0
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void readEEPROM() {
 5307              		.loc 22 255 0
 5308 0002 08B5     		push	{r3, lr}
 5309              	.LCFI49:
 5310              		.cfi_def_cfa_offset 8
 5311              		.cfi_offset 3, -8
 5312              		.cfi_offset 14, -4
 5313              		.loc 22 256 0
 5314 0004 0146     		mov	r1, r0
 5315 0006 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5316              	.LVL378:
 257:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(YAXIS, PITCH_PID_GAIN_ADR);
 5317              		.loc 22 257 0
 5318 000a 0120     		movs	r0, #1
 5319 000c 2421     		movs	r1, #36
 5320 000e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5321              	.LVL379:
 258:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ZAXIS, YAW_PID_GAIN_ADR);
 5322              		.loc 22 258 0
 5323 0012 0220     		movs	r0, #2
 5324 0014 1821     		movs	r1, #24
 5325 0016 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5326              	.LVL380:
 259:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 5327              		.loc 22 259 0
 5328 001a 0320     		movs	r0, #3
 5329 001c 0C21     		movs	r1, #12
 5330 001e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5331              	.LVL381:
 260:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 5332              		.loc 22 260 0
 5333 0022 0420     		movs	r0, #4
 5334 0024 3021     		movs	r1, #48
 5335 0026 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5336              	.LVL382:
 261:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 5337              		.loc 22 261 0
 5338 002a 0520     		movs	r0, #5
 5339 002c 3C21     		movs	r1, #60
 5340 002e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5341              	.LVL383:
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 5342              		.loc 22 262 0
 5343 0032 0620     		movs	r0, #6
 5344 0034 4821     		movs	r1, #72
 5345 0036 FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5346              	.LVL384:
 263:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   readPID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 5347              		.loc 22 263 0
 5348 003a 5421     		movs	r1, #84
 5349 003c 0720     		movs	r0, #7
 5350 003e FFF7FEFF 		bl	_Z10nvrReadPIDhj
 5351              	.LVL385:
 264:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 265:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = readFloat(ROTATION_SPEED_FACTOR_ARD);
 5352              		.loc 22 265 0
 5353 0042 4FF4A270 		mov	r0, #324
 5354 0046 FFF7FEFF 		bl	_Z12nvrReadFloati
 5355              	.LVL386:
 5356 004a 194B     		ldr	r3, .L330
 5357 004c 1860     		str	r0, [r3, #0]	@ float
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 267:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Leaving separate PID reads as commented for now
 268:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Previously had issue where EEPROM was not reading right data
 269:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 270:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 271:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 272:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       baroSmoothFactor = readFloat(ALTITUDE_SMOOTH_ADR);
 273:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif  
 274:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldBump = readFloat(ALTITUDE_BUMP_ADR);
 275:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     altitudeHoldPanicStickMovement = readFloat(ALTITUDE_PANIC_ADR);
 276:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     minThrottleAdjust = readFloat(ALTITUDE_MIN_THROTTLE_ADR);
 277:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     maxThrottleAdjust = readFloat(ALTITUDE_MAX_THROTTLE_ADR);
 278:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 279:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 280:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 281:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Mag calibration
 282:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 283:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[XAXIS]  = readFloat(XAXIS_MAG_BIAS_ADR);
 284:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[YAXIS]  = readFloat(YAXIS_MAG_BIAS_ADR);
 285:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     magBias[ZAXIS]  = readFloat(ZAXIS_MAG_BIAS_ADR);
 286:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 287:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 288:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 289:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 290:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorAlarmVoltage = readFloat(BATT_ALARM_VOLTAGE_ADR);
 291:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorThrottleTarget = readFloat(BATT_THROTTLE_TARGET_ADR);
 292:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     batteryMonitorGoingDownTime = readFloat(BATT_DOWN_TIME_ADR);
 293:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 294:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 295:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 5358              		.loc 22 295 0
 5359 004e 4FF48E70 		mov	r0, #284
 5360 0052 FFF7FEFF 		bl	_Z12nvrReadFloati
 5361              	.LVL387:
 5362 0056 07EE100A 		fmsr	s14, r0
 5363 005a 164B     		ldr	r3, .L330+4
 5364 005c FDEEC77A 		ftosizs	s15, s14
 296:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = readFloat(AREF_ADR);
 5365              		.loc 22 296 0
 5366 0060 4FF49070 		mov	r0, #288
 295:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = readFloat(MINARMEDTHROTTLE_ADR);
 5367              		.loc 22 295 0
 5368 0064 C3ED007A 		fsts	s15, [r3, #0]	@ int
 5369              		.loc 22 296 0
 5370 0068 FFF7FEFF 		bl	_Z12nvrReadFloati
 5371              	.LVL388:
 5372 006c 124B     		ldr	r3, .L330+8
 5373 006e 1860     		str	r0, [r3, #0]	@ float
 297:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = readFloat(FLIGHTMODE_ADR);
 5374              		.loc 22 297 0
 5375 0070 4FF49270 		mov	r0, #292
 5376 0074 FFF7FEFF 		bl	_Z12nvrReadFloati
 5377              	.LVL389:
 5378 0078 07EE900A 		fmsr	s15, r0
 5379 007c FCEEE77A 		ftouizs	s15, s15
 5380 0080 0E4B     		ldr	r3, .L330+12
 5381 0082 17EE900A 		fmrs	r0, s15	@ int
 5382 0086 1870     		strb	r0, [r3, #0]
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 5383              		.loc 22 298 0
 5384 0088 4FF49670 		mov	r0, #300
 5385 008c FFF7FEFF 		bl	_Z12nvrReadFloati
 5386              	.LVL390:
 5387 0090 0B4B     		ldr	r3, .L330+16
 5388 0092 1860     		str	r0, [r3, #0]	@ float
 299:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = readFloat(HEADINGHOLD_ADR);
 5389              		.loc 22 299 0
 5390 0094 4FF49470 		mov	r0, #296
 5391 0098 FFF7FEFF 		bl	_Z12nvrReadFloati
 5392              	.LVL391:
 5393 009c 07EE100A 		fmsr	s14, r0
 5394 00a0 BCEEC77A 		ftouizs	s14, s14
 5395 00a4 074B     		ldr	r3, .L330+20
 5396 00a6 17EE100A 		fmrs	r0, s14	@ int
 5397 00aa 1870     		strb	r0, [r3, #0]
 5398 00ac 08BD     		pop	{r3, pc}
 5399              	.L331:
 5400 00ae 00BF     		.align	2
 5401              	.L330:
 5402 00b0 00000000 		.word	.LANCHOR60
 5403 00b4 00000000 		.word	.LANCHOR65
 5404 00b8 00000000 		.word	.LANCHOR77
 5405 00bc 00000000 		.word	.LANCHOR59
 5406 00c0 00000000 		.word	.LANCHOR33
 5407 00c4 00000000 		.word	.LANCHOR68
 5408              		.cfi_endproc
 5409              	.LFE196:
 5411              		.section	.text._Z11writeEEPROMv,"ax",%progbits
 5412              		.align	1
 5413              		.global	_Z11writeEEPROMv
 5414              		.thumb
 5415              		.thumb_func
 5417              	_Z11writeEEPROMv:
 5418              	.LFB197:
 300:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 301:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 302:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     missionNbPoint = readFloat(GPS_MISSION_NB_POINT_ADR);
 303:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 304:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 305:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     readPID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 306:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     
 307:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 308:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].longitude = readLong(WAYPOINT_ADR[location].longitude);
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].latitude = readLong(WAYPOINT_ADR[location].latitude);
 310:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       waypoint[location].altitude = readLong(WAYPOINT_ADR[location].altitude);
 311:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     }    
 312:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 313:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 314:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Camera Control
 315:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 316:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     cameraMode = readFloat(CAMERAMODE_ADR);
 317:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraPitch = readFloat(MCAMERAPITCH_ADR);
 318:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraRoll = readFloat(MCAMERAROLL_ADR);    
 319:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     mCameraYaw = readFloat(MCAMERAYAW_ADR);
 320:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterPitch = readFloat(SERVOCENTERPITCH_ADR);
 321:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterRoll = readFloat(SERVOCENTERROLL_ADR);
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoCenterYaw = readFloat(SERVOCENTERYAW_ADR);
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinPitch = readFloat(SERVOMINPITCH_ADR);
 324:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinRoll = readFloat(SERVOMINROLL_ADR);
 325:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMinYaw = readFloat(SERVOMINYAW_ADR);
 326:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxPitch = readFloat(SERVOMAXPITCH_ADR);
 327:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxRoll = readFloat(SERVOMAXROLL_ADR);
 328:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     servoMaxYaw = readFloat(SERVOMAXYAW_ADR);
 329:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #ifdef CameraTXControl
 330:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       servoTXChannels = readFloat(SERVOTXCHANNELS_ADR);
 331:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       servoActualCenter = readFloat(SERVOCENTERPITCH_ADR);
 332:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 333:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif   
 334:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 335:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 5419              		.loc 22 336 0
 5420              		.cfi_startproc
 5421              		@ args = 0, pretend = 0, frame = 0
 5422              		@ frame_needed = 0, uses_anonymous_args = 0
 5423 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 5424              	.LCFI50:
 5425              		.cfi_def_cfa_offset 24
 5426              		.cfi_offset 4, -24
 5427              		.cfi_offset 5, -20
 5428              		.cfi_offset 6, -16
 5429              		.cfi_offset 7, -12
 5430              		.cfi_offset 8, -8
 5431              		.cfi_offset 14, -4
 5432              	.LBB319:
 5433              	.LBB320:
 5434              	.LBB321:
 5435              		.file 23 "../Libmaple/libmaple/libmaple/nvic.h"
   1:../Libmaple/libmaple/libmaple/nvic.h **** /******************************************************************************
   2:../Libmaple/libmaple/libmaple/nvic.h ****  * The MIT License
   3:../Libmaple/libmaple/libmaple/nvic.h ****  *
   4:../Libmaple/libmaple/libmaple/nvic.h ****  * Copyright (c) 2010 Perry Hung.
   5:../Libmaple/libmaple/libmaple/nvic.h ****  *
   6:../Libmaple/libmaple/libmaple/nvic.h ****  * Permission is hereby granted, free of charge, to any person
   7:../Libmaple/libmaple/libmaple/nvic.h ****  * obtaining a copy of this software and associated documentation
   8:../Libmaple/libmaple/libmaple/nvic.h ****  * files (the "Software"), to deal in the Software without
   9:../Libmaple/libmaple/libmaple/nvic.h ****  * restriction, including without limitation the rights to use, copy,
  10:../Libmaple/libmaple/libmaple/nvic.h ****  * modify, merge, publish, distribute, sublicense, and/or sell copies
  11:../Libmaple/libmaple/libmaple/nvic.h ****  * of the Software, and to permit persons to whom the Software is
  12:../Libmaple/libmaple/libmaple/nvic.h ****  * furnished to do so, subject to the following conditions:
  13:../Libmaple/libmaple/libmaple/nvic.h ****  *
  14:../Libmaple/libmaple/libmaple/nvic.h ****  * The above copyright notice and this permission notice shall be
  15:../Libmaple/libmaple/libmaple/nvic.h ****  * included in all copies or substantial portions of the Software.
  16:../Libmaple/libmaple/libmaple/nvic.h ****  *
  17:../Libmaple/libmaple/libmaple/nvic.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  18:../Libmaple/libmaple/libmaple/nvic.h ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  19:../Libmaple/libmaple/libmaple/nvic.h ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  20:../Libmaple/libmaple/libmaple/nvic.h ****  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  21:../Libmaple/libmaple/libmaple/nvic.h ****  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  22:../Libmaple/libmaple/libmaple/nvic.h ****  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  23:../Libmaple/libmaple/libmaple/nvic.h ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  24:../Libmaple/libmaple/libmaple/nvic.h ****  * SOFTWARE.
  25:../Libmaple/libmaple/libmaple/nvic.h ****  *****************************************************************************/
  26:../Libmaple/libmaple/libmaple/nvic.h **** 
  27:../Libmaple/libmaple/libmaple/nvic.h **** /**
  28:../Libmaple/libmaple/libmaple/nvic.h ****  * @file nvic.h
  29:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Nested vector interrupt controller support.
  30:../Libmaple/libmaple/libmaple/nvic.h ****  *
  31:../Libmaple/libmaple/libmaple/nvic.h ****  * Basic usage:
  32:../Libmaple/libmaple/libmaple/nvic.h ****  *
  33:../Libmaple/libmaple/libmaple/nvic.h ****  * @code
  34:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Initialise the interrupt controller and point to the vector
  35:../Libmaple/libmaple/libmaple/nvic.h ****  *   // table at the start of flash.
  36:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_init(0x08000000, 0);
  37:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Bind in a timer interrupt handler
  38:../Libmaple/libmaple/libmaple/nvic.h ****  *   timer_attach_interrupt(TIMER_CC1_INTERRUPT, handler);
  39:../Libmaple/libmaple/libmaple/nvic.h ****  *   // Optionally set the priority
  40:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_irq_set_priority(NVIC_TIMER1_CC, 5);
  41:../Libmaple/libmaple/libmaple/nvic.h ****  *   // All done, enable all interrupts
  42:../Libmaple/libmaple/libmaple/nvic.h ****  *   nvic_globalirq_enable();
  43:../Libmaple/libmaple/libmaple/nvic.h ****  * @endcode
  44:../Libmaple/libmaple/libmaple/nvic.h ****  */
  45:../Libmaple/libmaple/libmaple/nvic.h **** 
  46:../Libmaple/libmaple/libmaple/nvic.h **** #ifndef _NVIC_H_
  47:../Libmaple/libmaple/libmaple/nvic.h **** #define _NVIC_H_
  48:../Libmaple/libmaple/libmaple/nvic.h **** 
  49:../Libmaple/libmaple/libmaple/nvic.h **** #include "libmaple_types.h"
  50:../Libmaple/libmaple/libmaple/nvic.h **** #include "util.h"
  51:../Libmaple/libmaple/libmaple/nvic.h **** 
  52:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef __cplusplus
  53:../Libmaple/libmaple/libmaple/nvic.h **** extern "C"{
  54:../Libmaple/libmaple/libmaple/nvic.h **** #endif
  55:../Libmaple/libmaple/libmaple/nvic.h **** 
  56:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map type. */
  57:../Libmaple/libmaple/libmaple/nvic.h **** typedef struct nvic_reg_map {
  58:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISER[8];      /**< Interrupt Set Enable Registers */
  59:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED0[24];     /**< Reserved */
  60:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICER[8];      /**< Interrupt Clear Enable Registers */
  61:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RSERVED1[24];      /**< Reserved */
  62:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ISPR[8];      /**< Interrupt Set Pending Registers */
  63:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED2[24];     /**< Reserved */
  64:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 ICPR[8];      /**< Interrupt Clear Pending Registers */
  65:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED3[24];     /**< Reserved */
  66:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 IABR[8];      /**< Interrupt Active bit Registers */
  67:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED4[56];     /**< Reserved */
  68:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint8  IP[240];      /**< Interrupt Priority Registers */
  69:../Libmaple/libmaple/libmaple/nvic.h ****     uint32 RESERVED5[644];    /**< Reserved */
  70:../Libmaple/libmaple/libmaple/nvic.h ****     __io uint32 STIR;         /**< Software Trigger Interrupt Registers */
  71:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_reg_map;
  72:../Libmaple/libmaple/libmaple/nvic.h **** 
  73:../Libmaple/libmaple/libmaple/nvic.h **** /** NVIC register map base pointer. */
  74:../Libmaple/libmaple/libmaple/nvic.h **** #define NVIC_BASE                       ((struct nvic_reg_map*)0xE000E100)
  75:../Libmaple/libmaple/libmaple/nvic.h **** 
  76:../Libmaple/libmaple/libmaple/nvic.h **** /**
  77:../Libmaple/libmaple/libmaple/nvic.h ****  * @brief Interrupt vector table interrupt numbers.
  78:../Libmaple/libmaple/libmaple/nvic.h ****  *
  79:../Libmaple/libmaple/libmaple/nvic.h ****  * Each positive-valued enumerator is the position of the
  80:../Libmaple/libmaple/libmaple/nvic.h ****  * corresponding interrupt in the vector table.  Negative-valued
  81:../Libmaple/libmaple/libmaple/nvic.h ****  * enumerators correspond to interrupts controlled by the system
  82:../Libmaple/libmaple/libmaple/nvic.h ****  * handler block.
  83:../Libmaple/libmaple/libmaple/nvic.h ****  *
  84:../Libmaple/libmaple/libmaple/nvic.h ****  * @see scb.h
  85:../Libmaple/libmaple/libmaple/nvic.h ****  */
  86:../Libmaple/libmaple/libmaple/nvic.h **** typedef enum nvic_irq_num {
  87:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_NMI            = -14,  /**< Non-maskable interrupt */
  88:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_HARDFAULT      = -13,  /**< Hard fault (all class of fault) */
  89:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_MEM_MANAGE     = -12,  /**< Memory management */
  90:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_BUS_FAULT      = -11,  /**< Bus fault: prefetch fault, memory
  91:../Libmaple/libmaple/libmaple/nvic.h ****                                      access fault. */
  92:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USAGE_FAULT    = -10,  /**< Usage fault: Undefined instruction or
  93:../Libmaple/libmaple/libmaple/nvic.h ****                                      illegal state. */
  94:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SVC            = -5,   /**< System service call via SWI insruction */
  95:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DEBUG_MON      = -4,   /**< Debug monitor */
  96:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PEND_SVC       = -2,   /**< Pendable request for system service */
  97:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SYSTICK        = -1,   /**< System tick timer */
  98:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_WWDG           = 0,    /**< Window watchdog interrupt */
  99:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_PVD            = 1,    /**< PVD through EXTI line detection */
 100:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TAMPER         = 2,    /**< Tamper */
 101:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTC            = 3,    /**< Real-time clock */
 102:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FLASH          = 4,    /**< Flash */
 103:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RCC            = 5,    /**< Reset and clock control */
 104:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI0          = 6,    /**< EXTI line 0 */
 105:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI1          = 7,    /**< EXTI line 1 */
 106:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI2          = 8,    /**< EXTI line 2 */
 107:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI3          = 9,    /**< EXTI line 3 */
 108:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI4          = 10,   /**< EXTI line 4 */
 109:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH1        = 11,   /**< DMA1 channel 1 */
 110:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH2        = 12,   /**< DMA1 channel 2 */
 111:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH3        = 13,   /**< DMA1 channel 3 */
 112:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH4        = 14,   /**< DMA1 channel 4 */
 113:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH5        = 15,   /**< DMA1 channel 5 */
 114:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH6        = 16,   /**< DMA1 channel 6 */
 115:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA_CH7        = 17,   /**< DMA1 channel 7 */
 116:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC_1_2        = 18,   /**< ADC1 and ADC2 */
 117:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_HP_CAN_TX  = 19,   /**< USB high priority or CAN TX */
 118:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USB_LP_CAN_RX0 = 20,   /**< USB low priority or CAN RX0 */
 119:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_RX1        = 21,   /**< CAN RX1 */
 120:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_CAN_SCE        = 22,   /**< CAN SCE */
 121:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_9_5       = 23,   /**< EXTI line [9:5] */
 122:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_BRK     = 24,   /**< Timer 1 break */
 123:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_UP      = 25,   /**< Timer 1 update */
 124:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_TRG_COM = 26,   /**< Timer 1 trigger and commutation */
 125:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER1_CC      = 27,   /**< Timer 1 capture/compare */
 126:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER2         = 28,   /**< Timer 2 */
 127:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER3         = 29,   /**< Timer 3 */
 128:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER4         = 30,   /**< Timer 4 */
 129:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_EV        = 31,   /**< I2C1 event */
 130:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C1_ER        = 32,   /**< I2C1 error */
 131:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_EV        = 33,   /**< I2C2 event */
 132:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_I2C2_ER        = 34,   /**< I2C2 error */
 133:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI1           = 35,   /**< SPI1 */
 134:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI2           = 36,   /**< SPI2 */
 135:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART1         = 37,   /**< USART1 */
 136:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART2         = 38,   /**< USART2 */
 137:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USART3         = 39,   /**< USART3 */
 138:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_EXTI_15_10     = 40,   /**< EXTI line [15:10] */
 139:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_RTCALARM       = 41,   /**< RTC alarm through EXTI line */
 140:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_USBWAKEUP      = 42,   /**< USB wakeup from suspend through
 141:../Libmaple/libmaple/libmaple/nvic.h ****                                      EXTI line */
 142:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_BRK     = 43,   /**< Timer 8 break */
 143:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_UP      = 44,   /**< Timer 8 update */
 144:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_TRG_COM = 45,   /**< Timer 8 trigger and commutation */
 145:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER8_CC      = 46,   /**< Timer 8 capture/compare */
 146:../Libmaple/libmaple/libmaple/nvic.h **** #ifdef STM32_HIGH_DENSITY
 147:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_ADC3           = 47,   /**< ADC3 */
 148:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_FSMC           = 48,   /**< FSMC */
 149:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SDIO           = 49,   /**< SDIO */
 150:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER5         = 50,   /**< Timer 5 */
 151:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_SPI3           = 51,   /**< SPI3 */
 152:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART4          = 52,   /**< UART4 */
 153:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_UART5          = 53,   /**< UART5 */
 154:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER6         = 54,   /**< Timer 6 */
 155:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_TIMER7         = 55,   /**< Timer 7 */
 156:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH1       = 56,   /**< DMA2 channel 1 */
 157:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH2       = 57,   /**< DMA2 channel 2 */
 158:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH3       = 58,   /**< DMA2 channel 3 */
 159:../Libmaple/libmaple/libmaple/nvic.h ****     NVIC_DMA2_CH_4_5    = 59,   /**< DMA2 channels 4 and 5 */
 160:../Libmaple/libmaple/libmaple/nvic.h **** #endif
 161:../Libmaple/libmaple/libmaple/nvic.h **** } nvic_irq_num;
 162:../Libmaple/libmaple/libmaple/nvic.h **** 
 163:../Libmaple/libmaple/libmaple/nvic.h **** /*
 164:../Libmaple/libmaple/libmaple/nvic.h ****  * Initialises the interrupt controller and sets all interrupts to the
 165:../Libmaple/libmaple/libmaple/nvic.h ****  * lowest priority.
 166:../Libmaple/libmaple/libmaple/nvic.h ****  *
 167:../Libmaple/libmaple/libmaple/nvic.h ****  * For stand-alone products, the base address is normally the start of
 168:../Libmaple/libmaple/libmaple/nvic.h ****  * flash (0x08000000).
 169:../Libmaple/libmaple/libmaple/nvic.h ****  *
 170:../Libmaple/libmaple/libmaple/nvic.h ****  * @param vector_table_address  base address of the vector table
 171:../Libmaple/libmaple/libmaple/nvic.h ****  */
 172:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_init(uint32 vector_table_address, uint32 offset);
 173:../Libmaple/libmaple/libmaple/nvic.h **** 
 174:../Libmaple/libmaple/libmaple/nvic.h **** /**
 175:../Libmaple/libmaple/libmaple/nvic.h ****  * Sets the base address of the vector table.
 176:../Libmaple/libmaple/libmaple/nvic.h ****  */
 177:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_set_vector_table(uint32 address, uint32 offset);
 178:../Libmaple/libmaple/libmaple/nvic.h **** 
 179:../Libmaple/libmaple/libmaple/nvic.h **** void nvic_irq_set_priority(nvic_irq_num irqn, uint8 priority);
 180:../Libmaple/libmaple/libmaple/nvic.h **** 
 181:../Libmaple/libmaple/libmaple/nvic.h **** /**
 182:../Libmaple/libmaple/libmaple/nvic.h ****  * Enables interrupts and configurable fault handlers (clear PRIMASK).
 183:../Libmaple/libmaple/libmaple/nvic.h ****  */
 184:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_enable() {
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 186:../Libmaple/libmaple/libmaple/nvic.h **** }
 187:../Libmaple/libmaple/libmaple/nvic.h **** 
 188:../Libmaple/libmaple/libmaple/nvic.h **** /**
 189:../Libmaple/libmaple/libmaple/nvic.h ****  * Disable interrupts and configurable fault handlers (set PRIMASK).
 190:../Libmaple/libmaple/libmaple/nvic.h ****  */
 191:../Libmaple/libmaple/libmaple/nvic.h **** static inline void nvic_globalirq_disable() {
 192:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsid i");
 5436              		.loc 23 192 0
 5437              	@ 192 "../Libmaple/libmaple/libmaple/nvic.h" 1
 5438 0004 72B6     		cpsid i
 5439              	@ 0 "" 2
 5440              		.thumb
 5441              	.LBE321:
 5442              	.LBE320:
 337:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   cli(); // Needed so that APM sensor data does not overflow
 338:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(XAXIS, ROLL_PID_GAIN_ADR);
 5443              		.loc 22 338 0
 5444 0006 0020     		movs	r0, #0
 5445 0008 0146     		mov	r1, r0
 5446 000a FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5447              	.LVL392:
 339:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(YAXIS, PITCH_PID_GAIN_ADR);
 5448              		.loc 22 339 0
 5449 000e 0120     		movs	r0, #1
 5450 0010 2421     		movs	r1, #36
 5451 0012 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5452              	.LVL393:
 340:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_XAXIS_PID_IDX, LEVELROLL_PID_GAIN_ADR);
 5453              		.loc 22 340 0
 5454 0016 0320     		movs	r0, #3
 5455 0018 0C21     		movs	r1, #12
 5456 001a FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5457              	.LVL394:
 341:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_YAXIS_PID_IDX, LEVELPITCH_PID_GAIN_ADR);
 5458              		.loc 22 341 0
 5459 001e 0420     		movs	r0, #4
 5460 0020 3021     		movs	r1, #48
 5461 0022 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5462              	.LVL395:
 342:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ZAXIS, YAW_PID_GAIN_ADR);
 5463              		.loc 22 342 0
 5464 0026 0220     		movs	r0, #2
 5465 0028 1821     		movs	r1, #24
 5466 002a FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5467              	.LVL396:
 343:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(HEADING_HOLD_PID_IDX, HEADING_PID_GAIN_ADR);
 5468              		.loc 22 343 0
 5469 002e 0520     		movs	r0, #5
 5470 0030 3C21     		movs	r1, #60
 5471 0032 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5472              	.LVL397:
 344:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_XAXIS_PID_IDX, LEVEL_GYRO_ROLL_PID_GAIN_ADR);
 5473              		.loc 22 344 0
 5474 0036 0620     		movs	r0, #6
 5475 0038 4821     		movs	r1, #72
 5476 003a FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5477              	.LVL398:
 345:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writePID(ATTITUDE_GYRO_YAXIS_PID_IDX, LEVEL_GYRO_PITCH_PID_GAIN_ADR);
 5478              		.loc 22 345 0
 5479 003e 0720     		movs	r0, #7
 5480 0040 5421     		movs	r1, #84
 5481 0042 FFF7FEFF 		bl	_Z11nvrWritePIDhj
 5482              	.LVL399:
 346:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 347:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(rotationSpeedFactor,ROTATION_SPEED_FACTOR_ARD);
 5483              		.loc 22 347 0
 5484 0046 444B     		ldr	r3, .L335
 5485              	.LBB322:
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 5486              		.loc 22 336 0
 5487 0048 DFF84881 		ldr	r8, .L335+60
 5488              	.LBE322:
 5489              		.loc 22 347 0
 5490 004c 1868     		ldr	r0, [r3, #0]	@ float
 5491              	.LBB323:
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 5492              		.loc 22 336 0
 5493 004e 434F     		ldr	r7, .L335+4
 5494 0050 434E     		ldr	r6, .L335+8
 5495              	.LBE323:
 5496              		.loc 22 347 0
 5497 0052 4FF4A271 		mov	r1, #324
 5498 0056 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5499              	.LVL400:
 348:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 349:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro
 350:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(BARO_ALTITUDE_HOLD_PID_IDX, ALTITUDE_PID_GAIN_ADR);
 351:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 352:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 353:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 354:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #if defined AltitudeHoldBaro
 355:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(baroSmoothFactor, ALTITUDE_SMOOTH_ADR);
 356:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #else
 357:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(0.0, ALTITUDE_SMOOTH_ADR);
 358:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 359:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldBump, ALTITUDE_BUMP_ADR);
 360:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(altitudeHoldPanicStickMovement, ALTITUDE_PANIC_ADR);
 361:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minThrottleAdjust, ALTITUDE_MIN_THROTTLE_ADR);
 362:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxThrottleAdjust, ALTITUDE_MAX_THROTTLE_ADR);
 363:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(ZDAMPENING_PID_IDX, ZDAMP_PID_GAIN_ADR);
 364:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #else
 365:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 5500              		.loc 22 365 0
 5501 005a 4248     		ldr	r0, .L335+12
 5502 005c 4FF49C71 		mov	r1, #312
 5503 0060 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5504              	.LVL401:
 366:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(90, ALTITUDE_BUMP_ADR);
 5505              		.loc 22 366 0
 5506 0064 4048     		ldr	r0, .L335+16
 5507 0066 4FF49E71 		mov	r1, #316
 5508 006a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5509              	.LVL402:
 367:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(250, ALTITUDE_PANIC_ADR);
 5510              		.loc 22 367 0
 5511 006e 3F48     		ldr	r0, .L335+20
 5512 0070 4FF4A071 		mov	r1, #320
 5513 0074 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5514              	.LVL403:
 368:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(-50, ALTITUDE_MIN_THROTTLE_ADR);
 5515              		.loc 22 368 0
 5516 0078 3D48     		ldr	r0, .L335+24
 5517 007a 4FF49A71 		mov	r1, #308
 5518 007e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5519              	.LVL404:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(50, ALTITUDE_MAX_THROTTLE_ADR);
 5520              		.loc 22 369 0
 5521 0082 3C48     		ldr	r0, .L335+28
 5522 0084 4FF49871 		mov	r1, #304
 5523 0088 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5524              	.LVL405:
 370:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0.1, ALTITUDE_SMOOTH_ADR);
 5525              		.loc 22 370 0
 5526 008c 3548     		ldr	r0, .L335+12
 5527 008e 4FF49C71 		mov	r1, #312
 5528 0092 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5529              	.LVL406:
 371:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 372:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 373:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef HeadingMagHold
 374:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[XAXIS], XAXIS_MAG_BIAS_ADR);
 375:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[YAXIS], YAXIS_MAG_BIAS_ADR);
 376:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(magBias[ZAXIS], ZAXIS_MAG_BIAS_ADR);
 377:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 378:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(receiverXmitFactor, XMITFACTOR_ADR);
 5530              		.loc 22 378 0
 5531 0096 384B     		ldr	r3, .L335+32
 5532 0098 4FF48C71 		mov	r1, #280
 5533 009c 1868     		ldr	r0, [r3, #0]	@ float
 5534 009e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5535              	.LVL407:
 5536 00a2 0025     		movs	r5, #0
 5537 00a4 2C46     		mov	r4, r5
 5538              	.LVL408:
 5539              	.L333:
 5540              	.LBB324:
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 5541              		.loc 22 336 0 discriminator 2
 5542 00a6 08EB0403 		add	r3, r8, r4
 379:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 380:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 381:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverSlope[channel],  RECEIVER_DATA[channel].slope);
 5543              		.loc 22 381 0 discriminator 2
 5544 00aa 05F19C01 		add	r1, r5, #156
 5545 00ae 1868     		ldr	r0, [r3, #0]	@ float
 5546 00b0 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5547              	.LVL409:
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 5548              		.loc 22 336 0 discriminator 2
 5549 00b4 3B19     		adds	r3, r7, r4
 382:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverOffset[channel], RECEIVER_DATA[channel].offset);
 5550              		.loc 22 382 0 discriminator 2
 5551 00b6 05F1A001 		add	r1, r5, #160
 5552 00ba 1868     		ldr	r0, [r3, #0]	@ float
 5553 00bc FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5554              	.LVL410:
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void writeEEPROM(){
 5555              		.loc 22 336 0 discriminator 2
 5556 00c0 3319     		adds	r3, r6, r4
 383:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(receiverSmoothFactor[channel], RECEIVER_DATA[channel].smooth_factor);
 5557              		.loc 22 383 0 discriminator 2
 5558 00c2 05F1A401 		add	r1, r5, #164
 5559 00c6 1868     		ldr	r0, [r3, #0]	@ float
 5560 00c8 0434     		adds	r4, r4, #4
 5561 00ca FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5562              	.LVL411:
 5563 00ce 0C35     		adds	r5, r5, #12
 380:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 5564              		.loc 22 380 0 discriminator 2
 5565 00d0 182C     		cmp	r4, #24
 5566 00d2 E8D1     		bne	.L333
 5567              	.LBE324:
 384:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 385:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 386:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(minArmedThrottle, MINARMEDTHROTTLE_ADR);
 5568              		.loc 22 386 0
 5569 00d4 294B     		ldr	r3, .L335+36
 5570 00d6 D3ED007A 		flds	s15, [r3, #0]	@ int
 5571 00da F8EEE77A 		fsitos	s15, s15
 5572 00de 4FF48E71 		mov	r1, #284
 5573 00e2 17EE900A 		fmrs	r0, s15
 5574 00e6 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5575              	.LVL412:
 387:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(aref, AREF_ADR);
 5576              		.loc 22 387 0
 5577 00ea 254B     		ldr	r3, .L335+40
 5578 00ec 4FF49071 		mov	r1, #288
 5579 00f0 1868     		ldr	r0, [r3, #0]	@ float
 5580 00f2 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5581              	.LVL413:
 388:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(flightMode, FLIGHTMODE_ADR);
 5582              		.loc 22 388 0
 5583 00f6 234B     		ldr	r3, .L335+44
 5584 00f8 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 5585 00fa 07EE900A 		fmsr	s15, r0	@ int
 5586 00fe F8EE677A 		fuitos	s15, s15
 5587 0102 4FF49271 		mov	r1, #292
 5588 0106 17EE900A 		fmrs	r0, s15
 5589 010a FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5590              	.LVL414:
 389:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(headingHoldConfig, HEADINGHOLD_ADR);
 5591              		.loc 22 389 0
 5592 010e 1E4B     		ldr	r3, .L335+48
 5593 0110 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 5594 0112 07EE900A 		fmsr	s15, r0	@ int
 5595 0116 F8EE677A 		fuitos	s15, s15
 5596 011a 4FF49471 		mov	r1, #296
 5597 011e 17EE900A 		fmrs	r0, s15
 5598 0122 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5599              	.LVL415:
 390:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 5600              		.loc 22 390 0
 5601 0126 194B     		ldr	r3, .L335+52
 5602 0128 4FF49671 		mov	r1, #300
 5603 012c 1868     		ldr	r0, [r3, #0]	@ float
 5604 012e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5605              	.LVL416:
 391:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(SOFTWARE_VERSION, SOFTWARE_VERSION_ADR);
 5606              		.loc 22 391 0
 5607 0132 1748     		ldr	r0, .L335+56
 5608 0134 4FF48A71 		mov	r1, #276
 5609 0138 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5610              	.LVL417:
 392:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 393:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Battery Monitor
 394:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef BattMonitor
 395:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorAlarmVoltage, BATT_ALARM_VOLTAGE_ADR);
 396:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorThrottleTarget, BATT_THROTTLE_TARGET_ADR);
 397:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(batteryMonitorGoingDownTime, BATT_DOWN_TIME_ADR);
 398:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 399:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 400:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Range Finder
 401:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (AltitudeHoldRangeFinder)
 402:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(maxRangeFinderRange, RANGE_FINDER_MAX_ADR);
 403:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(minRangeFinderRange, RANGE_FINDER_MIN_ADR);
 404:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #else
 405:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0, RANGE_FINDER_MAX_ADR);
 5611              		.loc 22 405 0
 5612 013c 0020     		movs	r0, #0
 5613 013e 4FF4BC71 		mov	r1, #376
 5614 0142 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5615              	.LVL418:
 406:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(0, RANGE_FINDER_MIN_ADR);
 5616              		.loc 22 406 0
 5617 0146 0020     		movs	r0, #0
 5618 0148 4FF4BE71 		mov	r1, #380
 5619 014c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5620              	.LVL419:
 5621              	.LBB325:
 5622              	.LBB326:
 185:../Libmaple/libmaple/libmaple/nvic.h ****     asm volatile("cpsie i");
 5623              		.loc 23 185 0
 5624              	@ 185 "../Libmaple/libmaple/libmaple/nvic.h" 1
 5625 0150 62B6     		cpsie i
 5626              	@ 0 "" 2
 5627              		.thumb
 5628 0152 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5629              	.L336:
 5630 0156 00BF     		.align	2
 5631              	.L335:
 5632 0158 00000000 		.word	.LANCHOR60
 5633 015c 00000000 		.word	.LANCHOR8
 5634 0160 00000000 		.word	.LANCHOR9
 5635 0164 CDCCCC3D 		.word	1036831949
 5636 0168 0000B442 		.word	1119092736
 5637 016c 00007A43 		.word	1132068864
 5638 0170 000048C2 		.word	-1035468800
 5639 0174 00004842 		.word	1112014848
 5640 0178 00000000 		.word	.LANCHOR12
 5641 017c 00000000 		.word	.LANCHOR65
 5642 0180 00000000 		.word	.LANCHOR77
 5643 0184 00000000 		.word	.LANCHOR59
 5644 0188 00000000 		.word	.LANCHOR68
 5645 018c 00000000 		.word	.LANCHOR33
 5646 0190 CDCC4C40 		.word	1078774989
 5647 0194 00000000 		.word	.LANCHOR7
 5648              	.LBE326:
 5649              	.LBE325:
 5650              	.LBE319:
 5651              		.cfi_endproc
 5652              	.LFE197:
 5654              		.section	.text._Z25initSensorsZeroFromEEPROMv,"ax",%progbits
 5655              		.align	1
 5656              		.global	_Z25initSensorsZeroFromEEPROMv
 5657              		.thumb
 5658              		.thumb_func
 5660              	_Z25initSensorsZeroFromEEPROMv:
 5661              	.LFB198:
 407:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 408:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 409:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #if defined (UseGPSNavigator)
 410:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(missionNbPoint, GPS_MISSION_NB_POINT_ADR);
 411:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSROLL_PID_IDX, GPSROLL_PID_GAIN_ADR);
 412:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSPITCH_PID_IDX, GPSPITCH_PID_GAIN_ADR);
 413:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writePID(GPSYAW_PID_IDX, GPSYAW_PID_GAIN_ADR);
 414:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     
 415:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     for (byte location = 0; location < MAX_WAYPOINTS; location++) {
 416:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].longitude, WAYPOINT_ADR[location].longitude);
 417:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].latitude, WAYPOINT_ADR[location].latitude);
 418:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       writeLong(waypoint[location].altitude, WAYPOINT_ADR[location].altitude);
 419:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     }       
 420:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif
 421:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 422:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     // Camera Control
 423:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #ifdef CameraControl
 424:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(cameraMode, CAMERAMODE_ADR);
 425:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraPitch, MCAMERAPITCH_ADR);
 426:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraRoll, MCAMERAROLL_ADR);    
 427:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(mCameraYaw, MCAMERAYAW_ADR);
 428:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterPitch, SERVOCENTERPITCH_ADR);
 429:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterRoll, SERVOCENTERROLL_ADR);
 430:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoCenterYaw, SERVOCENTERYAW_ADR);
 431:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinPitch, SERVOMINPITCH_ADR);
 432:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinRoll, SERVOMINROLL_ADR);
 433:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMinYaw, SERVOMINYAW_ADR);
 434:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxPitch, SERVOMAXPITCH_ADR);
 435:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxRoll, SERVOMAXROLL_ADR);
 436:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     writeFloat(servoMaxYaw, SERVOMAXYAW_ADR);
 437:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #ifdef CameraTXControl
 438:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****       writeFloat(servoTXChannels, SERVOTXCHANNELS_ADR);
 439:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     #endif
 440:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   #endif 
 441:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   sei(); // Restart interrupts
 442:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 443:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 444:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initSensorsZeroFromEEPROM() {
 5662              		.loc 22 444 0
 5663              		.cfi_startproc
 5664              		@ args = 0, pretend = 0, frame = 0
 5665              		@ frame_needed = 0, uses_anonymous_args = 0
 5666 0000 38B5     		push	{r3, r4, r5, lr}
 5667              	.LCFI51:
 5668              		.cfi_def_cfa_offset 16
 5669              		.cfi_offset 3, -16
 5670              		.cfi_offset 4, -12
 5671              		.cfi_offset 5, -8
 5672              		.cfi_offset 14, -4
 445:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 446:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel initialization from EEPROM
 447:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 5673              		.loc 22 447 0
 5674 0002 4FF49670 		mov	r0, #300
 5675 0006 FFF7FEFF 		bl	_Z12nvrReadFloati
 5676              	.LVL420:
 5677 000a 114B     		ldr	r3, .L338
 448:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel calibration
 449:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = readFloat(XAXIS_ACCEL_SCALE_FACTOR_ADR);
 5678              		.loc 22 449 0
 5679 000c 114D     		ldr	r5, .L338+4
 447:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = readFloat(ACCEL_1G_ADR);
 5680              		.loc 22 447 0
 5681 000e 1860     		str	r0, [r3, #0]	@ float
 5682              		.loc 22 449 0
 5683 0010 4FF4A670 		mov	r0, #332
 5684 0014 FFF7FEFF 		bl	_Z12nvrReadFloati
 5685              	.LVL421:
 5686 0018 2860     		str	r0, [r5, #0]	@ float
 450:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = readFloat(XAXIS_ACCEL_BIAS_ADR);
 5687              		.loc 22 450 0
 5688 001a 4FF4A470 		mov	r0, #328
 5689 001e FFF7FEFF 		bl	_Z12nvrReadFloati
 5690              	.LVL422:
 5691 0022 0D4C     		ldr	r4, .L338+8
 5692 0024 2060     		str	r0, [r4, #0]	@ float
 451:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = readFloat(YAXIS_ACCEL_SCALE_FACTOR_ADR);
 5693              		.loc 22 451 0
 5694 0026 4FF4AA70 		mov	r0, #340
 5695 002a FFF7FEFF 		bl	_Z12nvrReadFloati
 5696              	.LVL423:
 5697 002e 6860     		str	r0, [r5, #4]	@ float
 452:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = readFloat(YAXIS_ACCEL_BIAS_ADR);
 5698              		.loc 22 452 0
 5699 0030 4FF4A870 		mov	r0, #336
 5700 0034 FFF7FEFF 		bl	_Z12nvrReadFloati
 5701              	.LVL424:
 5702 0038 6060     		str	r0, [r4, #4]	@ float
 453:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = readFloat(ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 5703              		.loc 22 453 0
 5704 003a 4FF4AE70 		mov	r0, #348
 5705 003e FFF7FEFF 		bl	_Z12nvrReadFloati
 5706              	.LVL425:
 5707 0042 A860     		str	r0, [r5, #8]	@ float
 454:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = readFloat(ZAXIS_ACCEL_BIAS_ADR);
 5708              		.loc 22 454 0
 5709 0044 4FF4AC70 		mov	r0, #344
 5710 0048 FFF7FEFF 		bl	_Z12nvrReadFloati
 5711              	.LVL426:
 5712 004c A060     		str	r0, [r4, #8]	@ float
 5713 004e 38BD     		pop	{r3, r4, r5, pc}
 5714              	.L339:
 5715              		.align	2
 5716              	.L338:
 5717 0050 00000000 		.word	.LANCHOR33
 5718 0054 00000000 		.word	.LANCHOR29
 5719 0058 00000000 		.word	.LANCHOR30
 5720              		.cfi_endproc
 5721              	.LFE198:
 5723              		.section	.text._Z24storeSensorsZeroToEEPROMv,"ax",%progbits
 5724              		.align	1
 5725              		.global	_Z24storeSensorsZeroToEEPROMv
 5726              		.thumb
 5727              		.thumb_func
 5729              	_Z24storeSensorsZeroToEEPROMv:
 5730              	.LFB199:
 455:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 456:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 457:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void storeSensorsZeroToEEPROM() {
 5731              		.loc 22 457 0
 5732              		.cfi_startproc
 5733              		@ args = 0, pretend = 0, frame = 0
 5734              		@ frame_needed = 0, uses_anonymous_args = 0
 5735 0000 38B5     		push	{r3, r4, r5, lr}
 5736              	.LCFI52:
 5737              		.cfi_def_cfa_offset 16
 5738              		.cfi_offset 3, -16
 5739              		.cfi_offset 4, -12
 5740              		.cfi_offset 5, -8
 5741              		.cfi_offset 14, -4
 458:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 459:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Store accel data to EEPROM
 460:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 5742              		.loc 22 460 0
 5743 0002 144B     		ldr	r3, .L341
 461:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   // Accel Cal
 462:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 5744              		.loc 22 462 0
 5745 0004 144D     		ldr	r5, .L341+4
 460:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 5746              		.loc 22 460 0
 5747 0006 1868     		ldr	r0, [r3, #0]	@ float
 463:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[XAXIS], XAXIS_ACCEL_BIAS_ADR);
 5748              		.loc 22 463 0
 5749 0008 144C     		ldr	r4, .L341+8
 460:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelOneG, ACCEL_1G_ADR);
 5750              		.loc 22 460 0
 5751 000a 4FF49671 		mov	r1, #300
 5752 000e FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5753              	.LVL427:
 462:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[XAXIS], XAXIS_ACCEL_SCALE_FACTOR_ADR);
 5754              		.loc 22 462 0
 5755 0012 2868     		ldr	r0, [r5, #0]	@ float
 5756 0014 4FF4A671 		mov	r1, #332
 5757 0018 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5758              	.LVL428:
 5759              		.loc 22 463 0
 5760 001c 2068     		ldr	r0, [r4, #0]	@ float
 5761 001e 4FF4A471 		mov	r1, #328
 5762 0022 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5763              	.LVL429:
 464:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[YAXIS], YAXIS_ACCEL_SCALE_FACTOR_ADR);
 5764              		.loc 22 464 0
 5765 0026 6868     		ldr	r0, [r5, #4]	@ float
 5766 0028 4FF4AA71 		mov	r1, #340
 5767 002c FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5768              	.LVL430:
 465:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[YAXIS], YAXIS_ACCEL_BIAS_ADR);
 5769              		.loc 22 465 0
 5770 0030 6068     		ldr	r0, [r4, #4]	@ float
 5771 0032 4FF4A871 		mov	r1, #336
 5772 0036 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5773              	.LVL431:
 466:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(accelScaleFactor[ZAXIS], ZAXIS_ACCEL_SCALE_FACTOR_ADR);
 5774              		.loc 22 466 0
 5775 003a A868     		ldr	r0, [r5, #8]	@ float
 5776 003c 4FF4AE71 		mov	r1, #348
 5777 0040 FFF7FEFF 		bl	_Z13nvrWriteFloatfi
 5778              	.LVL432:
 467:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 5779              		.loc 22 467 0
 5780 0044 A068     		ldr	r0, [r4, #8]	@ float
 5781 0046 4FF4AC71 		mov	r1, #344
 468:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 5782              		.loc 22 468 0
 5783 004a BDE83840 		pop	{r3, r4, r5, lr}
 467:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   writeFloat(runTimeAccelBias[ZAXIS], ZAXIS_ACCEL_BIAS_ADR);
 5784              		.loc 22 467 0
 5785 004e FFF7FEBF 		b	_Z13nvrWriteFloatfi
 5786              	.LVL433:
 5787              	.L342:
 5788 0052 00BF     		.align	2
 5789              	.L341:
 5790 0054 00000000 		.word	.LANCHOR33
 5791 0058 00000000 		.word	.LANCHOR29
 5792 005c 00000000 		.word	.LANCHOR30
 5793              		.cfi_endproc
 5794              	.LFE199:
 5796              		.section	.text._Z16initializeEEPROMv,"ax",%progbits
 5797              		.align	1
 5798              		.global	_Z16initializeEEPROMv
 5799              		.thumb
 5800              		.thumb_func
 5802              	_Z16initializeEEPROMv:
 5803              	.LFB195:
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5804              		.loc 22 124 0
 5805              		.cfi_startproc
 5806              		@ args = 0, pretend = 0, frame = 0
 5807              		@ frame_needed = 0, uses_anonymous_args = 0
 5808 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5809              	.LCFI53:
 5810              		.cfi_def_cfa_offset 24
 5811              		.cfi_offset 3, -24
 5812              		.cfi_offset 4, -20
 5813              		.cfi_offset 5, -16
 5814              		.cfi_offset 6, -12
 5815              		.cfi_offset 7, -8
 5816              		.cfi_offset 14, -4
 5817              	.LBB327:
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 5818              		.loc 22 126 0
 5819 0002 2E48     		ldr	r0, .L346
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 5820              		.loc 22 125 0
 5821 0004 2E4B     		ldr	r3, .L346+4
 5822 0006 2F49     		ldr	r1, .L346+8
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].I = 150.0;
 5823              		.loc 22 126 0
 5824 0008 5860     		str	r0, [r3, #4]	@ float
 129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].I = 150.0;
 5825              		.loc 22 129 0
 5826 000a D861     		str	r0, [r3, #28]	@ float
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 5827              		.loc 22 131 0
 5828 000c 2E48     		ldr	r0, .L346+12
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 5829              		.loc 22 127 0
 5830 000e 2F4A     		ldr	r2, .L346+16
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].P = 3.5;
 5831              		.loc 22 131 0
 5832 0010 9864     		str	r0, [r3, #72]	@ float
 134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].P = 3.5;
 5833              		.loc 22 134 0
 5834 0012 1866     		str	r0, [r3, #96]	@ float
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 5835              		.loc 22 137 0
 5836 0014 2E48     		ldr	r0, .L346+20
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 5837              		.loc 22 138 0
 5838 0016 2F4E     		ldr	r6, .L346+24
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].P = 200.0;
 5839              		.loc 22 137 0
 5840 0018 1863     		str	r0, [r3, #48]	@ float
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 5841              		.loc 22 140 0
 5842 001a 2F48     		ldr	r0, .L346+28
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].P = 100.0;
 5843              		.loc 22 125 0
 5844 001c 1960     		str	r1, [r3, #0]	@ float
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].P = 3.0;
 5845              		.loc 22 140 0
 5846 001e 9867     		str	r0, [r3, #120]	@ float
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 5847              		.loc 22 141 0
 5848 0020 2E48     		ldr	r0, .L346+32
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_XAXIS_PID_IDX].D = -350.0;
 5849              		.loc 22 127 0
 5850 0022 9A60     		str	r2, [r3, #8]	@ float
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 5851              		.loc 22 132 0
 5852 0024 0024     		movs	r4, #0
 128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].P = 100.0;
 5853              		.loc 22 128 0
 5854 0026 9961     		str	r1, [r3, #24]	@ float
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].I = 0.1;
 5855              		.loc 22 141 0
 5856 0028 D867     		str	r0, [r3, #124]	@ float
 144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].P = 100.0;
 5857              		.loc 22 144 0
 5858 002a C3F89010 		str	r1, [r3, #144]	@ float
 147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].P = 100.0;
 5859              		.loc 22 147 0
 5860 002e C3F8A810 		str	r1, [r3, #168]	@ float
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[RATE_YAXIS_PID_IDX].D = -350.0;
 5861              		.loc 22 130 0
 5862 0032 1A62     		str	r2, [r3, #32]	@ float
 146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].D = -350.0;
 5863              		.loc 22 146 0
 5864 0034 C3F89820 		str	r2, [r3, #152]	@ float
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].D = -350.0;
 5865              		.loc 22 149 0
 5866 0038 C3F8B020 		str	r2, [r3, #176]	@ float
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].I = 0.0;
 5867              		.loc 22 132 0
 5868 003c DC64     		str	r4, [r3, #76]	@ float
 133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_XAXIS_PID_IDX].D = 0.0;
 5869              		.loc 22 133 0
 5870 003e 1C65     		str	r4, [r3, #80]	@ float
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].I = 0.0;
 5871              		.loc 22 135 0
 5872 0040 5C66     		str	r4, [r3, #100]	@ float
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_YAXIS_PID_IDX].D = 0.0;
 5873              		.loc 22 136 0
 5874 0042 9C66     		str	r4, [r3, #104]	@ float
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].I = 5.0;
 5875              		.loc 22 138 0
 5876 0044 5E63     		str	r6, [r3, #52]	@ float
 139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ZAXIS_PID_IDX].D = 0.0;
 5877              		.loc 22 139 0
 5878 0046 9C63     		str	r4, [r3, #56]	@ float
 142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[HEADING_HOLD_PID_IDX].D = 0.0;
 5879              		.loc 22 142 0
 5880 0048 C3F88040 		str	r4, [r3, #128]	@ float
 145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_XAXIS_PID_IDX].I = 0.0;
 5881              		.loc 22 145 0
 5882 004c C3F89440 		str	r4, [r3, #148]	@ float
 148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   PID[ATTITUDE_GYRO_YAXIS_PID_IDX].I = 0.0;
 5883              		.loc 22 148 0
 5884 0050 C3F8AC40 		str	r4, [r3, #172]	@ float
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = 1.0;
 5885              		.loc 22 150 0
 5886 0054 224B     		ldr	r3, .L346+36
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 5887              		.loc 22 152 0
 5888 0056 234A     		ldr	r2, .L346+40
 5889              	.LBB328:
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5890              		.loc 22 124 0
 5891 0058 234F     		ldr	r7, .L346+44
 5892              	.LBE328:
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   rotationSpeedFactor = 1.0;
 5893              		.loc 22 150 0
 5894 005a 4FF07E55 		mov	r5, #1065353216
 5895 005e 1D60     		str	r5, [r3, #0]	@ float
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0;
 5896              		.loc 22 153 0
 5897 0060 224B     		ldr	r3, .L346+48
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[XAXIS] = 1.0;
 5898              		.loc 22 152 0
 5899 0062 1560     		str	r5, [r2, #0]	@ float
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[XAXIS] = 0;
 5900              		.loc 22 153 0
 5901 0064 1C60     		str	r4, [r3, #0]	@ float
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[YAXIS] = 1.0;
 5902              		.loc 22 154 0
 5903 0066 5560     		str	r5, [r2, #4]	@ float
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[YAXIS] = 0;
 5904              		.loc 22 155 0
 5905 0068 5C60     		str	r4, [r3, #4]	@ float
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelScaleFactor[ZAXIS] = 1.0;
 5906              		.loc 22 156 0
 5907 006a 9560     		str	r5, [r2, #8]	@ float
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   runTimeAccelBias[ZAXIS] = 0;
 5908              		.loc 22 157 0
 5909 006c 9C60     		str	r4, [r3, #8]	@ float
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   storeSensorsZeroToEEPROM();
 5910              		.loc 22 158 0
 5911 006e FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 5912              	.LVL434:
 185:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   initializePlatformSpecificAccelCalibration();
 5913              		.loc 22 185 0
 5914 0072 FFF7FEFF 		bl	_Z42initializePlatformSpecificAccelCalibrationv
 5915              	.LVL435:
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = 1.0;
 5916              		.loc 22 187 0
 5917 0076 1E4B     		ldr	r3, .L346+52
 5918              	.LBB329:
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5919              		.loc 22 124 0
 5920 0078 1E48     		ldr	r0, .L346+56
 5921              	.LBE329:
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = 1.0;
 5922              		.loc 22 187 0
 5923 007a 1D60     		str	r5, [r3, #0]	@ float
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 5924              		.loc 22 188 0
 5925 007c 1E4B     		ldr	r3, .L346+60
 5926              	.LBB330:
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5927              		.loc 22 124 0
 5928 007e 1F49     		ldr	r1, .L346+64
 5929              	.LBE330:
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   minArmedThrottle = 1150;
 5930              		.loc 22 188 0
 5931 0080 40F27E42 		movw	r2, #1150
 5932 0084 1A60     		str	r2, [r3, #0]
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   accelOneG = -9.80665; // AKA set one G to 9.8 m/s^2
 5933              		.loc 22 190 0
 5934 0086 1E4B     		ldr	r3, .L346+68
 5935 0088 1E4A     		ldr	r2, .L346+72
 5936 008a 1A60     		str	r2, [r3, #0]	@ float
 5937              	.LVL436:
 5938 008c 0023     		movs	r3, #0
 5939              	.LVL437:
 5940              	.L344:
 5941              	.LBB331:
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5942              		.loc 22 124 0 discriminator 2
 5943 008e FA18     		adds	r2, r7, r3
 192:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = 1.0;
 5944              		.loc 22 192 0 discriminator 2
 5945 0090 1560     		str	r5, [r2, #0]	@ float
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5946              		.loc 22 124 0 discriminator 2
 5947 0092 C218     		adds	r2, r0, r3
 193:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = 0.0;
 5948              		.loc 22 193 0 discriminator 2
 5949 0094 1460     		str	r4, [r2, #0]	@ float
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initializeEEPROM() {
 5950              		.loc 22 124 0 discriminator 2
 5951 0096 CA18     		adds	r2, r1, r3
 5952 0098 0433     		adds	r3, r3, #4
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 5953              		.loc 22 191 0 discriminator 2
 5954 009a 182B     		cmp	r3, #24
 194:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = 1.0;
 5955              		.loc 22 194 0 discriminator 2
 5956 009c 1560     		str	r5, [r2, #0]	@ float
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for (byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 5957              		.loc 22 191 0 discriminator 2
 5958 009e F6D1     		bne	.L344
 5959              	.LBE331:
 196:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverSmoothFactor[ZAXIS] = 0.5;
 5960              		.loc 22 196 0
 5961 00a0 164B     		ldr	r3, .L346+64
 5962 00a2 4FF07C52 		mov	r2, #1056964608
 5963 00a6 9A60     		str	r2, [r3, #8]	@ float
 198:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   flightMode = RATE_FLIGHT_MODE;
 5964              		.loc 22 198 0
 5965 00a8 174B     		ldr	r3, .L346+76
 5966 00aa 0022     		movs	r2, #0
 5967 00ac 1A70     		strb	r2, [r3, #0]
 199:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   headingHoldConfig = ON;
 5968              		.loc 22 199 0
 5969 00ae 174B     		ldr	r3, .L346+80
 5970 00b0 0122     		movs	r2, #1
 5971 00b2 1A70     		strb	r2, [r3, #0]
 200:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   aref = 5.0; // Use 3.0 if using a v1.7 shield or use 2.8 for an AeroQuad Shield < v1.7
 5972              		.loc 22 200 0
 5973 00b4 164B     		ldr	r3, .L346+84
 5974 00b6 1E60     		str	r6, [r3, #0]	@ float
 5975 00b8 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5976              	.L347:
 5977 00ba 00BF     		.align	2
 5978              	.L346:
 5979 00bc 00001643 		.word	1125515264
 5980 00c0 00000000 		.word	.LANCHOR15
 5981 00c4 0000C842 		.word	1120403456
 5982 00c8 00006040 		.word	1080033280
 5983 00cc 0000AFC3 		.word	-1011941376
 5984 00d0 00004843 		.word	1128792064
 5985 00d4 0000A040 		.word	1084227584
 5986 00d8 00004040 		.word	1077936128
 5987 00dc CDCCCC3D 		.word	1036831949
 5988 00e0 00000000 		.word	.LANCHOR60
 5989 00e4 00000000 		.word	.LANCHOR29
 5990 00e8 00000000 		.word	.LANCHOR7
 5991 00ec 00000000 		.word	.LANCHOR30
 5992 00f0 00000000 		.word	.LANCHOR12
 5993 00f4 00000000 		.word	.LANCHOR8
 5994 00f8 00000000 		.word	.LANCHOR65
 5995 00fc 00000000 		.word	.LANCHOR9
 5996 0100 00000000 		.word	.LANCHOR33
 5997 0104 0AE81CC1 		.word	-1055070198
 5998 0108 00000000 		.word	.LANCHOR59
 5999 010c 00000000 		.word	.LANCHOR68
 6000 0110 00000000 		.word	.LANCHOR77
 6001              	.LBE327:
 6002              		.cfi_endproc
 6003              	.LFE195:
 6005              		.section	.text._Z46processZeroThrottleFunctionFromReceiverCommandv,"ax",%progbits
 6006              		.align	1
 6007              		.global	_Z46processZeroThrottleFunctionFromReceiverCommandv
 6008              		.thumb
 6009              		.thumb_func
 6011              	_Z46processZeroThrottleFunctionFromReceiverCommandv:
 6012              	.LFB186:
 6013              		.file 24 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/FlightCommandProcessor.h"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  This program is free software: you can redistribute it and/or modify 
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  it under the terms of the GNU General Public License as published by 
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  the Free Software Foundation, either version 3 of the License, or 
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  (at your option) any later version. 
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  This program is distributed in the hope that it will be useful, 
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  but WITHOUT ANY WARRANTY; without even the implied warranty of 
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  GNU General Public License for more details. 
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  You should have received a copy of the GNU General Public License 
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  along with this program. If not, see <http://www.gnu.org/licenses/>. 
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** // FlightCommandProcessor is responsible for decoding transmitter stick combinations
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** // for setting up AeroQuad modes such as motor arming and disarming
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #ifndef _AQ_FLIGHT_COMMAND_READER_
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #define _AQ_FLIGHT_COMMAND_READER_
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #if defined (AltitudeHoldBaro) || defined (AltitudeHoldRangeFinder)
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   boolean isPositionHoldEnabledByUser() {
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #if defined (UseGPSNavigator)
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if ((receiverCommand[AUX1] < 1750) || (receiverCommand[AUX2] < 1750)) {
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         return true;
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       return false;
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #else
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (receiverCommand[AUX1] < 1750) {
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         return true;
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       return false;
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #endif
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #endif
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   void processAltitudeHoldStateFromReceiverCommand() {
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (isPositionHoldEnabledByUser()) {
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (!isAltitudeHoldInitialized) {
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = estimatedAltitude;//getBaroAltitude();
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           isAltitudeHoldInitialized = true;
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         altitudeHoldState = ON;
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     } 
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else {
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isAltitudeHoldInitialized = false;
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       altitudeHoldState = OFF;
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #endif
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #if defined (AutoLanding)
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   void processAutoLandingStateFromReceiverCommand() {
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[AUX3] < 1750) {
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (altitudeHoldState != ALTPANIC ) {  // check for special condition with manditory override
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (isAutoLandingInitialized) {
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           autoLandingState = BARO_AUTO_DESCENT_STATE;
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldBaro
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             baroAltitudeToHoldTarget = getBaroAltitude();
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[BARO_ALTITUDE_HOLD_PID_IDX].lastError = baroAltitudeToHoldTarget;
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #if defined AltitudeHoldRangeFinder
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             sonarAltitudeToHoldTarget = rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX];
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].integratedError = 0;
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****             PID[SONAR_ALTITUDE_HOLD_PID_IDX].lastError = sonarAltitudeToHoldTarget;
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           #endif
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldThrottle = receiverCommand[THROTTLE];
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           isAutoLandingInitialized = true;
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
  94:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         altitudeHoldState = ON;
  95:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
  96:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
  97:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else {
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       autoLandingState = OFF;
  99:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       autoLandingThrottleCorrection = 0;
 100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isAutoLandingInitialized = false;
 101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #if defined (UseGPSNavigator)
 102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if ((receiverCommand[AUX1] > 1750) && (receiverCommand[AUX2] > 1750)) {
 103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldState = OFF;
 104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           isAltitudeHoldInitialized = false;
 105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
 106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #else
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         if (receiverCommand[AUX1] > 1750) {
 108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           altitudeHoldState = OFF;
 109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****           isAltitudeHoldInitialized = false;
 110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         }
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       #endif
 112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #endif
 115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 117:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #if defined (UseGPSNavigator)
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   void processGpsNavigationStateFromReceiverCommand() {
 119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Init home command
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (motorArmed == OFF && 
 121:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         receiverCommand[THROTTLE] < MINCHECK && receiverCommand[ZAXIS] < MINCHECK &&
 122:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         receiverCommand[YAXIS] > MAXCHECK && receiverCommand[XAXIS] > MAXCHECK &&
 123:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         haveAGpsLock()) {
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       homePosition.latitude = currentPosition.latitude;
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       homePosition.longitude = currentPosition.longitude;
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       homePosition.altitude = DEFAULT_HOME_ALTITUDE;
 128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[AUX2] < 1750) {  // Enter in execute mission state, if none, go back home, 
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (isInitNavigationNeeded) {
 133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         
 134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         gpsRollAxisCorrection = 0;
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         gpsPitchAxisCorrection = 0;
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         gpsYawAxisCorrection = 0;
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         isInitNavigationNeeded = false;
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
 139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       positionHoldState = OFF;         // disable the position hold while navigating
 142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isStorePositionNeeded = true;
 143:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       navigationState = ON;
 145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else if (receiverCommand[AUX1] < 1250) {  // Enter in position hold state
 147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (isStorePositionNeeded) {
 148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         gpsRollAxisCorrection = 0;
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         gpsPitchAxisCorrection = 0;
 151:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         gpsYawAxisCorrection = 0;
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         positionHoldPointToReach.latitude = currentPosition.latitude;
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         positionHoldPointToReach.longitude = currentPosition.longitude;
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         positionHoldPointToReach.altitude = getBaroAltitude();
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         isStorePositionNeeded = false;
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 159:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isInitNavigationNeeded = true;  // disable navigation
 160:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       navigationState = OFF;
 161:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 162:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       positionHoldState = ON;
 163:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else {
 165:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       // Navigation and position hold are disabled
 166:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       positionHoldState = OFF;
 167:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isStorePositionNeeded = true;
 168:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 169:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       navigationState = OFF;
 170:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       isInitNavigationNeeded = true;
 171:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 172:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       gpsRollAxisCorrection = 0;
 173:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       gpsPitchAxisCorrection = 0;
 174:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       gpsYawAxisCorrection = 0;
 175:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 176:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 177:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** #endif
 178:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 179:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 180:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 181:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 182:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** void processZeroThrottleFunctionFromReceiverCommand() {
 6014              		.loc 24 182 0
 6015              		.cfi_startproc
 6016              		@ args = 0, pretend = 0, frame = 0
 6017              		@ frame_needed = 0, uses_anonymous_args = 0
 6018              	.LBB332:
 183:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   // Disarm motors (left stick lower left corner)
 184:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] < MINCHECK && motorArmed == ON) {
 6019              		.loc 24 184 0
 6020 0000 274A     		ldr	r2, .L353
 6021 0002 9168     		ldr	r1, [r2, #8]
 6022 0004 40F24B43 		movw	r3, #1099
 6023 0008 9942     		cmp	r1, r3
 6024              	.LBE332:
 182:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** void processZeroThrottleFunctionFromReceiverCommand() {
 6025              		.loc 24 182 0
 6026 000a 70B5     		push	{r4, r5, r6, lr}
 6027              	.LCFI54:
 6028              		.cfi_def_cfa_offset 16
 6029              		.cfi_offset 4, -16
 6030              		.cfi_offset 5, -12
 6031              		.cfi_offset 6, -8
 6032              		.cfi_offset 14, -4
 6033 000c 1546     		mov	r5, r2
 6034 000e 1E46     		mov	r6, r3
 6035              	.LBB337:
 6036              		.loc 24 184 0
 6037 0010 0BDC     		bgt	.L349
 6038              		.loc 24 184 0 is_stmt 0 discriminator 1
 6039 0012 244C     		ldr	r4, .L353+4
 6040 0014 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 6041 0016 012B     		cmp	r3, #1
 6042 0018 07D1     		bne	.L349
 185:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     commandAllMotors(MINCOMMAND);
 6043              		.loc 24 185 0 is_stmt 1
 6044 001a 4FF47A70 		mov	r0, #1000
 6045 001e FFF7FEFF 		bl	_Z16commandAllMotorsi
 6046              	.LVL438:
 186:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     motorArmed = OFF;
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     inFlight = false;
 6047              		.loc 24 187 0
 6048 0022 214A     		ldr	r2, .L353+8
 186:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     motorArmed = OFF;
 6049              		.loc 24 186 0
 6050 0024 0023     		movs	r3, #0
 6051 0026 2370     		strb	r3, [r4, #0]
 6052              		.loc 24 187 0
 6053 0028 1370     		strb	r3, [r2, #0]
 6054              	.L349:
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 189:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #ifdef OSD
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       notifyOSD(OSD_CENTER|OSD_WARN, "MOTORS UNARMED");
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #endif
 192:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 193:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #if defined BattMonitorAutoDescent
 194:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       batteryMonitorAlarmCounter = 0;
 195:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       batteryMonitorStartThrottle = 0;
 196:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       batteyMonitorThrottleCorrection = 0.0;
 197:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #endif
 198:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }    
 199:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 200:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   // Zero Gyro and Accel sensors (left stick lower left, right stick lower right corner)
 201:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if ((receiverCommand[ZAXIS] < MINCHECK) && (receiverCommand[XAXIS] > MAXCHECK) && (receiverComman
 6055              		.loc 24 201 0
 6056 002a AA68     		ldr	r2, [r5, #8]
 6057 002c 1C4B     		ldr	r3, .L353
 6058 002e B242     		cmp	r2, r6
 6059 0030 14DC     		bgt	.L350
 6060              		.loc 24 201 0 is_stmt 0 discriminator 1
 6061 0032 1A68     		ldr	r2, [r3, #0]
 6062 0034 40F26C71 		movw	r1, #1900
 6063 0038 8A42     		cmp	r2, r1
 6064 003a 0FDD     		ble	.L350
 6065              		.loc 24 201 0 discriminator 2
 6066 003c 5A68     		ldr	r2, [r3, #4]
 6067 003e 40F24B43 		movw	r3, #1099
 6068 0042 9A42     		cmp	r2, r3
 6069 0044 0ADC     		bgt	.L350
 202:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     calibrateGyro();
 6070              		.loc 24 202 0 is_stmt 1
 6071 0046 FFF7FEFF 		bl	_Z13calibrateGyrov
 6072              	.LVL439:
 203:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     computeAccelBias();
 6073              		.loc 24 203 0
 6074 004a FFF7FEFF 		bl	_Z16computeAccelBiasv
 6075              	.LVL440:
 204:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     storeSensorsZeroToEEPROM();
 6076              		.loc 24 204 0
 6077 004e FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 6078              	.LVL441:
 205:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     calibrateKinematics();
 206:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     zeroIntegralError();
 6079              		.loc 24 206 0
 6080 0052 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 6081              	.LVL442:
 207:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     pulseMotors(3);
 6082              		.loc 24 207 0
 6083 0056 0320     		movs	r0, #3
 6084 0058 FFF7FEFF 		bl	_Z11pulseMotorsh
 6085              	.LVL443:
 6086              	.L350:
 6087              	.LBB333:
 208:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }   
 209:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 210:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   // Arm motors (left stick lower right corner)
 211:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] > MAXCHECK && motorArmed == OFF && safetyCheck == ON) {
 6088              		.loc 24 211 0
 6089 005c 104B     		ldr	r3, .L353
 6090 005e 9A68     		ldr	r2, [r3, #8]
 6091 0060 40F26C73 		movw	r3, #1900
 6092 0064 9A42     		cmp	r2, r3
 6093 0066 10DD     		ble	.L351
 6094              		.loc 24 211 0 is_stmt 0 discriminator 1
 6095 0068 0E49     		ldr	r1, .L353+4
 6096 006a 0B78     		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6097 006c 6BB9     		cbnz	r3, .L351
 6098              		.loc 24 211 0 discriminator 2
 6099 006e 0F4B     		ldr	r3, .L353+12
 6100 0070 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 6101 0072 0128     		cmp	r0, #1
 6102 0074 09D1     		bne	.L351
 6103              	.LVL444:
 6104              	.LBB334:
 6105              	.LBB335:
 212:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 213:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #ifdef OSD_SYSTEM_MENU
 214:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       if (menuOwnsSticks) {
 215:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         return;
 216:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       }
 217:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #endif
 218:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 219:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 220:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorCommand[motor] = MINTHROTTLE;
 6106              		.loc 24 220 0 is_stmt 1 discriminator 1
 6107 0076 0E4B     		ldr	r3, .L353+16
 6108              	.LBE335:
 221:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 222:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     motorArmed = ON;
 6109              		.loc 24 222 0 discriminator 1
 6110 0078 0870     		strb	r0, [r1, #0]
 6111              	.LBB336:
 220:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       motorCommand[motor] = MINTHROTTLE;
 6112              		.loc 24 220 0 discriminator 1
 6113 007a 40F24C42 		movw	r2, #1100
 6114 007e 1A60     		str	r2, [r3, #0]
 6115              	.LVL445:
 6116 0080 5A60     		str	r2, [r3, #4]
 6117              	.LVL446:
 6118 0082 9A60     		str	r2, [r3, #8]
 6119              	.LVL447:
 6120 0084 DA60     		str	r2, [r3, #12]
 6121              	.LVL448:
 6122              	.LBE336:
 223:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 224:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #ifdef OSD
 225:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       notifyOSD(OSD_CENTER|OSD_WARN, "!MOTORS ARMED!");
 226:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     #endif  
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     zeroIntegralError();
 6123              		.loc 24 228 0 discriminator 1
 6124 0086 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 6125              	.LVL449:
 6126              	.L351:
 6127              	.LBE334:
 6128              	.LBE333:
 229:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 230:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 231:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   // Prevents accidental arming of motor output if no transmitter command received
 232:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[ZAXIS] > MINCHECK) {
 6129              		.loc 24 232 0
 6130 008a 054B     		ldr	r3, .L353
 6131 008c 9A68     		ldr	r2, [r3, #8]
 6132 008e 40F24C43 		movw	r3, #1100
 6133 0092 9A42     		cmp	r2, r3
 6134 0094 02DD     		ble	.L348
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     safetyCheck = ON; 
 6135              		.loc 24 233 0
 6136 0096 054B     		ldr	r3, .L353+12
 6137 0098 0122     		movs	r2, #1
 6138 009a 1A70     		strb	r2, [r3, #0]
 6139              	.L348:
 6140 009c 70BD     		pop	{r4, r5, r6, pc}
 6141              	.L354:
 6142 009e 00BF     		.align	2
 6143              	.L353:
 6144 00a0 00000000 		.word	.LANCHOR4
 6145 00a4 00000000 		.word	.LANCHOR76
 6146 00a8 00000000 		.word	.LANCHOR14
 6147 00ac 00000000 		.word	.LANCHOR64
 6148 00b0 00000000 		.word	.LANCHOR54
 6149              	.LBE337:
 6150              		.cfi_endproc
 6151              	.LFE186:
 6153              		.section	.text._Z17readPilotCommandsv,"ax",%progbits
 6154              		.align	1
 6155              		.global	_Z17readPilotCommandsv
 6156              		.thumb
 6157              		.thumb_func
 6159              	_Z17readPilotCommandsv:
 6160              	.LFB187:
 234:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 235:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** }
 236:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 237:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 238:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 239:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 240:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** /**
 241:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * readPilotCommands
 242:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * 
 243:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * This function is responsible to read receiver
 244:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  * and process command from the users
 245:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****  */
 246:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** void readPilotCommands() {
 6161              		.loc 24 246 0
 6162              		.cfi_startproc
 6163              		@ args = 0, pretend = 0, frame = 0
 6164              		@ frame_needed = 0, uses_anonymous_args = 0
 6165 0000 10B5     		push	{r4, lr}
 6166              	.LCFI55:
 6167              		.cfi_def_cfa_offset 8
 6168              		.cfi_offset 4, -8
 6169              		.cfi_offset 14, -4
 247:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 248:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   readReceiver(); 
 6170              		.loc 24 248 0
 6171 0002 FFF7FEFF 		bl	_Z12readReceiverv
 6172              	.LVL450:
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   
 250:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (receiverCommand[THROTTLE] < MINCHECK) {
 6173              		.loc 24 250 0
 6174 0006 154B     		ldr	r3, .L362
 6175 0008 DA68     		ldr	r2, [r3, #12]
 6176 000a 40F24B43 		movw	r3, #1099
 6177 000e 9A42     		cmp	r2, r3
 6178 0010 01DC     		bgt	.L356
 251:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     processZeroThrottleFunctionFromReceiverCommand();
 6179              		.loc 24 251 0
 6180 0012 FFF7FEFF 		bl	_Z46processZeroThrottleFunctionFromReceiverCommandv
 6181              	.LVL451:
 6182              	.L356:
 252:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 253:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 254:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   if (!inFlight) {
 6183              		.loc 24 254 0
 6184 0016 124A     		ldr	r2, .L362+4
 6185 0018 104B     		ldr	r3, .L362
 6186 001a 1178     		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 6187 001c 49B9     		cbnz	r1, .L357
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (motorArmed == ON && receiverCommand[THROTTLE] > minArmedThrottle) {
 6188              		.loc 24 255 0
 6189 001e 1149     		ldr	r1, .L362+8
 6190 0020 0978     		ldrb	r1, [r1, #0]	@ zero_extendqisi2
 6191 0022 0129     		cmp	r1, #1
 6192 0024 05D1     		bne	.L357
 6193              		.loc 24 255 0 is_stmt 0 discriminator 1
 6194 0026 104C     		ldr	r4, .L362+12
 6195 0028 D868     		ldr	r0, [r3, #12]
 6196 002a 2468     		ldr	r4, [r4, #0]
 6197 002c A042     		cmp	r0, r4
 256:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       inFlight = true;
 6198              		.loc 24 256 0 is_stmt 1 discriminator 1
 6199 002e C8BF     		it	gt
 6200 0030 1170     		strbgt	r1, [r2, #0]
 6201              	.L357:
 257:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 258:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****   }
 259:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h **** 
 260:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     // Check Mode switch for Acro or Stable
 261:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (receiverCommand[MODE] > 1500) {
 6202              		.loc 24 261 0
 6203 0032 1A69     		ldr	r2, [r3, #16]
 6204 0034 40F2DC53 		movw	r3, #1500
 6205 0038 9A42     		cmp	r2, r3
 6206 003a 0C4B     		ldr	r3, .L362+16
 6207 003c 01DD     		ble	.L358
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         flightMode = ATTITUDE_FLIGHT_MODE;
 6208              		.loc 24 262 0
 6209 003e 0122     		movs	r2, #1
 6210 0040 00E0     		b	.L361
 6211              	.L358:
 263:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 264:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     else {
 265:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         flightMode = RATE_FLIGHT_MODE;
 6212              		.loc 24 265 0
 6213 0042 0022     		movs	r2, #0
 6214              	.L361:
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     }
 267:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     
 268:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****     if (previousFlightMode != flightMode) {
 6215              		.loc 24 268 0
 6216 0044 0A4C     		ldr	r4, .L362+20
 265:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****         flightMode = RATE_FLIGHT_MODE;
 6217              		.loc 24 265 0
 6218 0046 1A70     		strb	r2, [r3, #0]
 6219              		.loc 24 268 0
 6220 0048 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6221 004a 2278     		ldrb	r2, [r4, #0]	@ zero_extendqisi2
 6222 004c 9A42     		cmp	r2, r3
 6223 004e 04D0     		beq	.L355
 269:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       zeroIntegralError();
 6224              		.loc 24 269 0
 6225 0050 FFF7FEFF 		bl	_Z17zeroIntegralErrorv
 6226              	.LVL452:
 270:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\FlightCommandProcessor.h ****       previousFlightMode = flightMode;
 6227              		.loc 24 270 0
 6228 0054 054B     		ldr	r3, .L362+16
 6229 0056 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 6230 0058 2370     		strb	r3, [r4, #0]
 6231              	.L355:
 6232 005a 10BD     		pop	{r4, pc}
 6233              	.L363:
 6234              		.align	2
 6235              	.L362:
 6236 005c 00000000 		.word	.LANCHOR4
 6237 0060 00000000 		.word	.LANCHOR14
 6238 0064 00000000 		.word	.LANCHOR76
 6239 0068 00000000 		.word	.LANCHOR65
 6240 006c 00000000 		.word	.LANCHOR59
 6241 0070 00000000 		.word	.LANCHOR78
 6242              		.cfi_endproc
 6243              	.LFE187:
 6245              		.section	.text._Z22initReceiverFromEEPROMv,"ax",%progbits
 6246              		.align	1
 6247              		.global	_Z22initReceiverFromEEPROMv
 6248              		.thumb
 6249              		.thumb_func
 6251              	_Z22initReceiverFromEEPROMv:
 6252              	.LFB200:
 469:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** 
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 6253              		.loc 22 470 0
 6254              		.cfi_startproc
 6255              		@ args = 0, pretend = 0, frame = 0
 6256              		@ frame_needed = 0, uses_anonymous_args = 0
 6257 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 6258              	.LCFI56:
 6259              		.cfi_def_cfa_offset 24
 6260              		.cfi_offset 4, -24
 6261              		.cfi_offset 5, -20
 6262              		.cfi_offset 6, -16
 6263              		.cfi_offset 7, -12
 6264              		.cfi_offset 8, -8
 6265              		.cfi_offset 14, -4
 6266              	.LBB338:
 471:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   receiverXmitFactor = readFloat(XMITFACTOR_ADR);
 6267              		.loc 22 471 0
 6268 0004 4FF48C70 		mov	r0, #280
 6269 0008 FFF7FEFF 		bl	_Z12nvrReadFloati
 6270              	.LVL453:
 6271 000c 104B     		ldr	r3, .L367
 6272              	.LBB339:
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 6273              		.loc 22 470 0
 6274 000e 114F     		ldr	r7, .L367+4
 6275 0010 114E     		ldr	r6, .L367+8
 6276 0012 DFF84880 		ldr	r8, .L367+12
 6277              	.LBE339:
 6278              		.loc 22 471 0
 6279 0016 1860     		str	r0, [r3, #0]	@ float
 6280              	.LVL454:
 6281 0018 0025     		movs	r5, #0
 6282 001a 2C46     		mov	r4, r5
 6283              	.LVL455:
 6284              	.L365:
 6285              	.LBB340:
 472:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   
 473:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 474:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSlope[channel] = readFloat(RECEIVER_DATA[channel].slope);
 6286              		.loc 22 474 0 discriminator 2
 6287 001c 04F19C00 		add	r0, r4, #156
 6288 0020 FFF7FEFF 		bl	_Z12nvrReadFloati
 6289              	.LVL456:
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 6290              		.loc 22 470 0 discriminator 2
 6291 0024 7B19     		adds	r3, r7, r5
 6292              		.loc 22 474 0 discriminator 2
 6293 0026 1860     		str	r0, [r3, #0]	@ float
 475:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverOffset[channel] = readFloat(RECEIVER_DATA[channel].offset);
 6294              		.loc 22 475 0 discriminator 2
 6295 0028 04F1A000 		add	r0, r4, #160
 6296 002c FFF7FEFF 		bl	_Z12nvrReadFloati
 6297              	.LVL457:
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 6298              		.loc 22 470 0 discriminator 2
 6299 0030 7319     		adds	r3, r6, r5
 6300              		.loc 22 475 0 discriminator 2
 6301 0032 1860     		str	r0, [r3, #0]	@ float
 476:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****     receiverSmoothFactor[channel] = readFloat(RECEIVER_DATA[channel].smooth_factor);
 6302              		.loc 22 476 0 discriminator 2
 6303 0034 04F1A400 		add	r0, r4, #164
 6304 0038 FFF7FEFF 		bl	_Z12nvrReadFloati
 6305              	.LVL458:
 6306 003c 0C34     		adds	r4, r4, #12
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** void initReceiverFromEEPROM() {
 6307              		.loc 22 470 0 discriminator 2
 6308 003e 08EB0503 		add	r3, r8, r5
 6309 0042 0435     		adds	r5, r5, #4
 473:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 6310              		.loc 22 473 0 discriminator 2
 6311 0044 482C     		cmp	r4, #72
 6312              		.loc 22 476 0 discriminator 2
 6313 0046 1860     		str	r0, [r3, #0]	@ float
 473:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   for(byte channel = XAXIS; channel < LASTCHANNEL; channel++) {
 6314              		.loc 22 473 0 discriminator 2
 6315 0048 E8D1     		bne	.L365
 6316              	.LBE340:
 6317              	.LBE338:
 477:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h ****   }
 478:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\DataStorage.h **** }
 6318              		.loc 22 478 0
 6319 004a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 6320              	.L368:
 6321 004e 00BF     		.align	2
 6322              	.L367:
 6323 0050 00000000 		.word	.LANCHOR12
 6324 0054 00000000 		.word	.LANCHOR7
 6325 0058 00000000 		.word	.LANCHOR8
 6326 005c 00000000 		.word	.LANCHOR9
 6327              		.cfi_endproc
 6328              	.LFE200:
 6330              		.section	.text._Z17initCommunicationv,"ax",%progbits
 6331              		.align	1
 6332              		.global	_Z17initCommunicationv
 6333              		.thumb
 6334              		.thumb_func
 6336              	_Z17initCommunicationv:
 6337              	.LFB201:
 6338              		.file 25 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/SerialCom.h"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   This program is free software: you can redistribute it and/or modify
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   it under the terms of the GNU General Public License as published by
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   the Free Software Foundation, either version 3 of the License, or
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   (at your option) any later version.
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   This program is distributed in the hope that it will be useful,
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   GNU General Public License for more details.
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   You should have received a copy of the GNU General Public License
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // SerialCom.pde is responsible for the serial communication for commands and telemetry from the Ae
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // This comtains readSerialCommand() which listens for a serial command and it's arguments
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // This also contains readSerialTelemetry() which listens for a telemetry request and responds with
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // For more information on each command/telemetry look at: http://aeroquad.com/content.php?117
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // Includes re-write / fixes from Aadamson and ala42, special thanks to those guys!
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // http://aeroquad.com/showthread.php?1461-We-have-some-hidden-warnings&p=14618&viewfull=1#post1461
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #ifndef _AQ_SERIAL_COMM_
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #define _AQ_SERIAL_COMM_
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** char queryType = 'X';
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void initCommunication() {
 6339              		.loc 25 34 0
 6340              		.cfi_startproc
 6341              		@ args = 0, pretend = 0, frame = 0
 6342              		@ frame_needed = 0, uses_anonymous_args = 0
 6343              		@ link register save eliminated.
 6344 0000 7047     		bx	lr
 6345              		.cfi_endproc
 6346              	.LFE201:
 6348              		.section	.text._Z10getHeadingv,"ax",%progbits
 6349              		.align	1
 6350              		.global	_Z10getHeadingv
 6351              		.thumb
 6352              		.thumb_func
 6354              	_Z10getHeadingv:
 6355              	.LFB215:
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // do nothing here for now
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** //********************************** Serial Commands **********************************************
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** bool validateCalibrateCommand(byte command)
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = command;
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     return true;
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   else {
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = 0;
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     testCommand = 1000;
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     return false;
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->P = readFloatSerial();
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->I = readFloatSerial();
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->integratedError = 0;
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void skipSerialValues(byte number) {
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     readFloatSerial();
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // Check for serial message
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (SERIAL_AVAILABLE()) {
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = SERIAL_READ();
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'A': // Receive roll and pitch rate mode PID
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'B': // Receive roll/pitch attitude mode PID
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial(); 
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'C': // Receive yaw PID
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       headingHoldConfig = readFloatSerial();
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
  94:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
  95:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'D': // Altitude hold PID
  96:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
  97:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(BARO_ALTITUDE_HOLD_PID_IDX);
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         readFloatSerial();
  99:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldBump = readFloatSerial();
 100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         altitudeHoldPanicStickMovement = readFloatSerial();
 101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         minThrottleAdjust = readFloatSerial();
 102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         maxThrottleAdjust = readFloatSerial();
 103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #if defined AltitudeHoldBaro
 104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           baroSmoothFactor = readFloatSerial();
 105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #else
 106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #endif
 108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(ZDAMPENING_PID_IDX);
 109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'E': // Receive sensor filtering values
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       aref = readFloatSerial();
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       minArmedThrottle = readFloatSerial();
 115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 117:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'F': // Receive transmitter smoothing values
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 121:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 122:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 123:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'G': // Receive transmitter calibration values
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'H': // Receive transmitter calibration values
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'I': // Initialize EEPROM with default values
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM();
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef HeadingMagHold
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeMagnetometer();
 142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 143:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef AltitudeHoldBaro
 144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         initializeBaro();
 145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'J': // calibrate gyros
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 151:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'K': // Write accel calibration values
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
 159:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();    
 160:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 161:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 162:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 163:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'L': // generate accel bias
 164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 165:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 166:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateKinematics();
 167:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         accelOneG = meterPerSecSec[ZAXIS];
 168:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 169:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 170:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 171:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 172:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'M': // calibrate magnetometer
 173:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef HeadingMagHold
 174:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[XAXIS]  = readFloatSerial();
 175:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[YAXIS]  = readFloatSerial();
 176:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         magBias[ZAXIS]  = readFloatSerial();
 177:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 178:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 179:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(3);
 180:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 181:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 182:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 183:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'N': // battery monitor
 184:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef BattMonitor
 185:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorAlarmVoltage = readFloatSerial();
 186:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorThrottleTarget = readFloatSerial();
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         batteryMonitorGoingDownTime = readFloatSerial();
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         setBatteryCellVoltageThreshold(batteryMonitorAlarmVoltage);
 189:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(3);
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 192:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 193:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 194:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'O': // define waypoints
 195:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef UseGPSNavigator
 196:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         missionNbPoint = readIntegerSerial();
 197:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].latitude = readIntegerSerial();
 198:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].longitude = readIntegerSerial();
 199:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         waypoint[missionNbPoint].altitude = readIntegerSerial();
 200:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 201:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         for(byte i = 0; i < 4; i++) {
 202:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 203:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 204:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 205:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 206:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'P': //  read Camera values
 207:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef CameraControl
 208:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         cameraMode = readFloatSerial();
 209:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterPitch = readFloatSerial();
 210:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterRoll = readFloatSerial();
 211:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoCenterYaw = readFloatSerial();
 212:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraPitch = readFloatSerial();
 213:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraRoll = readFloatSerial();
 214:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         mCameraYaw = readFloatSerial();
 215:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinPitch = readFloatSerial();
 216:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinRoll = readFloatSerial();
 217:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMinYaw = readFloatSerial();
 218:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxPitch = readFloatSerial();
 219:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxRoll = readFloatSerial();
 220:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         servoMaxYaw = readFloatSerial();
 221:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #ifdef CameraTXControl
 222:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           servoTXChannels = readFloatSerial();
 223:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #endif
 224:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 225:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #ifdef CameraTXControl
 226:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           skipSerialValues(14)
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #else
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           skipSerialValues(13);
 229:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         #endif
 230:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 231:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 232:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'U': // Range Finder
 234:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (AltitudeHoldRangeFinder)
 235:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         maxRangeFinderRange = readFloatSerial();
 236:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         minRangeFinderRange = readFloatSerial();
 237:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 238:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(2);
 239:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 240:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 241:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 242:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'V': // GPS
 243:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (UseGPSNavigator)
 244:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSROLL_PID_IDX);
 245:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSPITCH_PID_IDX);
 246:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         readSerialPID(GPSYAW_PID_IDX);
 247:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         writeEEPROM();
 248:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(9);
 250:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 251:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 252:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 253:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'W': // Write all user configurable values to EEPROM
 254:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 256:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 257:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 258:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'X': // Stop sending messages
 259:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 260:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 261:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case '1': // Calibrate ESCS's by setting Throttle high on all channels
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       validateCalibrateCommand(1);
 263:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 264:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 265:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case '2': // Calibrate ESC's by setting Throttle low on all channels
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       validateCalibrateCommand(2);
 267:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 268:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 269:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case '3': // Test ESC calibration
 270:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(3)) {
 271:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = readFloatSerial();
 272:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 273:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 274:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 275:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case '4': // Turn off ESC calibration
 276:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(4)) {
 277:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 278:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 279:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 280:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 281:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 282:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case '5': // Send individual motor commands (motor, command)
 283:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 284:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++) {
 285:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 286:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 287:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 288:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 289:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 290:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     case 'Z': // fast telemetry transfer <--- get rid if this?
 291:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (readFloatSerial() == 1.0)
 292:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = ON;
 293:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       else
 294:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = OFF;
 295:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 296:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 297:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 299:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 300:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
 301:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** //********************************* Serial Telemetry **********************************************
 302:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** //*************************************************************************************************
 303:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 304:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(float val) {
 305:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 306:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 307:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 308:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 310:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 311:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 312:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 313:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 314:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 315:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 316:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 317:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 318:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 319:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 320:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 321:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 324:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(unsigned long val)
 325:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 326:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 327:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 328:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 329:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 330:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(byte val)
 331:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 332:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 333:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 334:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 335:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(long int val)
 337:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 338:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 339:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 340:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 341:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 342:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintPID(unsigned char IDPid)
 343:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 344:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 345:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 346:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 347:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 348:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 349:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintDummyValues(byte number) {
 350:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 351:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(0);
 352:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 353:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 354:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 355:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 356:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** float getHeading()
 357:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 6356              		.loc 25 357 0
 6357              		.cfi_startproc
 6358              		@ args = 0, pretend = 0, frame = 0
 6359              		@ frame_needed = 0, uses_anonymous_args = 0
 6360              		@ link register save eliminated.
 358:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(HeadingMagHold) || defined(AeroQuadMega_CHR6DM) || defined(APM_OP_CHR6DM)
 359:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     float heading = trueNorthHeading;
 360:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     if (heading < 0) { 
 361:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       heading += (2.0 * M_PI);
 362:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 363:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     return heading;
 364:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #else
 365:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     return(gyroHeading);
 366:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 367:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6361              		.loc 25 367 0
 6362 0000 014B     		ldr	r3, .L371
 6363 0002 1868     		ldr	r0, [r3, #0]	@ float
 6364 0004 7047     		bx	lr
 6365              	.L372:
 6366 0006 00BF     		.align	2
 6367              	.L371:
 6368 0008 00000000 		.word	.LANCHOR22
 6369              		.cfi_endproc
 6370              	.LFE215:
 6372              		.section	.text._Z15readValueSerialPch,"ax",%progbits
 6373              		.align	1
 6374              		.global	_Z15readValueSerialPch
 6375              		.thumb
 6376              		.thumb_func
 6378              	_Z15readValueSerialPch:
 6379              	.LFB217:
 368:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 370:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 371:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '=': // Reserved debug command to view any variable from Serial Monitor
 372:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 373:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 374:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'a': // Send roll and pitch rate mode PID values
 375:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 376:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 377:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 378:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 379:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 380:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 381:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 382:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'b': // Send roll and pitch attitude mode PID values
 383:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 384:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 385:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 386:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 387:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(0);
 388:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 389:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 390:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 391:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'c': // Send yaw PID values
 392:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 393:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 394:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 395:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 396:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 397:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 398:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'd': // Altitude Hold
 399:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 400:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(BARO_ALTITUDE_HOLD_PID_IDX);
 401:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 402:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldBump);
 403:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(altitudeHoldPanicStickMovement);
 404:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(minThrottleAdjust);
 405:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxThrottleAdjust);
 406:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro
 407:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(baroSmoothFactor);
 408:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 409:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 410:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 411:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(ZDAMPENING_PID_IDX);
 412:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 413:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(10);
 414:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 415:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 416:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 417:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 418:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 419:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'e': // miscellaneous config values
 420:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(aref);
 421:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 422:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 423:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 424:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 425:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'f': // Send transmitter smoothing values
 426:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 427:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 428:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 429:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 430:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintDummyValues(10 - LASTCHANNEL);
 431:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 432:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 433:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 434:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 435:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'g': // Send transmitter calibration data
 436:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 437:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 438:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 439:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 440:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 441:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 442:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 443:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 444:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'h': // Send transmitter calibration data
 445:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 446:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 447:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 448:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 449:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 450:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 451:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 452:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 453:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'i': // Send sensor data
 454:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 455:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 456:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 457:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 458:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 459:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 460:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 461:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined(HeadingMagHold)
 462:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(getMagnetometerData(axis));
 463:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 464:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 465:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 466:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 467:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 468:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 469:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'j': // Send raw mag values
 471:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef HeadingMagHold
 472:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(XAXIS));
 473:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getMagnetometerRawData(YAXIS));
 474:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(getMagnetometerRawData(ZAXIS));
 475:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 476:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 477:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 478:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'k': // Send accelerometer cal values
 479:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 480:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 481:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 482:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 483:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 484:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 485:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 486:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 487:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 488:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 489:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 490:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 491:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 492:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 493:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'l': // Send raw accel values
 494:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     evaluateMetersPerSec();    // reset sample data
 495:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     delay(2);
 496:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     measureCriticalSensors();  // call mesureAccelSum that give one raw sample in accelSample
 497:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]));
 498:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]));
 499:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]));
 500:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 501:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 502:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'm': // Send magnetometer cal values
 503:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef HeadingMagHold
 504:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[XAXIS], 6);
 505:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 506:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINT(magBias[YAXIS], 6);
 507:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       comma();
 508:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(magBias[ZAXIS], 6);
 509:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 510:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 511:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 512:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 513:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'n': // battery monitor
 514:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef BattMonitor
 515:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorAlarmVoltage);
 516:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorThrottleTarget);
 517:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(batteryMonitorGoingDownTime);
 518:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 519:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(3);
 520:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 521:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 522:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 523:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 524:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 525:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'o': // send waypoints
 526:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef UseGPSNavigator
 527:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       for (byte index = 0; index < MAX_WAYPOINTS; index++) {
 528:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(index);
 529:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].latitude);
 530:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].longitude);
 531:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(waypoint[index].altitude);
 532:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       }
 533:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 534:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(4);
 535:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 536:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 537:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 538:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 539:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 540:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'p': // Send Camera values
 541:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef CameraControl
 542:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(cameraMode);
 543:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterPitch);
 544:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterRoll);
 545:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoCenterYaw);
 546:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraPitch);
 547:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraRoll);
 548:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(mCameraYaw);
 549:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinPitch);
 550:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinRoll);
 551:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMinYaw);
 552:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxPitch);
 553:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxRoll);
 554:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(servoMaxYaw);
 555:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef CameraTXControl
 556:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(servoTXChannels);
 557:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 558:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 559:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #ifdef CameraTXControl
 560:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintDummyValues(14);
 561:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 562:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintDummyValues(13);
 563:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 564:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 565:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 566:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 567:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 568:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 569:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'q': // Send Vehicle State Value
 570:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 571:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 572:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 573:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 574:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'r': // Vehicle attitude
 575:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 576:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 577:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(getHeading());
 578:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 579:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 580:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 's': // Send all flight data
 581:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 582:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 583:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 584:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(getHeading());
 585:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined AltitudeHoldBaro || defined AltitudeHoldRangeFinder
 586:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined AltitudeHoldBaro
 587:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(estimatedAltitude);
 588:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #elif defined AltitudeHoldRangeFinder
 589:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX] != INVALID_RANGE ? rangeFinde
 590:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 591:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((int)altitudeHoldState);
 592:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 593:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 594:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 595:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 596:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 597:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 598:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 599:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 600:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 601:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 602:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 603:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 604:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 605:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 606:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef BattMonitor
 607:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 608:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 609:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 610:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 611:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(flightMode);
 612:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 613:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 614:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 615:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 't': // Send processed transmitter values
 616:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 617:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 618:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 619:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 620:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 621:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 622:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'u': // Send range finder values
 623:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (AltitudeHoldRangeFinder)
 624:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(maxRangeFinderRange);
 625:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(minRangeFinderRange);
 626:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 627:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 628:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 629:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 630:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 631:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 632:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 633:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'v': // Send GPS PIDs
 634:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (UseGPSNavigator)
 635:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSROLL_PID_IDX);
 636:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSPITCH_PID_IDX);
 637:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintPID(GPSYAW_PID_IDX);
 638:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       queryType = 'X';
 639:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 640:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(9);
 641:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 642:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 643:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 644:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 645:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'y': // send GPS info
 646:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (UseGPS)
 647:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.state);
 648:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.lat);
 649:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.lon);
 650:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.height);
 651:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.course);
 652:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.speed);
 653:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.accuracy);
 654:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.sats);
 655:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.fixtime);
 656:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.sentences);
 657:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gpsData.idlecount);
 658:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 659:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(11);
 660:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif    
 661:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 662:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 663:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****  
 664:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'z': // Send all Altitude data 
 665:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (AltitudeHoldBaro) 
 666:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(getBaroAltitude()); 
 667:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 668:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 669:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif 
 670:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (AltitudeHoldRangeFinder) 
 671:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(rangeFinderRange[ALTITUDE_RANGE_FINDER_INDEX]);
 672:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 673:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0); 
 674:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif 
 675:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 676:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     
 677:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '$': // send BatteryMonitor voltage/current readings
 678:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (BattMonitor)
 679:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((float)batteryData[0].voltage/100.0); // voltage internally stored at 10mV:s
 680:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #if defined (BM_EXTENDED)
 681:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma((float)batteryData[0].current/100.0);
 682:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma((float)batteryData[0].usedCapacity/1000.0);
 683:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #else
 684:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintDummyValues(2);
 685:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       #endif
 686:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 687:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(3);
 688:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 689:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 690:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 691:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     
 692:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '%': // send RSSI
 693:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #if defined (UseAnalogRSSIReader) || defined (UseEzUHFRSSIReader) || defined (UseSBUSRSSIReader
 694:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(rssiRawValue);
 695:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 696:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 697:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 698:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 699:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 700:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case 'x': // Stop sending messages
 701:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 702:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 703:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '!': // Send flight software version
 704:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 705:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 706:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 707:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 708:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '#': // Send configuration
 709:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     reportVehicleState();
 710:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 711:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 712:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 713:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '6': // Report remote commands
 714:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 715:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 716:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 717:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 718:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 719:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 720:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 721:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #if defined(OSD) && defined(OSD_LOADFONT)
 722:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   case '&': // fontload
 723:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     if (OFF == motorArmed) {
 724:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       max7456LoadFont();
 725:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 726:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 727:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 728:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #endif
 729:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 730:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 731:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 732:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 733:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readValueSerial(char *data, byte size) {
 6380              		.loc 25 733 0
 6381              		.cfi_startproc
 6382              		@ args = 0, pretend = 0, frame = 0
 6383              		@ frame_needed = 0, uses_anonymous_args = 0
 6384              	.LVL459:
 6385 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 6386              	.LCFI57:
 6387              		.cfi_def_cfa_offset 24
 6388              		.cfi_offset 3, -24
 6389              		.cfi_offset 4, -20
 6390              		.cfi_offset 5, -16
 6391              		.cfi_offset 6, -12
 6392              		.cfi_offset 7, -8
 6393              		.cfi_offset 14, -4
 6394              	.LBB341:
 734:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   byte index = 0;
 735:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   byte timeout = 0;
 736:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   data[0] = '\0';
 6395              		.loc 25 736 0
 6396 0002 0025     		movs	r5, #0
 6397              	.LBE341:
 733:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readValueSerial(char *data, byte size) {
 6398              		.loc 25 733 0
 6399 0004 0646     		mov	r6, r0
 6400              	.LBB342:
 6401              		.loc 25 736 0
 6402 0006 0570     		strb	r5, [r0, #0]
 734:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   byte index = 0;
 6403              		.loc 25 734 0
 6404 0008 2C46     		mov	r4, r5
 737:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 738:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 6405              		.loc 25 738 0
 6406 000a 4F1E     		subs	r7, r1, #1
 6407              	.LVL460:
 6408              	.L378:
 739:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     if (SERIAL_AVAILABLE() == 0) {
 6409              		.loc 25 739 0
 6410 000c 0F48     		ldr	r0, .L384
 6411 000e FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 6412              	.LVL461:
 6413 0012 28B9     		cbnz	r0, .L374
 740:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       delay(1);
 6414              		.loc 25 740 0
 6415 0014 0120     		movs	r0, #1
 741:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout++;
 6416              		.loc 25 741 0
 6417 0016 0135     		adds	r5, r5, #1
 6418              	.LVL462:
 740:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       delay(1);
 6419              		.loc 25 740 0
 6420 0018 FFF7FEFF 		bl	_Z5delaym
 6421              	.LVL463:
 6422              		.loc 25 741 0
 6423 001c EDB2     		uxtb	r5, r5
 6424              	.LVL464:
 6425 001e 06E0     		b	.L375
 6426              	.L374:
 742:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     } else {
 743:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       data[index] = SERIAL_READ();
 6427              		.loc 25 743 0
 6428 0020 0A48     		ldr	r0, .L384
 6429 0022 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 6430              	.LVL465:
 6431 0026 3055     		strb	r0, [r6, r4]
 6432              	.LVL466:
 744:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout = 0;
 745:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       index++;
 6433              		.loc 25 745 0
 6434 0028 0134     		adds	r4, r4, #1
 6435              	.LVL467:
 6436 002a E4B2     		uxtb	r4, r4
 6437              	.LVL468:
 744:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       timeout = 0;
 6438              		.loc 25 744 0
 6439 002c 0025     		movs	r5, #0
 6440              	.LVL469:
 6441              	.L375:
 738:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 6442              		.loc 25 738 0
 6443 002e 3CB1     		cbz	r4, .L376
 738:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 6444              		.loc 25 738 0 is_stmt 0 discriminator 2
 6445 0030 3319     		adds	r3, r6, r4
 6446 0032 13F8013C 		ldrb	r3, [r3, #-1]	@ zero_extendqisi2
 6447 0036 3B2B     		cmp	r3, #59
 6448 0038 02D1     		bne	.L376
 6449              	.L377:
 746:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     }
 747:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   } while ((index == 0 || data[index-1] != ';') && (timeout < 10) && (index < size-1));
 748:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 749:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   data[index] = '\0';
 6450              		.loc 25 749 0 is_stmt 1
 6451 003a 0023     		movs	r3, #0
 6452 003c 3355     		strb	r3, [r6, r4]
 6453 003e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 6454              	.L376:
 738:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 6455              		.loc 25 738 0 discriminator 1
 6456 0040 092D     		cmp	r5, #9
 6457 0042 FAD8     		bhi	.L377
 738:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   do {
 6458              		.loc 25 738 0 is_stmt 0 discriminator 4
 6459 0044 BC42     		cmp	r4, r7
 6460 0046 E1DB     		blt	.L378
 6461 0048 F7E7     		b	.L377
 6462              	.L385:
 6463 004a 00BF     		.align	2
 6464              	.L384:
 6465 004c 00000000 		.word	SerialUSB
 6466              	.LBE342:
 6467              		.cfi_endproc
 6468              	.LFE217:
 6470              		.section	.text._Z15readFloatSerialv,"ax",%progbits
 6471              		.align	1
 6472              		.global	_Z15readFloatSerialv
 6473              		.thumb
 6474              		.thumb_func
 6476              	_Z15readFloatSerialv:
 6477              	.LFB218:
 750:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 751:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 752:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 753:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // Used to read floating point values from the serial port
 754:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** float readFloatSerial() {
 6478              		.loc 25 754 0 is_stmt 1
 6479              		.cfi_startproc
 6480              		@ args = 0, pretend = 0, frame = 16
 6481              		@ frame_needed = 0, uses_anonymous_args = 0
 6482 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 6483              	.LCFI58:
 6484              		.cfi_def_cfa_offset 24
 6485              		.cfi_offset 0, -24
 6486              		.cfi_offset 1, -20
 6487              		.cfi_offset 2, -16
 6488              		.cfi_offset 3, -12
 6489              		.cfi_offset 4, -8
 6490              		.cfi_offset 14, -4
 6491              	.LBB343:
 755:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   char data[15] = "";
 6492              		.loc 25 755 0
 6493 0002 0021     		movs	r1, #0
 6494 0004 0B22     		movs	r2, #11
 6495 0006 01A8     		add	r0, sp, #4
 6496 0008 0091     		str	r1, [sp, #0]
 6497 000a FFF7FEFF 		bl	memset
 6498              	.LVL470:
 756:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 757:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   readValueSerial(data, sizeof(data));
 6499              		.loc 25 757 0
 6500 000e 6846     		mov	r0, sp
 6501 0010 0F21     		movs	r1, #15
 6502 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 6503              	.LVL471:
 758:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   return atof(data);
 6504              		.loc 25 758 0
 6505 0016 6846     		mov	r0, sp
 6506 0018 FFF7FEFF 		bl	atof
 6507              	.LVL472:
 6508 001c FFF7FEFF 		bl	__aeabi_d2f
 6509              	.LVL473:
 6510              	.LBE343:
 759:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6511              		.loc 25 759 0
 6512 0020 05B0     		add	sp, sp, #20
 6513 0022 00BD     		pop	{pc}
 6514              		.cfi_endproc
 6515              	.LFE218:
 6517              		.section	.text._Z16skipSerialValuesh,"ax",%progbits
 6518              		.align	1
 6519              		.global	_Z16skipSerialValuesh
 6520              		.thumb
 6521              		.thumb_func
 6523              	_Z16skipSerialValuesh:
 6524              	.LFB204:
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void skipSerialValues(byte number) {
 6525              		.loc 25 64 0
 6526              		.cfi_startproc
 6527              		@ args = 0, pretend = 0, frame = 0
 6528              		@ frame_needed = 0, uses_anonymous_args = 0
 6529              	.LVL474:
 6530 0000 38B5     		push	{r3, r4, r5, lr}
 6531              	.LCFI59:
 6532              		.cfi_def_cfa_offset 16
 6533              		.cfi_offset 3, -16
 6534              		.cfi_offset 4, -12
 6535              		.cfi_offset 5, -8
 6536              		.cfi_offset 14, -4
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void skipSerialValues(byte number) {
 6537              		.loc 25 64 0
 6538 0002 0546     		mov	r5, r0
 6539              	.LBB344:
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 6540              		.loc 25 65 0
 6541 0004 0024     		movs	r4, #0
 6542 0006 03E0     		b	.L388
 6543              	.LVL475:
 6544              	.L389:
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     readFloatSerial();
 6545              		.loc 25 66 0 discriminator 2
 6546 0008 FFF7FEFF 		bl	_Z15readFloatSerialv
 6547              	.LVL476:
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 6548              		.loc 25 65 0 discriminator 2
 6549 000c 0134     		adds	r4, r4, #1
 6550              	.LVL477:
 6551 000e E4B2     		uxtb	r4, r4
 6552              	.LVL478:
 6553              	.L388:
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 6554              		.loc 25 65 0 is_stmt 0 discriminator 1
 6555 0010 AC42     		cmp	r4, r5
 6556 0012 F9D1     		bne	.L389
 6557              	.LBE344:
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6558              		.loc 25 68 0 is_stmt 1
 6559 0014 38BD     		pop	{r3, r4, r5, pc}
 6560              		.cfi_endproc
 6561              	.LFE204:
 6563              		.section	.text._Z13readSerialPIDh,"ax",%progbits
 6564              		.align	1
 6565              		.global	_Z13readSerialPIDh
 6566              		.thumb
 6567              		.thumb_func
 6569              	_Z13readSerialPIDh:
 6570              	.LFB203:
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 6571              		.loc 25 55 0
 6572              		.cfi_startproc
 6573              		@ args = 0, pretend = 0, frame = 0
 6574              		@ frame_needed = 0, uses_anonymous_args = 0
 6575              	.LVL479:
 6576              	.LBB345:
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 6577              		.loc 25 56 0
 6578 0000 084B     		ldr	r3, .L391
 6579              	.LBE345:
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialPID(unsigned char PIDid) {
 6580              		.loc 25 55 0
 6581 0002 10B5     		push	{r4, lr}
 6582              	.LCFI60:
 6583              		.cfi_def_cfa_offset 8
 6584              		.cfi_offset 4, -8
 6585              		.cfi_offset 14, -4
 6586              	.LBB346:
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   struct PIDdata* pid = &PID[PIDid];
 6587              		.loc 25 56 0
 6588 0004 1824     		movs	r4, #24
 6589 0006 04FB0034 		mla	r4, r4, r0, r3
 6590              	.LVL480:
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->P = readFloatSerial();
 6591              		.loc 25 57 0
 6592 000a FFF7FEFF 		bl	_Z15readFloatSerialv
 6593              	.LVL481:
 6594 000e 2060     		str	r0, [r4, #0]	@ float
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->I = readFloatSerial();
 6595              		.loc 25 58 0
 6596 0010 FFF7FEFF 		bl	_Z15readFloatSerialv
 6597              	.LVL482:
 6598 0014 6060     		str	r0, [r4, #4]	@ float
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
 6599              		.loc 25 59 0
 6600 0016 FFF7FEFF 		bl	_Z15readFloatSerialv
 6601              	.LVL483:
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
 6602              		.loc 25 60 0
 6603 001a 0023     		movs	r3, #0
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->D = readFloatSerial();
 6604              		.loc 25 59 0
 6605 001c A060     		str	r0, [r4, #8]	@ float
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->lastError = 0;
 6606              		.loc 25 60 0
 6607 001e E360     		str	r3, [r4, #12]	@ float
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   pid->integratedError = 0;
 6608              		.loc 25 61 0
 6609 0020 6361     		str	r3, [r4, #20]	@ float
 6610 0022 10BD     		pop	{r4, pc}
 6611              	.L392:
 6612              		.align	2
 6613              	.L391:
 6614 0024 00000000 		.word	.LANCHOR15
 6615              	.LBE346:
 6616              		.cfi_endproc
 6617              	.LFE203:
 6619              		.section	.text._Z24validateCalibrateCommandh,"ax",%progbits
 6620              		.align	1
 6621              		.global	_Z24validateCalibrateCommandh
 6622              		.thumb
 6623              		.thumb_func
 6625              	_Z24validateCalibrateCommandh:
 6626              	.LFB202:
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 6627              		.loc 25 42 0
 6628              		.cfi_startproc
 6629              		@ args = 0, pretend = 0, frame = 0
 6630              		@ frame_needed = 0, uses_anonymous_args = 0
 6631              	.LVL484:
 6632 0000 10B5     		push	{r4, lr}
 6633              	.LCFI61:
 6634              		.cfi_def_cfa_offset 8
 6635              		.cfi_offset 4, -8
 6636              		.cfi_offset 14, -4
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 6637              		.loc 25 42 0
 6638 0002 0446     		mov	r4, r0
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (readFloatSerial() == 123.45) {// use a specific float value to validate full throttle call is
 6639              		.loc 25 43 0
 6640 0004 FFF7FEFF 		bl	_Z15readFloatSerialv
 6641              	.LVL485:
 6642 0008 DFED0B7A 		flds	s15, .L396
 6643 000c 07EE100A 		fmsr	s14, r0
 6644 0010 B4EE677A 		fcmps	s14, s15
 6645 0014 F1EE10FA 		fmstat
 6646 0018 4FF00003 		mov	r3, #0
 6647 001c 074A     		ldr	r2, .L396+4
 6648 001e 04D1     		bne	.L394
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
 6649              		.loc 25 44 0
 6650 0020 0749     		ldr	r1, .L396+8
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = command;
 6651              		.loc 25 45 0
 6652 0022 1470     		strb	r4, [r2, #0]
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     motorArmed = OFF;
 6653              		.loc 25 44 0
 6654 0024 0B70     		strb	r3, [r1, #0]
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     return true;
 6655              		.loc 25 46 0
 6656 0026 0120     		movs	r0, #1
 6657 0028 10BD     		pop	{r4, pc}
 6658              	.L394:
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     calibrateESC = 0;
 6659              		.loc 25 49 0
 6660 002a 1370     		strb	r3, [r2, #0]
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     testCommand = 1000;
 6661              		.loc 25 50 0
 6662 002c 054A     		ldr	r2, .L396+12
 6663 002e 4FF47A71 		mov	r1, #1000
 6664 0032 1160     		str	r1, [r2, #0]
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     return false;
 6665              		.loc 25 51 0
 6666 0034 1846     		mov	r0, r3
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6667              		.loc 25 53 0
 6668 0036 10BD     		pop	{r4, pc}
 6669              	.L397:
 6670              		.align	2
 6671              	.L396:
 6672 0038 66E6F642 		.word	1123477094
 6673 003c 00000000 		.word	.LANCHOR61
 6674 0040 00000000 		.word	.LANCHOR76
 6675 0044 00000000 		.word	.LANCHOR62
 6676              		.cfi_endproc
 6677              	.LFE202:
 6679              		.section	.text._Z17readSerialCommandv,"ax",%progbits
 6680              		.align	1
 6681              		.global	_Z17readSerialCommandv
 6682              		.thumb
 6683              		.thumb_func
 6685              	_Z17readSerialCommandv:
 6686              	.LFB205:
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 6687              		.loc 25 70 0
 6688              		.cfi_startproc
 6689              		@ args = 0, pretend = 0, frame = 0
 6690              		@ frame_needed = 0, uses_anonymous_args = 0
 6691 0000 38B5     		push	{r3, r4, r5, lr}
 6692              	.LCFI62:
 6693              		.cfi_def_cfa_offset 16
 6694              		.cfi_offset 3, -16
 6695              		.cfi_offset 4, -12
 6696              		.cfi_offset 5, -8
 6697              		.cfi_offset 14, -4
 6698              	.LBB347:
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (SERIAL_AVAILABLE()) {
 6699              		.loc 25 72 0
 6700 0002 8048     		ldr	r0, .L448
 6701 0004 FFF7FEFF 		bl	_ZN9USBSerial9availableEv
 6702              	.LVL486:
 6703 0008 0028     		cmp	r0, #0
 6704 000a 00F03A81 		beq	.L398
 6705              	.LBB348:
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = SERIAL_READ();
 6706              		.loc 25 73 0
 6707 000e 7D48     		ldr	r0, .L448
 6708 0010 FFF7FEFF 		bl	_ZN9USBSerial4readEv
 6709              	.LVL487:
 6710 0014 7C4B     		ldr	r3, .L448+4
 6711 0016 1870     		strb	r0, [r3, #0]
 6712              	.LBB349:
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     switch (queryType) {
 6713              		.loc 25 74 0
 6714 0018 3138     		subs	r0, r0, #49
 6715 001a 2928     		cmp	r0, #41
 6716 001c 00F23181 		bhi	.L398
 6717 0020 DFE810F0 		tbh	[pc, r0, lsl #1]
 6718              	.L425:
 6719 0024 CC00     		.2byte	(.L401-.L425)/2
 6720 0026 CE00     		.2byte	(.L402-.L425)/2
 6721 0028 D300     		.2byte	(.L403-.L425)/2
 6722 002a E200     		.2byte	(.L404-.L425)/2
 6723 002c 0C01     		.2byte	(.L405-.L425)/2
 6724 002e 2F01     		.2byte	(.L398-.L425)/2
 6725 0030 2F01     		.2byte	(.L398-.L425)/2
 6726 0032 2F01     		.2byte	(.L398-.L425)/2
 6727 0034 2F01     		.2byte	(.L398-.L425)/2
 6728 0036 2F01     		.2byte	(.L398-.L425)/2
 6729 0038 2F01     		.2byte	(.L398-.L425)/2
 6730 003a 2F01     		.2byte	(.L398-.L425)/2
 6731 003c 2F01     		.2byte	(.L398-.L425)/2
 6732 003e 2F01     		.2byte	(.L398-.L425)/2
 6733 0040 2F01     		.2byte	(.L398-.L425)/2
 6734 0042 2F01     		.2byte	(.L398-.L425)/2
 6735 0044 3100     		.2byte	(.L406-.L425)/2
 6736 0046 3C00     		.2byte	(.L407-.L425)/2
 6737 0048 4C00     		.2byte	(.L408-.L425)/2
 6738 004a 2F01     		.2byte	(.L398-.L425)/2
 6739 004c 5D00     		.2byte	(.L409-.L425)/2
 6740 004e 6900     		.2byte	(.L410-.L425)/2
 6741 0050 7700     		.2byte	(.L411-.L425)/2
 6742 0052 8600     		.2byte	(.L412-.L425)/2
 6743 0054 9800     		.2byte	(.L413-.L425)/2
 6744 0056 A100     		.2byte	(.L414-.L425)/2
 6745 0058 A500     		.2byte	(.L415-.L425)/2
 6746 005a B500     		.2byte	(.L416-.L425)/2
 6747 005c BB00     		.2byte	(.L418-.L425)/2
 6748 005e BB00     		.2byte	(.L418-.L425)/2
 6749 0060 2A00     		.2byte	(.L419-.L425)/2
 6750 0062 BD00     		.2byte	(.L420-.L425)/2
 6751 0064 2F01     		.2byte	(.L398-.L425)/2
 6752 0066 2F01     		.2byte	(.L398-.L425)/2
 6753 0068 2F01     		.2byte	(.L398-.L425)/2
 6754 006a 2F01     		.2byte	(.L398-.L425)/2
 6755 006c C200     		.2byte	(.L421-.L425)/2
 6756 006e C400     		.2byte	(.L422-.L425)/2
 6757 0070 C600     		.2byte	(.L423-.L425)/2
 6758 0072 2F01     		.2byte	(.L398-.L425)/2
 6759 0074 2F01     		.2byte	(.L398-.L425)/2
 6760 0076 1F01     		.2byte	(.L424-.L425)/2
 6761              	.L419:
 6762              	.LVL488:
 6763              	.LBB350:
 6764              	.LBB351:
 202:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           readFloatSerial();
 6765              		.loc 25 202 0 discriminator 1
 6766 0078 FFF7FEFF 		bl	_Z15readFloatSerialv
 6767              	.LVL489:
 6768 007c FFF7FEFF 		bl	_Z15readFloatSerialv
 6769              	.LVL490:
 6770 0080 FFF7FEFF 		bl	_Z15readFloatSerialv
 6771              	.LVL491:
 6772 0084 16E0     		b	.L441
 6773              	.LVL492:
 6774              	.L406:
 6775              	.LBE351:
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_XAXIS_PID_IDX);
 6776              		.loc 25 76 0
 6777 0086 0020     		movs	r0, #0
 6778 0088 FFF7FEFF 		bl	_Z13readSerialPIDh
 6779              	.LVL493:
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(RATE_YAXIS_PID_IDX);
 6780              		.loc 25 77 0
 6781 008c 0120     		movs	r0, #1
 6782 008e FFF7FEFF 		bl	_Z13readSerialPIDh
 6783              	.LVL494:
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       rotationSpeedFactor = readFloatSerial();
 6784              		.loc 25 78 0
 6785 0092 FFF7FEFF 		bl	_Z15readFloatSerialv
 6786              	.LVL495:
 6787 0096 5D4B     		ldr	r3, .L448+8
 6788 0098 1860     		str	r0, [r3, #0]	@ float
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 6789              		.loc 25 79 0
 6790 009a 38BD     		pop	{r3, r4, r5, pc}
 6791              	.L407:
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_XAXIS_PID_IDX);
 6792              		.loc 25 82 0
 6793 009c 0320     		movs	r0, #3
 6794 009e FFF7FEFF 		bl	_Z13readSerialPIDh
 6795              	.LVL496:
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_YAXIS_PID_IDX);
 6796              		.loc 25 83 0
 6797 00a2 0420     		movs	r0, #4
 6798 00a4 FFF7FEFF 		bl	_Z13readSerialPIDh
 6799              	.LVL497:
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 6800              		.loc 25 84 0
 6801 00a8 0620     		movs	r0, #6
 6802 00aa FFF7FEFF 		bl	_Z13readSerialPIDh
 6803              	.LVL498:
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 6804              		.loc 25 85 0
 6805 00ae 0720     		movs	r0, #7
 6806 00b0 FFF7FEFF 		bl	_Z13readSerialPIDh
 6807              	.LVL499:
 6808              	.L441:
 6809              	.LBE350:
 6810              	.LBE349:
 6811              	.LBE348:
 6812              	.LBE347:
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6813              		.loc 25 298 0
 6814 00b4 BDE83840 		pop	{r3, r4, r5, lr}
 6815              	.LBB374:
 6816              	.LBB368:
 6817              	.LBB362:
 6818              	.LBB356:
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial(); 
 6819              		.loc 25 86 0
 6820 00b8 FFF7FEBF 		b	_Z15readFloatSerialv
 6821              	.LVL500:
 6822              	.L408:
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(ZAXIS_PID_IDX);
 6823              		.loc 25 90 0
 6824 00bc 0220     		movs	r0, #2
 6825 00be FFF7FEFF 		bl	_Z13readSerialPIDh
 6826              	.LVL501:
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readSerialPID(HEADING_HOLD_PID_IDX);
 6827              		.loc 25 91 0
 6828 00c2 0520     		movs	r0, #5
 6829 00c4 FFF7FEFF 		bl	_Z13readSerialPIDh
 6830              	.LVL502:
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       headingHoldConfig = readFloatSerial();
 6831              		.loc 25 92 0
 6832 00c8 FFF7FEFF 		bl	_Z15readFloatSerialv
 6833              	.LVL503:
 6834 00cc 07EE100A 		fmsr	s14, r0
 6835 00d0 BCEEC77A 		ftouizs	s14, s14
 6836 00d4 4E4B     		ldr	r3, .L448+12
 6837 00d6 17EE100A 		fmrs	r0, s14	@ int
 6838 00da 1870     		strb	r0, [r3, #0]
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 6839              		.loc 25 93 0
 6840 00dc 38BD     		pop	{r3, r4, r5, pc}
 6841              	.L409:
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       aref = readFloatSerial();
 6842              		.loc 25 113 0
 6843 00de FFF7FEFF 		bl	_Z15readFloatSerialv
 6844              	.LVL504:
 6845 00e2 4C4B     		ldr	r3, .L448+16
 6846 00e4 1860     		str	r0, [r3, #0]	@ float
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       minArmedThrottle = readFloatSerial();
 6847              		.loc 25 114 0
 6848 00e6 FFF7FEFF 		bl	_Z15readFloatSerialv
 6849              	.LVL505:
 6850 00ea 07EE100A 		fmsr	s14, r0
 6851 00ee 4A4B     		ldr	r3, .L448+20
 6852 00f0 FDEEC77A 		ftosizs	s15, s14
 6853 00f4 75E0     		b	.L445
 6854              	.L410:
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 6855              		.loc 25 118 0
 6856 00f6 FFF7FEFF 		bl	_Z15readFloatSerialv
 6857              	.LVL506:
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 6858              		.loc 25 70 0
 6859 00fa 484C     		ldr	r4, .L448+24
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 6860              		.loc 25 118 0
 6861 00fc 484B     		ldr	r3, .L448+28
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void readSerialCommand() {
 6862              		.loc 25 70 0
 6863 00fe 04F11805 		add	r5, r4, #24
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverXmitFactor = readFloatSerial();
 6864              		.loc 25 118 0
 6865 0102 1860     		str	r0, [r3, #0]	@ float
 6866              	.LVL507:
 6867              	.L426:
 6868              	.LBB352:
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         receiverSmoothFactor[channel] = readFloatSerial();
 6869              		.loc 25 120 0 discriminator 2
 6870 0104 FFF7FEFF 		bl	_Z15readFloatSerialv
 6871              	.LVL508:
 6872 0108 44F8040F 		str	r0, [r4, #4]!	@ float
 119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       for(byte channel = XAXIS; channel<LASTCHANNEL; channel++) {
 6873              		.loc 25 119 0 discriminator 2
 6874 010c AC42     		cmp	r4, r5
 6875 010e F9D1     		bne	.L426
 6876 0110 38BD     		pop	{r3, r4, r5, pc}
 6877              	.L411:
 6878              	.LBE352:
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 6879              		.loc 25 125 0
 6880 0112 FFF7FEFF 		bl	_Z15readFloatSerialv
 6881              	.LVL509:
 6882 0116 07EE900A 		fmsr	s15, r0
 6883 011a 424B     		ldr	r3, .L448+32
 6884 011c FDEEE77A 		ftosizs	s15, s15
 6885 0120 C3ED007A 		fsts	s15, [r3, #0]	@ int
 6886 0124 17EE904A 		fmrs	r4, s15	@ int
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverSlope[channelCal] = readFloatSerial();
 6887              		.loc 25 126 0
 6888 0128 FFF7FEFF 		bl	_Z15readFloatSerialv
 6889              	.LVL510:
 6890 012c 3E4B     		ldr	r3, .L448+36
 6891 012e 0DE0     		b	.L444
 6892              	.L412:
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       channelCal = (int)readFloatSerial();
 6893              		.loc 25 130 0
 6894 0130 FFF7FEFF 		bl	_Z15readFloatSerialv
 6895              	.LVL511:
 6896 0134 07EE100A 		fmsr	s14, r0
 6897 0138 3A4B     		ldr	r3, .L448+32
 6898 013a BDEEC77A 		ftosizs	s14, s14
 6899 013e 83ED007A 		fsts	s14, [r3, #0]	@ int
 6900 0142 17EE104A 		fmrs	r4, s14	@ int
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       receiverOffset[channelCal] = readFloatSerial();
 6901              		.loc 25 131 0
 6902 0146 FFF7FEFF 		bl	_Z15readFloatSerialv
 6903              	.LVL512:
 6904 014a 384B     		ldr	r3, .L448+40
 6905              	.L444:
 6906 014c 03EB8404 		add	r4, r3, r4, lsl #2
 6907 0150 2060     		str	r0, [r4, #0]	@ float
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       break;
 6908              		.loc 25 132 0
 6909 0152 38BD     		pop	{r3, r4, r5, pc}
 6910              	.L413:
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       initializeEEPROM(); // defined in DataStorage.h
 6911              		.loc 25 135 0
 6912 0154 FFF7FEFF 		bl	_Z16initializeEEPROMv
 6913              	.LVL513:
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM();
 6914              		.loc 25 136 0
 6915 0158 FFF7FEFF 		bl	_Z11writeEEPROMv
 6916              	.LVL514:
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 6917              		.loc 25 137 0
 6918 015c FFF7FEFF 		bl	_Z24storeSensorsZeroToEEPROMv
 6919              	.LVL515:
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 6920              		.loc 25 138 0
 6921 0160 FFF7FEFF 		bl	_Z13calibrateGyrov
 6922              	.LVL516:
 6923 0164 26E0     		b	.L443
 6924              	.L414:
 6925              	.LBE356:
 6926              	.LBE362:
 6927              	.LBE368:
 6928              	.LBE374:
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6929              		.loc 25 298 0
 6930 0166 BDE83840 		pop	{r3, r4, r5, lr}
 6931              	.LBB375:
 6932              	.LBB369:
 6933              	.LBB363:
 6934              	.LBB357:
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       calibrateGyro();
 6935              		.loc 25 149 0
 6936 016a FFF7FEBF 		b	_Z13calibrateGyrov
 6937              	.LVL517:
 6938              	.L415:
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[XAXIS] = readFloatSerial();
 6939              		.loc 25 153 0
 6940 016e FFF7FEFF 		bl	_Z15readFloatSerialv
 6941              	.LVL518:
 6942 0172 2F4C     		ldr	r4, .L448+44
 6943 0174 2060     		str	r0, [r4, #0]	@ float
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
 6944              		.loc 25 154 0
 6945 0176 FFF7FEFF 		bl	_Z15readFloatSerialv
 6946              	.LVL519:
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[YAXIS] = readFloatSerial();
 6947              		.loc 25 155 0
 6948 017a FFF7FEFF 		bl	_Z15readFloatSerialv
 6949              	.LVL520:
 6950 017e 6060     		str	r0, [r4, #4]	@ float
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
 6951              		.loc 25 156 0
 6952 0180 FFF7FEFF 		bl	_Z15readFloatSerialv
 6953              	.LVL521:
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       accelScaleFactor[ZAXIS] = readFloatSerial();
 6954              		.loc 25 157 0
 6955 0184 FFF7FEFF 		bl	_Z15readFloatSerialv
 6956              	.LVL522:
 6957 0188 A060     		str	r0, [r4, #8]	@ float
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       readFloatSerial();
 6958              		.loc 25 158 0
 6959 018a FFF7FEFF 		bl	_Z15readFloatSerialv
 6960              	.LVL523:
 6961              	.L416:
 164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       computeAccelBias();
 6962              		.loc 25 164 0
 6963 018e FFF7FEFF 		bl	_Z16computeAccelBiasv
 6964              	.LVL524:
 6965              	.LBE357:
 6966              	.LBE363:
 6967              	.LBE369:
 6968              	.LBE375:
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6969              		.loc 25 298 0
 6970 0192 BDE83840 		pop	{r3, r4, r5, lr}
 6971              	.LBB376:
 6972              	.LBB370:
 6973              	.LBB364:
 6974              	.LBB358:
 169:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       storeSensorsZeroToEEPROM();
 6975              		.loc 25 169 0
 6976 0196 FFF7FEBF 		b	_Z24storeSensorsZeroToEEPROMv
 6977              	.LVL525:
 6978              	.L418:
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(3);
 6979              		.loc 25 190 0
 6980 019a 0320     		movs	r0, #3
 6981 019c 00E0     		b	.L446
 6982              	.L420:
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           skipSerialValues(13);
 6983              		.loc 25 228 0
 6984 019e 0D20     		movs	r0, #13
 6985              	.L446:
 6986              	.LBE358:
 6987              	.LBE364:
 6988              	.LBE370:
 6989              	.LBE376:
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 6990              		.loc 25 298 0
 6991 01a0 BDE83840 		pop	{r3, r4, r5, lr}
 6992              	.LBB377:
 6993              	.LBB371:
 6994              	.LBB365:
 6995              	.LBB359:
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           skipSerialValues(13);
 6996              		.loc 25 228 0
 6997 01a4 FFF7FEBF 		b	_Z16skipSerialValuesh
 6998              	.LVL526:
 6999              	.L421:
 238:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(2);
 7000              		.loc 25 238 0
 7001 01a8 0220     		movs	r0, #2
 7002 01aa F9E7     		b	.L446
 7003              	.L422:
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         skipSerialValues(9);
 7004              		.loc 25 249 0
 7005 01ac 0920     		movs	r0, #9
 7006 01ae F7E7     		b	.L446
 7007              	.L423:
 254:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       writeEEPROM(); // defined in DataStorage.h
 7008              		.loc 25 254 0
 7009 01b0 FFF7FEFF 		bl	_Z11writeEEPROMv
 7010              	.LVL527:
 7011              	.L443:
 7012              	.LBE359:
 7013              	.LBE365:
 7014              	.LBE371:
 7015              	.LBE377:
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7016              		.loc 25 298 0
 7017 01b4 BDE83840 		pop	{r3, r4, r5, lr}
 7018              	.LBB378:
 7019              	.LBB372:
 7020              	.LBB366:
 7021              	.LBB360:
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       zeroIntegralError();
 7022              		.loc 25 255 0
 7023 01b8 FFF7FEBF 		b	_Z17zeroIntegralErrorv
 7024              	.LVL528:
 7025              	.L401:
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       validateCalibrateCommand(1);
 7026              		.loc 25 262 0
 7027 01bc 0120     		movs	r0, #1
 7028 01be 00E0     		b	.L447
 7029              	.L402:
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       validateCalibrateCommand(2);
 7030              		.loc 25 266 0
 7031 01c0 0220     		movs	r0, #2
 7032              	.L447:
 7033              	.LBE360:
 7034              	.LBE366:
 7035              	.LBE372:
 7036              	.LBE378:
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7037              		.loc 25 298 0
 7038 01c2 BDE83840 		pop	{r3, r4, r5, lr}
 7039              	.LBB379:
 7040              	.LBB373:
 7041              	.LBB367:
 7042              	.LBB361:
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       validateCalibrateCommand(2);
 7043              		.loc 25 266 0
 7044 01c6 FFF7FEBF 		b	_Z24validateCalibrateCommandh
 7045              	.LVL529:
 7046              	.L403:
 270:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(3)) {
 7047              		.loc 25 270 0
 7048 01ca 0320     		movs	r0, #3
 7049 01cc FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 7050              	.LVL530:
 7051 01d0 0028     		cmp	r0, #0
 7052 01d2 56D0     		beq	.L398
 271:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = readFloatSerial();
 7053              		.loc 25 271 0
 7054 01d4 FFF7FEFF 		bl	_Z15readFloatSerialv
 7055              	.LVL531:
 7056 01d8 07EE100A 		fmsr	s14, r0
 7057 01dc 154B     		ldr	r3, .L448+48
 7058 01de FDEEC77A 		ftosizs	s15, s14
 7059              	.L445:
 7060 01e2 C3ED007A 		fsts	s15, [r3, #0]	@ int
 7061 01e6 38BD     		pop	{r3, r4, r5, pc}
 7062              	.L404:
 276:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(4)) {
 7063              		.loc 25 276 0
 7064 01e8 0420     		movs	r0, #4
 7065 01ea FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 7066              	.LVL532:
 7067 01ee 0028     		cmp	r0, #0
 7068 01f0 47D0     		beq	.L398
 277:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         calibrateESC = 0;
 7069              		.loc 25 277 0
 7070 01f2 114B     		ldr	r3, .L448+52
 7071 01f4 0022     		movs	r2, #0
 7072 01f6 1A70     		strb	r2, [r3, #0]
 278:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         testCommand = 1000;
 7073              		.loc 25 278 0
 7074 01f8 0E4B     		ldr	r3, .L448+48
 7075 01fa 4FF47A72 		mov	r2, #1000
 7076 01fe 1A60     		str	r2, [r3, #0]
 7077 0200 38BD     		pop	{r3, r4, r5, pc}
 7078              	.L449:
 7079 0202 00BF     		.align	2
 7080              	.L448:
 7081 0204 00000000 		.word	SerialUSB
 7082 0208 00000000 		.word	.LANCHOR79
 7083 020c 00000000 		.word	.LANCHOR60
 7084 0210 00000000 		.word	.LANCHOR68
 7085 0214 00000000 		.word	.LANCHOR77
 7086 0218 00000000 		.word	.LANCHOR65
 7087 021c FCFFFFFF 		.word	.LANCHOR9-4
 7088 0220 00000000 		.word	.LANCHOR12
 7089 0224 00000000 		.word	.LANCHOR80
 7090 0228 00000000 		.word	.LANCHOR7
 7091 022c 00000000 		.word	.LANCHOR8
 7092 0230 00000000 		.word	.LANCHOR29
 7093 0234 00000000 		.word	.LANCHOR62
 7094 0238 00000000 		.word	.LANCHOR61
 7095              	.L405:
 7096              	.LBB353:
 283:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 7097              		.loc 25 283 0
 7098 023c 0520     		movs	r0, #5
 7099 023e FFF7FEFF 		bl	_Z24validateCalibrateCommandh
 7100              	.LVL533:
 7101 0242 F0B1     		cbz	r0, .L398
 7102              	.LBB354:
 285:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 7103              		.loc 25 285 0
 7104 0244 0F4D     		ldr	r5, .L450
 7105              	.LBE354:
 283:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (validateCalibrateCommand(5)) {
 7106              		.loc 25 283 0
 7107 0246 0024     		movs	r4, #0
 7108              	.L428:
 7109              	.LBB355:
 285:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           motorConfiguratorCommand[motor] = (int)readFloatSerial();
 7110              		.loc 25 285 0 discriminator 2
 7111 0248 FFF7FEFF 		bl	_Z15readFloatSerialv
 7112              	.LVL534:
 7113 024c 07EE100A 		fmsr	s14, r0
 7114 0250 FDEEC77A 		ftosizs	s15, s14
 7115 0254 17EE903A 		fmrs	r3, s15	@ int
 7116 0258 6351     		str	r3, [r4, r5]
 7117              	.LVL535:
 7118 025a 0434     		adds	r4, r4, #4
 284:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte motor = 0; motor < LASTMOTOR; motor++) {
 7119              		.loc 25 284 0 discriminator 2
 7120 025c 102C     		cmp	r4, #16
 7121 025e F3D1     		bne	.L428
 7122 0260 38BD     		pop	{r3, r4, r5, pc}
 7123              	.L424:
 7124              	.LBE355:
 7125              	.LBE353:
 291:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       if (readFloatSerial() == 1.0)
 7126              		.loc 25 291 0
 7127 0262 FFF7FEFF 		bl	_Z15readFloatSerialv
 7128              	.LVL536:
 7129 0266 07EE100A 		fmsr	s14, r0
 7130 026a F7EE007A 		fconsts	s15, #112
 7131 026e B4EE677A 		fcmps	s14, s15
 7132 0272 F1EE10FA 		fmstat
 7133 0276 044B     		ldr	r3, .L450+4
 7134 0278 01D1     		bne	.L429
 292:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = ON;
 7135              		.loc 25 292 0
 7136 027a 0122     		movs	r2, #1
 7137 027c 00E0     		b	.L442
 7138              	.L429:
 294:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         fastTransfer = OFF;
 7139              		.loc 25 294 0
 7140 027e 0022     		movs	r2, #0
 7141              	.L442:
 7142 0280 1A70     		strb	r2, [r3, #0]
 7143              	.L398:
 7144 0282 38BD     		pop	{r3, r4, r5, pc}
 7145              	.L451:
 7146              		.align	2
 7147              	.L450:
 7148 0284 00000000 		.word	.LANCHOR63
 7149 0288 00000000 		.word	.LANCHOR81
 7150              	.LBE361:
 7151              	.LBE367:
 7152              	.LBE373:
 7153              	.LBE379:
 7154              		.cfi_endproc
 7155              	.LFE205:
 7157              		.section	.text._Z17readIntegerSerialv,"ax",%progbits
 7158              		.align	1
 7159              		.global	_Z17readIntegerSerialv
 7160              		.thumb
 7161              		.thumb_func
 7163              	_Z17readIntegerSerialv:
 7164              	.LFB219:
 760:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 761:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** // Used to read integer values from the serial port
 762:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** long readIntegerSerial() {
 7165              		.loc 25 762 0
 7166              		.cfi_startproc
 7167              		@ args = 0, pretend = 0, frame = 16
 7168              		@ frame_needed = 0, uses_anonymous_args = 0
 7169 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 7170              	.LCFI63:
 7171              		.cfi_def_cfa_offset 24
 7172              		.cfi_offset 0, -24
 7173              		.cfi_offset 1, -20
 7174              		.cfi_offset 2, -16
 7175              		.cfi_offset 3, -12
 7176              		.cfi_offset 4, -8
 7177              		.cfi_offset 14, -4
 7178              	.LBB380:
 763:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   char data[16] = "";
 7179              		.loc 25 763 0
 7180 0002 0021     		movs	r1, #0
 7181 0004 0C22     		movs	r2, #12
 7182 0006 01A8     		add	r0, sp, #4
 7183 0008 0091     		str	r1, [sp, #0]
 7184 000a FFF7FEFF 		bl	memset
 7185              	.LVL537:
 764:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 765:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   readValueSerial(data, sizeof(data));
 7186              		.loc 25 765 0
 7187 000e 6846     		mov	r0, sp
 7188 0010 1021     		movs	r1, #16
 7189 0012 FFF7FEFF 		bl	_Z15readValueSerialPch
 7190              	.LVL538:
 766:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   return atol(data);
 7191              		.loc 25 766 0
 7192 0016 6846     		mov	r0, sp
 7193 0018 FFF7FEFF 		bl	atol
 7194              	.LVL539:
 7195              	.LBE380:
 767:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7196              		.loc 25 767 0
 7197 001c 05B0     		add	sp, sp, #20
 7198 001e 00BD     		pop	{pc}
 7199              		.cfi_endproc
 7200              	.LFE219:
 7202              		.section	.text._Z5commav,"ax",%progbits
 7203              		.align	1
 7204              		.global	_Z5commav
 7205              		.thumb
 7206              		.thumb_func
 7208              	_Z5commav:
 7209              	.LFB220:
 768:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 769:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void comma() {
 7210              		.loc 25 769 0
 7211              		.cfi_startproc
 7212              		@ args = 0, pretend = 0, frame = 0
 7213              		@ frame_needed = 0, uses_anonymous_args = 0
 7214              		@ link register save eliminated.
 770:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(',');
 7215              		.loc 25 770 0
 7216 0000 0148     		ldr	r0, .L454
 7217 0002 2C21     		movs	r1, #44
 771:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7218              		.loc 25 771 0
 770:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(',');
 7219              		.loc 25 770 0
 7220 0004 FFF7FEBF 		b	_ZN5Print5printEc
 7221              	.LVL540:
 7222              	.L455:
 7223              		.align	2
 7224              	.L454:
 7225 0008 00000000 		.word	SerialUSB
 7226              		.cfi_endproc
 7227              	.LFE220:
 7229              		.section	.text._Z15PrintValueCommal,"ax",%progbits
 7230              		.align	1
 7231              		.global	_Z15PrintValueCommal
 7232              		.thumb
 7233              		.thumb_func
 7235              	_Z15PrintValueCommal:
 7236              	.LFB212:
 337:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7237              		.loc 25 337 0
 7238              		.cfi_startproc
 7239              		@ args = 0, pretend = 0, frame = 0
 7240              		@ frame_needed = 0, uses_anonymous_args = 0
 7241              	.LVL541:
 7242 0000 08B5     		push	{r3, lr}
 7243              	.LCFI64:
 7244              		.cfi_def_cfa_offset 8
 7245              		.cfi_offset 3, -8
 7246              		.cfi_offset 14, -4
 337:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7247              		.loc 25 337 0
 7248 0002 0146     		mov	r1, r0
 338:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7249              		.loc 25 338 0
 7250 0004 0A22     		movs	r2, #10
 7251 0006 0348     		ldr	r0, .L457
 7252              	.LVL542:
 7253 0008 FFF7FEFF 		bl	_ZN5Print5printEli
 7254              	.LVL543:
 340:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7255              		.loc 25 340 0
 7256 000c BDE80840 		pop	{r3, lr}
 339:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7257              		.loc 25 339 0
 7258 0010 FFF7FEBF 		b	_Z5commav
 7259              	.LVL544:
 7260              	.L458:
 7261              		.align	2
 7262              	.L457:
 7263 0014 00000000 		.word	SerialUSB
 7264              		.cfi_endproc
 7265              	.LFE212:
 7267              		.section	.text._Z15PrintValueCommah,"ax",%progbits
 7268              		.align	1
 7269              		.global	_Z15PrintValueCommah
 7270              		.thumb
 7271              		.thumb_func
 7273              	_Z15PrintValueCommah:
 7274              	.LFB211:
 331:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7275              		.loc 25 331 0
 7276              		.cfi_startproc
 7277              		@ args = 0, pretend = 0, frame = 0
 7278              		@ frame_needed = 0, uses_anonymous_args = 0
 7279              	.LVL545:
 7280 0000 08B5     		push	{r3, lr}
 7281              	.LCFI65:
 7282              		.cfi_def_cfa_offset 8
 7283              		.cfi_offset 3, -8
 7284              		.cfi_offset 14, -4
 331:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7285              		.loc 25 331 0
 7286 0002 0146     		mov	r1, r0
 332:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7287              		.loc 25 332 0
 7288 0004 0A22     		movs	r2, #10
 7289 0006 0348     		ldr	r0, .L460
 7290              	.LVL546:
 7291 0008 FFF7FEFF 		bl	_ZN5Print5printEhi
 7292              	.LVL547:
 334:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7293              		.loc 25 334 0
 7294 000c BDE80840 		pop	{r3, lr}
 333:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7295              		.loc 25 333 0
 7296 0010 FFF7FEBF 		b	_Z5commav
 7297              	.LVL548:
 7298              	.L461:
 7299              		.align	2
 7300              	.L460:
 7301 0014 00000000 		.word	SerialUSB
 7302              		.cfi_endproc
 7303              	.LFE211:
 7305              		.section	.text._Z15PrintValueCommam,"ax",%progbits
 7306              		.align	1
 7307              		.global	_Z15PrintValueCommam
 7308              		.thumb
 7309              		.thumb_func
 7311              	_Z15PrintValueCommam:
 7312              	.LFB210:
 325:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7313              		.loc 25 325 0
 7314              		.cfi_startproc
 7315              		@ args = 0, pretend = 0, frame = 0
 7316              		@ frame_needed = 0, uses_anonymous_args = 0
 7317              	.LVL549:
 7318 0000 08B5     		push	{r3, lr}
 7319              	.LCFI66:
 7320              		.cfi_def_cfa_offset 8
 7321              		.cfi_offset 3, -8
 7322              		.cfi_offset 14, -4
 325:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7323              		.loc 25 325 0
 7324 0002 0146     		mov	r1, r0
 326:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7325              		.loc 25 326 0
 7326 0004 0A22     		movs	r2, #10
 7327 0006 0348     		ldr	r0, .L463
 7328              	.LVL550:
 7329 0008 FFF7FEFF 		bl	_ZN5Print5printEmi
 7330              	.LVL551:
 328:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7331              		.loc 25 328 0
 7332 000c BDE80840 		pop	{r3, lr}
 327:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7333              		.loc 25 327 0
 7334 0010 FFF7FEBF 		b	_Z5commav
 7335              	.LVL552:
 7336              	.L464:
 7337              		.align	2
 7338              	.L463:
 7339 0014 00000000 		.word	SerialUSB
 7340              		.cfi_endproc
 7341              	.LFE210:
 7343              		.section	.text._Z15PrintValueCommai,"ax",%progbits
 7344              		.align	1
 7345              		.global	_Z15PrintValueCommai
 7346              		.thumb
 7347              		.thumb_func
 7349              	_Z15PrintValueCommai:
 7350              	.LFB209:
 319:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 7351              		.loc 25 319 0
 7352              		.cfi_startproc
 7353              		@ args = 0, pretend = 0, frame = 0
 7354              		@ frame_needed = 0, uses_anonymous_args = 0
 7355              	.LVL553:
 7356 0000 08B5     		push	{r3, lr}
 7357              	.LCFI67:
 7358              		.cfi_def_cfa_offset 8
 7359              		.cfi_offset 3, -8
 7360              		.cfi_offset 14, -4
 319:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(int val) {
 7361              		.loc 25 319 0
 7362 0002 0146     		mov	r1, r0
 320:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7363              		.loc 25 320 0
 7364 0004 0A22     		movs	r2, #10
 7365 0006 0348     		ldr	r0, .L466
 7366              	.LVL554:
 7367 0008 FFF7FEFF 		bl	_ZN5Print5printEii
 7368              	.LVL555:
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7369              		.loc 25 322 0
 7370 000c BDE80840 		pop	{r3, lr}
 321:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7371              		.loc 25 321 0
 7372 0010 FFF7FEBF 		b	_Z5commav
 7373              	.LVL556:
 7374              	.L467:
 7375              		.align	2
 7376              	.L466:
 7377 0014 00000000 		.word	SerialUSB
 7378              		.cfi_endproc
 7379              	.LFE209:
 7381              		.section	.text._Z16PrintDummyValuesh,"ax",%progbits
 7382              		.align	1
 7383              		.global	_Z16PrintDummyValuesh
 7384              		.thumb
 7385              		.thumb_func
 7387              	_Z16PrintDummyValuesh:
 7388              	.LFB214:
 349:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintDummyValues(byte number) {
 7389              		.loc 25 349 0
 7390              		.cfi_startproc
 7391              		@ args = 0, pretend = 0, frame = 0
 7392              		@ frame_needed = 0, uses_anonymous_args = 0
 7393              	.LVL557:
 7394 0000 38B5     		push	{r3, r4, r5, lr}
 7395              	.LCFI68:
 7396              		.cfi_def_cfa_offset 16
 7397              		.cfi_offset 3, -16
 7398              		.cfi_offset 4, -12
 7399              		.cfi_offset 5, -8
 7400              		.cfi_offset 14, -4
 349:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintDummyValues(byte number) {
 7401              		.loc 25 349 0
 7402 0002 0546     		mov	r5, r0
 7403              	.LBB381:
 350:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 7404              		.loc 25 350 0
 7405 0004 0024     		movs	r4, #0
 7406 0006 04E0     		b	.L469
 7407              	.LVL558:
 7408              	.L470:
 351:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(0);
 7409              		.loc 25 351 0 discriminator 2
 7410 0008 0020     		movs	r0, #0
 7411 000a FFF7FEFF 		bl	_Z15PrintValueCommai
 7412              	.LVL559:
 350:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 7413              		.loc 25 350 0 discriminator 2
 7414 000e 0134     		adds	r4, r4, #1
 7415              	.LVL560:
 7416 0010 E4B2     		uxtb	r4, r4
 7417              	.LVL561:
 7418              	.L469:
 350:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   for(byte i=0; i<number; i++) {
 7419              		.loc 25 350 0 is_stmt 0 discriminator 1
 7420 0012 AC42     		cmp	r4, r5
 7421 0014 F8D1     		bne	.L470
 7422              	.LBE381:
 353:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7423              		.loc 25 353 0 is_stmt 1
 7424 0016 38BD     		pop	{r3, r4, r5, pc}
 7425              		.cfi_endproc
 7426              	.LFE214:
 7428              		.section	.text._Z15PrintValueCommac,"ax",%progbits
 7429              		.align	1
 7430              		.global	_Z15PrintValueCommac
 7431              		.thumb
 7432              		.thumb_func
 7434              	_Z15PrintValueCommac:
 7435              	.LFB208:
 314:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 7436              		.loc 25 314 0
 7437              		.cfi_startproc
 7438              		@ args = 0, pretend = 0, frame = 0
 7439              		@ frame_needed = 0, uses_anonymous_args = 0
 7440              	.LVL562:
 7441 0000 08B5     		push	{r3, lr}
 7442              	.LCFI69:
 7443              		.cfi_def_cfa_offset 8
 7444              		.cfi_offset 3, -8
 7445              		.cfi_offset 14, -4
 314:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(char val) {
 7446              		.loc 25 314 0
 7447 0002 0146     		mov	r1, r0
 315:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7448              		.loc 25 315 0
 7449 0004 0348     		ldr	r0, .L472
 7450              	.LVL563:
 7451 0006 FFF7FEFF 		bl	_ZN5Print5printEc
 7452              	.LVL564:
 317:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7453              		.loc 25 317 0
 7454 000a BDE80840 		pop	{r3, lr}
 316:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7455              		.loc 25 316 0
 7456 000e FFF7FEBF 		b	_Z5commav
 7457              	.LVL565:
 7458              	.L473:
 7459 0012 00BF     		.align	2
 7460              	.L472:
 7461 0014 00000000 		.word	SerialUSB
 7462              		.cfi_endproc
 7463              	.LFE208:
 7465              		.section	.text._Z15PrintValueCommad,"ax",%progbits
 7466              		.align	1
 7467              		.global	_Z15PrintValueCommad
 7468              		.thumb
 7469              		.thumb_func
 7471              	_Z15PrintValueCommad:
 7472              	.LFB207:
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 7473              		.loc 25 309 0
 7474              		.cfi_startproc
 7475              		@ args = 0, pretend = 0, frame = 0
 7476              		@ frame_needed = 0, uses_anonymous_args = 0
 7477              	.LVL566:
 7478 0000 07B5     		push	{r0, r1, r2, lr}
 7479              	.LCFI70:
 7480              		.cfi_def_cfa_offset 16
 7481              		.cfi_offset 0, -16
 7482              		.cfi_offset 1, -12
 7483              		.cfi_offset 2, -8
 7484              		.cfi_offset 14, -4
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 7485              		.loc 25 309 0
 7486 0002 0B46     		mov	r3, r1
 310:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7487              		.loc 25 310 0
 7488 0004 0221     		movs	r1, #2
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(double val) {
 7489              		.loc 25 309 0
 7490 0006 0246     		mov	r2, r0
 310:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7491              		.loc 25 310 0
 7492 0008 0091     		str	r1, [sp, #0]
 7493 000a 0448     		ldr	r0, .L475
 7494              	.LVL567:
 7495 000c FFF7FEFF 		bl	_ZN5Print5printEdi
 7496              	.LVL568:
 312:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7497              		.loc 25 312 0
 7498 0010 03B0     		add	sp, sp, #12
 7499 0012 5DF804EB 		pop	{lr}
 311:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7500              		.loc 25 311 0
 7501 0016 FFF7FEBF 		b	_Z5commav
 7502              	.LVL569:
 7503              	.L476:
 7504 001a 00BF     		.align	2
 7505              	.L475:
 7506 001c 00000000 		.word	SerialUSB
 7507              		.cfi_endproc
 7508              	.LFE207:
 7510              		.section	.text._Z15PrintValueCommaf,"ax",%progbits
 7511              		.align	1
 7512              		.global	_Z15PrintValueCommaf
 7513              		.thumb
 7514              		.thumb_func
 7516              	_Z15PrintValueCommaf:
 7517              	.LFB206:
 304:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void PrintValueComma(float val) {
 7518              		.loc 25 304 0
 7519              		.cfi_startproc
 7520              		@ args = 0, pretend = 0, frame = 0
 7521              		@ frame_needed = 0, uses_anonymous_args = 0
 7522              	.LVL570:
 7523 0000 07B5     		push	{r0, r1, r2, lr}
 7524              	.LCFI71:
 7525              		.cfi_def_cfa_offset 16
 7526              		.cfi_offset 0, -16
 7527              		.cfi_offset 1, -12
 7528              		.cfi_offset 2, -8
 7529              		.cfi_offset 14, -4
 305:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(val);
 7530              		.loc 25 305 0
 7531 0002 FFF7FEFF 		bl	__aeabi_f2d
 7532              	.LVL571:
 7533 0006 0B46     		mov	r3, r1
 7534 0008 0221     		movs	r1, #2
 7535 000a 0246     		mov	r2, r0
 7536 000c 0091     		str	r1, [sp, #0]
 7537 000e 0448     		ldr	r0, .L478
 7538 0010 FFF7FEFF 		bl	_ZN5Print5printEdi
 7539              	.LVL572:
 307:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7540              		.loc 25 307 0
 7541 0014 03B0     		add	sp, sp, #12
 7542 0016 5DF804EB 		pop	{lr}
 306:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   comma();
 7543              		.loc 25 306 0
 7544 001a FFF7FEBF 		b	_Z5commav
 7545              	.LVL573:
 7546              	.L479:
 7547 001e 00BF     		.align	2
 7548              	.L478:
 7549 0020 00000000 		.word	SerialUSB
 7550              		.cfi_endproc
 7551              	.LFE206:
 7553              		.section	.text._Z8PrintPIDh,"ax",%progbits
 7554              		.align	1
 7555              		.global	_Z8PrintPIDh
 7556              		.thumb
 7557              		.thumb_func
 7559              	_Z8PrintPIDh:
 7560              	.LFB213:
 343:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7561              		.loc 25 343 0
 7562              		.cfi_startproc
 7563              		@ args = 0, pretend = 0, frame = 0
 7564              		@ frame_needed = 0, uses_anonymous_args = 0
 7565              	.LVL574:
 344:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 7566              		.loc 25 344 0
 7567 0000 074B     		ldr	r3, .L481
 343:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 7568              		.loc 25 343 0
 7569 0002 10B5     		push	{r4, lr}
 7570              	.LCFI72:
 7571              		.cfi_def_cfa_offset 8
 7572              		.cfi_offset 4, -8
 7573              		.cfi_offset 14, -4
 344:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].P);
 7574              		.loc 25 344 0
 7575 0004 1824     		movs	r4, #24
 7576 0006 04FB0034 		mla	r4, r4, r0, r3
 7577 000a 2068     		ldr	r0, [r4, #0]	@ float
 7578              	.LVL575:
 7579 000c FFF7FEFF 		bl	_Z15PrintValueCommaf
 7580              	.LVL576:
 345:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].I);
 7581              		.loc 25 345 0
 7582 0010 6068     		ldr	r0, [r4, #4]	@ float
 7583 0012 FFF7FEFF 		bl	_Z15PrintValueCommaf
 7584              	.LVL577:
 346:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 7585              		.loc 25 346 0
 7586 0016 A068     		ldr	r0, [r4, #8]	@ float
 347:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7587              		.loc 25 347 0
 7588 0018 BDE81040 		pop	{r4, lr}
 346:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   PrintValueComma(PID[IDPid].D);
 7589              		.loc 25 346 0
 7590 001c FFF7FEBF 		b	_Z15PrintValueCommaf
 7591              	.LVL578:
 7592              	.L482:
 7593              		.align	2
 7594              	.L481:
 7595 0020 00000000 		.word	.LANCHOR15
 7596              		.cfi_endproc
 7597              	.LFE213:
 7599              		.section	.text._Z17printVehicleStatePKcmS0_,"ax",%progbits
 7600              		.align	1
 7601              		.global	_Z17printVehicleStatePKcmS0_
 7602              		.thumb
 7603              		.thumb_func
 7605              	_Z17printVehicleStatePKcmS0_:
 7606              	.LFB221:
 772:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 773:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 774:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #ifdef BinaryWrite
 775:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void printInt(int data) {
 776:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   byte msb, lsb;
 777:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 778:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   msb = data >> 8;
 779:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   lsb = data & 0xff;
 780:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 781:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(msb);
 782:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(lsb);
 783:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 784:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 785:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendBinaryFloat(float data) {
 786:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   union binaryFloatType {
 787:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     byte floatByte[4];
 788:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     float floatVal;
 789:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   } binaryFloat;
 790:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 791:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryFloat.floatVal = data;
 792:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[3]);
 793:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[2]);
 794:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[1]);
 795:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryFloat.floatByte[0]);
 796:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 797:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 798:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendBinaryuslong(unsigned long data) {
 799:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   union binaryuslongType {
 800:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     byte uslongByte[4];
 801:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     unsigned long uslongVal;
 802:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   } binaryuslong;
 803:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 804:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryuslong.uslongVal = data;
 805:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[3]);
 806:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[2]);
 807:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[1]);
 808:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   binaryPort->write(binaryuslong.uslongByte[0]);
 809:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 810:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 811:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 812:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void fastTelemetry()
 813:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** {
 814:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // **************************************************************
 815:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // ***************** Fast Transfer Of Sensor Data ***************
 816:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // **************************************************************
 817:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // AeroQuad.h defines the output rate to be 10ms
 818:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // Since writing to UART is done by hardware, unable to measure data rate directly
 819:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // Through analysis:  115200 baud = 115200 bits/second = 14400 bytes/second
 820:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // If float = 4 bytes, then 3600 floats/second
 821:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // If 10 ms output rate, then 36 floats/10ms
 822:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // Number of floats written using sendBinaryFloat is 15
 823:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 824:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (motorArmed == ON) {
 825:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #ifdef OpenlogBinaryWrite
 826:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(21845); // Start word of 0x5555
 827:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        sendBinaryuslong(currentTime);
 828:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         printInt((int)flightMode);
 829:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 830:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 831:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 832:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 833:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 834:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 835:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        sendBinaryFloat(accelOneG);
 836:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        #ifdef HeadingMagHold
 837:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(hdgX);
 838:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(hdgY);
 839:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 		  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 840:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 		       #if defined(HeadingMagHold)
 841:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 			      sendBinaryFloat(getMagnetometerData(axis));
 842:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 		       #endif
 843:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           }
 844:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        #else
 845:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 846:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 847:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0.0);
 848:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        #endif
 849:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 850:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****           sendBinaryFloat(kinematicsAngle[axis]);
 851:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         }
 852:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         printInt(32767); // Stop word of 0x7FFF
 853:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #else
 854:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(21845); // Start word of 0x5555
 855:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 856:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(gyroRate[axis]);
 857:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 858:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 859:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(meterPerSecSec[axis]);
 860:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 861:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++)
 862:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        #if defined(HeadingMagHold)
 863:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(getMagnetometerData(axis));
 864:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        #else
 865:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(0);
 866:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        #endif
 867:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 868:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(getGyroUnbias(axis));
 869:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 870:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
 871:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****          sendBinaryFloat(kinematicsAngle[axis]);
 872:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        }
 873:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****        printInt(32767); // Stop word of 0x7FFF
 874:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     #endif
 875:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 876:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 877:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #endif // BinaryWrite
 878:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 879:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 7607              		.loc 25 879 0
 7608              		.cfi_startproc
 7609              		@ args = 0, pretend = 0, frame = 0
 7610              		@ frame_needed = 0, uses_anonymous_args = 0
 7611              	.LVL579:
 7612 0000 38B5     		push	{r3, r4, r5, lr}
 7613              	.LCFI73:
 7614              		.cfi_def_cfa_offset 16
 7615              		.cfi_offset 3, -16
 7616              		.cfi_offset 4, -12
 7617              		.cfi_offset 5, -8
 7618              		.cfi_offset 14, -4
 7619              		.loc 25 879 0
 7620 0002 0346     		mov	r3, r0
 7621 0004 0D46     		mov	r5, r1
 880:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   
 881:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(sensorName);
 7622              		.loc 25 881 0
 7623 0006 0B48     		ldr	r0, .L485
 7624              	.LVL580:
 7625 0008 1946     		mov	r1, r3
 7626              	.LVL581:
 879:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void printVehicleState(const char *sensorName, unsigned long state, const char *message) {
 7627              		.loc 25 879 0
 7628 000a 1446     		mov	r4, r2
 7629              		.loc 25 881 0
 7630 000c FFF7FEFF 		bl	_ZN5Print5printEPKc
 7631              	.LVL582:
 882:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT(": ");
 7632              		.loc 25 882 0
 7633 0010 0848     		ldr	r0, .L485
 7634 0012 0949     		ldr	r1, .L485+4
 7635 0014 FFF7FEFF 		bl	_ZN5Print5printEPKc
 7636              	.LVL583:
 883:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (!(vehicleState & state)) {
 7637              		.loc 25 883 0
 7638 0018 084B     		ldr	r3, .L485+8
 7639 001a 1B68     		ldr	r3, [r3, #0]
 7640 001c 1D42     		tst	r5, r3
 7641 001e 03D1     		bne	.L484
 884:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT("Not ");
 7642              		.loc 25 884 0
 7643 0020 0448     		ldr	r0, .L485
 7644 0022 0749     		ldr	r1, .L485+12
 7645 0024 FFF7FEFF 		bl	_ZN5Print5printEPKc
 7646              	.LVL584:
 7647              	.L484:
 885:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 886:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(message);
 7648              		.loc 25 886 0
 7649 0028 0248     		ldr	r0, .L485
 7650 002a 2146     		mov	r1, r4
 887:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7651              		.loc 25 887 0
 7652 002c BDE83840 		pop	{r3, r4, r5, lr}
 886:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(message);
 7653              		.loc 25 886 0
 7654 0030 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 7655              	.LVL585:
 7656              	.L486:
 7657              		.align	2
 7658              	.L485:
 7659 0034 00000000 		.word	SerialUSB
 7660 0038 00000000 		.word	.LC0
 7661 003c 00000000 		.word	.LANCHOR18
 7662 0040 03000000 		.word	.LC1
 7663              		.cfi_endproc
 7664              	.LFE221:
 7666              		.section	.text._Z18reportVehicleStatev,"ax",%progbits
 7667              		.align	1
 7668              		.global	_Z18reportVehicleStatev
 7669              		.thumb
 7670              		.thumb_func
 7672              	_Z18reportVehicleStatev:
 7673              	.LFB222:
 888:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 889:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void reportVehicleState() {
 7674              		.loc 25 889 0
 7675              		.cfi_startproc
 7676              		@ args = 0, pretend = 0, frame = 0
 7677              		@ frame_needed = 0, uses_anonymous_args = 0
 7678 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 7679              	.LCFI74:
 7680              		.cfi_def_cfa_offset 24
 7681              		.cfi_offset 0, -24
 7682              		.cfi_offset 1, -20
 7683              		.cfi_offset 4, -16
 7684              		.cfi_offset 5, -12
 7685              		.cfi_offset 6, -8
 7686              		.cfi_offset 14, -4
 890:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   // Tell Configurator how many vehicle state values to expect
 891:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(15);
 7687              		.loc 25 891 0
 7688 0002 374C     		ldr	r4, .L488+8
 892:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Software Version: ");
 893:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 894:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Board Type: ");
 895:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(AeroQuad_v18)
 896:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("v1.8 and greater");
 897:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuad_Mini)
 898:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mini");
 899:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(MWCFlip15)
 900:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("MWCFlip15");
 901:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v2)
 902:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v2");
 903:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadMega_v21)
 904:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Mega v21");
 905:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(MWCProEz30)
 906:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("MWCProEz30");    
 907:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(AeroQuadSTM32)
 908:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(STM32_BOARD_TYPE);
 909:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(Naze32)
 910:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Naze32");
 911:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 912:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 913:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Flight Config: ");
 914:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #if defined(quadPlusConfig)
 915:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad +");
 916:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(quadXConfig)
 917:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad X");
 918:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined (quadY4Config)
 919:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad Y4");
 920:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined (triConfig)
 921:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Tri");
 922:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexPlusConfig)
 923:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex +");
 924:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexXConfig)
 925:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex X");
 926:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(hexY6Config)
 927:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Hex Y6");
 928:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoX8Config)
 929:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X8");
 930:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoXConfig)
 931:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo X");
 932:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #elif defined(octoPlusConfig)
 933:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Octo +");
 934:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   #endif
 935:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 936:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Receiver Channels: ");
 937:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTCHANNEL);
 938:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 939:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Motors: ");
 940:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTMOTOR);
 941:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** 
 942:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Gyroscope", GYRO_DETECTED, "Detected");
 7689              		.loc 25 942 0
 7690 0004 374D     		ldr	r5, .L488+12
 891:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(15);
 7691              		.loc 25 891 0
 7692 0006 0A22     		movs	r2, #10
 7693 0008 2046     		mov	r0, r4
 7694 000a 0F21     		movs	r1, #15
 7695 000c FFF7FEFF 		bl	_ZN5Print7printlnEii
 7696              	.LVL586:
 893:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 7697              		.loc 25 893 0
 7698 0010 0126     		movs	r6, #1
 892:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Software Version: ");
 7699              		.loc 25 892 0
 7700 0012 2046     		mov	r0, r4
 7701 0014 3449     		ldr	r1, .L488+16
 7702 0016 FFF7FEFF 		bl	_ZN5Print5printEPKc
 7703              	.LVL587:
 893:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 7704              		.loc 25 893 0
 7705 001a 2FA3     		adr	r3, .L488
 7706 001c D3E90023 		ldrd	r2, [r3]
 7707 0020 2046     		mov	r0, r4
 7708 0022 0096     		str	r6, [sp, #0]
 7709 0024 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 7710              	.LVL588:
 894:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Board Type: ");
 7711              		.loc 25 894 0
 7712 0028 2046     		mov	r0, r4
 7713 002a 3049     		ldr	r1, .L488+20
 7714 002c FFF7FEFF 		bl	_ZN5Print5printEPKc
 7715              	.LVL589:
 908:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(STM32_BOARD_TYPE);
 7716              		.loc 25 908 0
 7717 0030 2046     		mov	r0, r4
 7718 0032 2F49     		ldr	r1, .L488+24
 7719 0034 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 7720              	.LVL590:
 913:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Flight Config: ");
 7721              		.loc 25 913 0
 7722 0038 2046     		mov	r0, r4
 7723 003a 2E49     		ldr	r1, .L488+28
 7724 003c FFF7FEFF 		bl	_ZN5Print5printEPKc
 7725              	.LVL591:
 917:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN("Quad X");
 7726              		.loc 25 917 0
 7727 0040 2046     		mov	r0, r4
 7728 0042 2D49     		ldr	r1, .L488+32
 7729 0044 FFF7FEFF 		bl	_ZN5Print7printlnEPKc
 7730              	.LVL592:
 936:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Receiver Channels: ");
 7731              		.loc 25 936 0
 7732 0048 2046     		mov	r0, r4
 7733 004a 2C49     		ldr	r1, .L488+36
 7734 004c FFF7FEFF 		bl	_ZN5Print5printEPKc
 7735              	.LVL593:
 937:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTCHANNEL);
 7736              		.loc 25 937 0
 7737 0050 0A22     		movs	r2, #10
 7738 0052 2046     		mov	r0, r4
 7739 0054 0621     		movs	r1, #6
 7740 0056 FFF7FEFF 		bl	_ZN5Print7printlnEii
 7741              	.LVL594:
 939:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("Motors: ");
 7742              		.loc 25 939 0
 7743 005a 2046     		mov	r0, r4
 7744 005c 2849     		ldr	r1, .L488+40
 7745 005e FFF7FEFF 		bl	_ZN5Print5printEPKc
 7746              	.LVL595:
 940:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(LASTMOTOR);
 7747              		.loc 25 940 0
 7748 0062 2046     		mov	r0, r4
 7749 0064 0421     		movs	r1, #4
 7750 0066 0A22     		movs	r2, #10
 7751 0068 FFF7FEFF 		bl	_ZN5Print7printlnEii
 7752              	.LVL596:
 7753              		.loc 25 942 0
 7754 006c 3146     		mov	r1, r6
 7755 006e 2A46     		mov	r2, r5
 7756 0070 2448     		ldr	r0, .L488+44
 7757 0072 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7758              	.LVL597:
 943:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Accelerometer", ACCEL_DETECTED, "Detected");
 7759              		.loc 25 943 0
 7760 0076 0221     		movs	r1, #2
 7761 0078 2A46     		mov	r2, r5
 7762 007a 2348     		ldr	r0, .L488+48
 7763 007c FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7764              	.LVL598:
 944:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Barometer", BARO_DETECTED, "Detected");
 7765              		.loc 25 944 0
 7766 0080 0821     		movs	r1, #8
 7767 0082 2A46     		mov	r2, r5
 7768 0084 2148     		ldr	r0, .L488+52
 7769 0086 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7770              	.LVL599:
 945:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Magnetometer", MAG_DETECTED, "Detected");
 7771              		.loc 25 945 0
 7772 008a 2A46     		mov	r2, r5
 946:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Heading Hold", HEADINGHOLD_ENABLED, "Enabled");
 7773              		.loc 25 946 0
 7774 008c 204D     		ldr	r5, .L488+56
 945:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Magnetometer", MAG_DETECTED, "Detected");
 7775              		.loc 25 945 0
 7776 008e 2148     		ldr	r0, .L488+60
 7777 0090 0421     		movs	r1, #4
 7778 0092 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7779              	.LVL600:
 7780              		.loc 25 946 0
 7781 0096 1021     		movs	r1, #16
 7782 0098 2A46     		mov	r2, r5
 7783 009a 1F48     		ldr	r0, .L488+64
 7784 009c FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7785              	.LVL601:
 947:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Altitude Hold", ALTITUDEHOLD_ENABLED, "Enabled");
 7786              		.loc 25 947 0
 7787 00a0 2021     		movs	r1, #32
 7788 00a2 2A46     		mov	r2, r5
 7789 00a4 1D48     		ldr	r0, .L488+68
 7790 00a6 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7791              	.LVL602:
 948:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Battery Monitor", BATTMONITOR_ENABLED, "Enabled");
 7792              		.loc 25 948 0
 7793 00aa 4021     		movs	r1, #64
 7794 00ac 2A46     		mov	r2, r5
 7795 00ae 1C48     		ldr	r0, .L488+72
 7796 00b0 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7797              	.LVL603:
 949:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Camera Stability", CAMERASTABLE_ENABLED, "Enabled");
 7798              		.loc 25 949 0
 7799 00b4 8021     		movs	r1, #128
 7800 00b6 2A46     		mov	r2, r5
 7801 00b8 1A48     		ldr	r0, .L488+76
 7802 00ba FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7803              	.LVL604:
 950:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   printVehicleState("Range Detection", RANGE_ENABLED, "Enabled");
 7804              		.loc 25 950 0
 7805 00be 1A48     		ldr	r0, .L488+80
 7806 00c0 4FF48071 		mov	r1, #256
 7807 00c4 2A46     		mov	r2, r5
 7808 00c6 FFF7FEFF 		bl	_Z17printVehicleStatePKcmS0_
 7809              	.LVL605:
 951:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #ifdef UseGPS
 952:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("GPS: ");
 953:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT((gpsData.state==GPS_DETECTING)?"Scanning ":"Detected ");
 954:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   if (gpsData.state != GPS_DETECTING) {
 955:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(gpsTypes[gpsData.type].name);
 956:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   }
 957:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINT("@");
 958:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN(gpsBaudRates[gpsData.baudrate]);
 959:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #else
 960:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN("GPS: Not Enabled");
 7810              		.loc 25 960 0
 7811 00ca 1849     		ldr	r1, .L488+84
 7812 00cc 2046     		mov	r0, r4
 961:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** #endif
 962:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 7813              		.loc 25 962 0
 7814 00ce 02B0     		add	sp, sp, #8
 7815 00d0 BDE87040 		pop	{r4, r5, r6, lr}
 960:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   SERIAL_PRINTLN("GPS: Not Enabled");
 7816              		.loc 25 960 0
 7817 00d4 FFF7FEBF 		b	_ZN5Print7printlnEPKc
 7818              	.LVL606:
 7819              	.L489:
 7820              		.align	3
 7821              	.L488:
 7822 00d8 000000A0 		.word	-1610612736
 7823 00dc 99990940 		.word	1074370969
 7824 00e0 00000000 		.word	SerialUSB
 7825 00e4 71000000 		.word	.LC10
 7826 00e8 08000000 		.word	.LC2
 7827 00ec 1B000000 		.word	.LC3
 7828 00f0 28000000 		.word	.LC4
 7829 00f4 33000000 		.word	.LC5
 7830 00f8 43000000 		.word	.LC6
 7831 00fc 4A000000 		.word	.LC7
 7832 0100 5E000000 		.word	.LC8
 7833 0104 67000000 		.word	.LC9
 7834 0108 7A000000 		.word	.LC11
 7835 010c 88000000 		.word	.LC12
 7836 0110 AC000000 		.word	.LC15
 7837 0114 92000000 		.word	.LC13
 7838 0118 9F000000 		.word	.LC14
 7839 011c B4000000 		.word	.LC16
 7840 0120 C2000000 		.word	.LC17
 7841 0124 D2000000 		.word	.LC18
 7842 0128 E3000000 		.word	.LC19
 7843 012c F3000000 		.word	.LC20
 7844              		.cfi_endproc
 7845              	.LFE222:
 7847              		.section	.text._Z19sendSerialTelemetryv,"ax",%progbits
 7848              		.align	1
 7849              		.global	_Z19sendSerialTelemetryv
 7850              		.thumb
 7851              		.thumb_func
 7853              	_Z19sendSerialTelemetryv:
 7854              	.LFB216:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 7855              		.loc 25 369 0
 7856              		.cfi_startproc
 7857              		@ args = 0, pretend = 0, frame = 0
 7858              		@ frame_needed = 0, uses_anonymous_args = 0
 7859 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 7860              	.LCFI75:
 7861              		.cfi_def_cfa_offset 32
 7862              		.cfi_offset 0, -32
 7863              		.cfi_offset 1, -28
 7864              		.cfi_offset 2, -24
 7865              		.cfi_offset 4, -20
 7866              		.cfi_offset 5, -16
 7867              		.cfi_offset 6, -12
 7868              		.cfi_offset 7, -8
 7869              		.cfi_offset 14, -4
 7870              	.LBB382:
 370:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 7871              		.loc 25 370 0
 7872 0002 AC4C     		ldr	r4, .L555
 7873 0004 2378     		ldrb	r3, [r4, #0]	@ zero_extendqisi2
 7874 0006 6B2B     		cmp	r3, #107
 7875 0008 00F0E080 		beq	.L506
 7876 000c 2FD8     		bhi	.L520
 7877 000e 632B     		cmp	r3, #99
 7878 0010 00F08D80 		beq	.L499
 7879 0014 18D8     		bhi	.L521
 7880 0016 362B     		cmp	r3, #54
 7881 0018 00F0E381 		beq	.L534
 7882 001c 0ED8     		bhi	.L522
 7883 001e 232B     		cmp	r3, #35
 7884 0020 00F0DA81 		beq	.L493
 7885 0024 03D8     		bhi	.L523
 7886 0026 212B     		cmp	r3, #33
 7887 0028 40F0E981 		bne	.L490
 7888 002c CBE1     		b	.L492
 7889              	.L523:
 7890 002e 242B     		cmp	r3, #36
 7891 0030 00F0BD81 		beq	.L494
 7892 0034 252B     		cmp	r3, #37
 7893 0036 40F0E281 		bne	.L490
 7894 003a BCE1     		b	.L495
 7895              	.L522:
 7896 003c 612B     		cmp	r3, #97
 7897 003e 5ED0     		beq	.L497
 7898 0040 622B     		cmp	r3, #98
 7899 0042 40F0DC81 		bne	.L490
 7900 0046 65E0     		b	.L498
 7901              	.L521:
 7902 0048 662B     		cmp	r3, #102
 7903 004a 00F08480 		beq	.L502
 7904 004e 05D8     		bhi	.L524
 7905 0050 642B     		cmp	r3, #100
 7906 0052 76D0     		beq	.L500
 7907 0054 652B     		cmp	r3, #101
 7908 0056 40F0D281 		bne	.L490
 7909 005a 74E0     		b	.L501
 7910              	.L524:
 7911 005c 682B     		cmp	r3, #104
 7912 005e 00F0A080 		beq	.L504
 7913 0062 C0F08980 		bcc	.L503
 7914 0066 692B     		cmp	r3, #105
 7915 0068 40F0C981 		bne	.L490
 7916 006c 29E0     		b	.L505
 7917              	.L520:
 7918 006e 722B     		cmp	r3, #114
 7919 0070 00F00C81 		beq	.L513
 7920 0074 10D8     		bhi	.L525
 7921 0076 6E2B     		cmp	r3, #110
 7922 0078 00F0FB80 		beq	.L509
 7923 007c 06D8     		bhi	.L526
 7924 007e 6C2B     		cmp	r3, #108
 7925 0080 00F0E680 		beq	.L507
 7926 0084 6D2B     		cmp	r3, #109
 7927 0086 40F0BA81 		bne	.L490
 7928 008a A7E1     		b	.L545
 7929              	.L526:
 7930 008c 702B     		cmp	r3, #112
 7931 008e 00F0F480 		beq	.L511
 7932 0092 00F2F480 		bhi	.L512
 7933 0096 EEE0     		b	.L544
 7934              	.L525:
 7935 0098 752B     		cmp	r3, #117
 7936 009a 00F07281 		beq	.L516
 7937 009e 06D8     		bhi	.L527
 7938 00a0 732B     		cmp	r3, #115
 7939 00a2 00F02B81 		beq	.L514
 7940 00a6 742B     		cmp	r3, #116
 7941 00a8 40F0A981 		bne	.L490
 7942 00ac 60E1     		b	.L535
 7943              	.L527:
 7944 00ae 792B     		cmp	r3, #121
 7945 00b0 00F07781 		beq	.L518
 7946 00b4 7A2B     		cmp	r3, #122
 7947 00b6 00F07681 		beq	.L519
 7948 00ba 762B     		cmp	r3, #118
 7949 00bc 40F09F81 		bne	.L490
 7950 00c0 68E1     		b	.L517
 7951              	.L505:
 7952              	.LVL607:
 7953              	.LBB383:
 7954              	.LBB384:
 455:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 7955              		.loc 25 455 0 discriminator 1
 7956 00c2 7D4C     		ldr	r4, .L555+4
 7957 00c4 2068     		ldr	r0, [r4, #0]	@ float
 7958 00c6 FFF7FEFF 		bl	_Z15PrintValueCommaf
 7959              	.LVL608:
 7960 00ca 6068     		ldr	r0, [r4, #4]	@ float
 7961 00cc FFF7FEFF 		bl	_Z15PrintValueCommaf
 7962              	.LVL609:
 7963 00d0 A068     		ldr	r0, [r4, #8]	@ float
 7964              	.LBE384:
 7965              	.LBB385:
 458:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 7966              		.loc 25 458 0 discriminator 1
 7967 00d2 7A4C     		ldr	r4, .L555+8
 7968              	.LBE385:
 7969              	.LBB386:
 455:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(gyroRate[axis]);
 7970              		.loc 25 455 0 discriminator 1
 7971 00d4 FFF7FEFF 		bl	_Z15PrintValueCommaf
 7972              	.LVL610:
 7973              	.LBE386:
 7974              	.LBB387:
 458:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(filteredAccel[axis]);
 7975              		.loc 25 458 0 discriminator 1
 7976 00d8 2068     		ldr	r0, [r4, #0]	@ float
 7977 00da FFF7FEFF 		bl	_Z15PrintValueCommaf
 7978              	.LVL611:
 7979 00de 6068     		ldr	r0, [r4, #4]	@ float
 7980 00e0 FFF7FEFF 		bl	_Z15PrintValueCommaf
 7981              	.LVL612:
 7982 00e4 A068     		ldr	r0, [r4, #8]	@ float
 7983 00e6 FFF7FEFF 		bl	_Z15PrintValueCommaf
 7984              	.LVL613:
 7985              	.LBE387:
 7986              	.LBB388:
 464:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintValueComma(0);
 7987              		.loc 25 464 0 discriminator 1
 7988 00ea 0020     		movs	r0, #0
 7989 00ec FFF7FEFF 		bl	_Z15PrintValueCommai
 7990              	.LVL614:
 7991 00f0 0020     		movs	r0, #0
 7992 00f2 FFF7FEFF 		bl	_Z15PrintValueCommai
 7993              	.LVL615:
 7994 00f6 0020     		movs	r0, #0
 7995 00f8 FFF7FEFF 		bl	_Z15PrintValueCommai
 7996              	.LVL616:
 7997 00fc 32E1     		b	.L547
 7998              	.LVL617:
 7999              	.L497:
 8000              	.LBE388:
 375:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_XAXIS_PID_IDX);
 8001              		.loc 25 375 0
 8002 00fe 0020     		movs	r0, #0
 8003 0100 FFF7FEFF 		bl	_Z8PrintPIDh
 8004              	.LVL618:
 376:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(RATE_YAXIS_PID_IDX);
 8005              		.loc 25 376 0
 8006 0104 0120     		movs	r0, #1
 8007 0106 FFF7FEFF 		bl	_Z8PrintPIDh
 8008              	.LVL619:
 377:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(rotationSpeedFactor);
 8009              		.loc 25 377 0
 8010 010a 6D4B     		ldr	r3, .L555+12
 8011 010c 1868     		ldr	r0, [r3, #0]	@ float
 8012 010e FFF7FEFF 		bl	_Z15PrintValueCommaf
 8013              	.LVL620:
 8014 0112 42E1     		b	.L550
 8015              	.L498:
 383:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_XAXIS_PID_IDX);
 8016              		.loc 25 383 0
 8017 0114 0320     		movs	r0, #3
 8018 0116 FFF7FEFF 		bl	_Z8PrintPIDh
 8019              	.LVL621:
 384:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_YAXIS_PID_IDX);
 8020              		.loc 25 384 0
 8021 011a 0420     		movs	r0, #4
 8022 011c FFF7FEFF 		bl	_Z8PrintPIDh
 8023              	.LVL622:
 385:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_XAXIS_PID_IDX);
 8024              		.loc 25 385 0
 8025 0120 0620     		movs	r0, #6
 8026 0122 FFF7FEFF 		bl	_Z8PrintPIDh
 8027              	.LVL623:
 386:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ATTITUDE_GYRO_YAXIS_PID_IDX);
 8028              		.loc 25 386 0
 8029 0126 0720     		movs	r0, #7
 8030 0128 FFF7FEFF 		bl	_Z8PrintPIDh
 8031              	.LVL624:
 8032 012c 2CE1     		b	.L554
 8033              	.L499:
 392:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(ZAXIS_PID_IDX);
 8034              		.loc 25 392 0
 8035 012e 0220     		movs	r0, #2
 8036 0130 FFF7FEFF 		bl	_Z8PrintPIDh
 8037              	.LVL625:
 393:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintPID(HEADING_HOLD_PID_IDX);
 8038              		.loc 25 393 0
 8039 0134 0520     		movs	r0, #5
 8040 0136 FFF7FEFF 		bl	_Z8PrintPIDh
 8041              	.LVL626:
 394:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN((int)headingHoldConfig);
 8042              		.loc 25 394 0
 8043 013a 624B     		ldr	r3, .L555+16
 8044 013c 6248     		ldr	r0, .L555+20
 8045 013e 1978     		ldrb	r1, [r3, #0]	@ zero_extendqisi2
 8046 0140 24E1     		b	.L551
 8047              	.L500:
 413:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(10);
 8048              		.loc 25 413 0
 8049 0142 0A20     		movs	r0, #10
 8050 0144 27E1     		b	.L552
 8051              	.L501:
 420:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(aref);
 8052              		.loc 25 420 0
 8053 0146 614B     		ldr	r3, .L555+24
 8054 0148 1868     		ldr	r0, [r3, #0]	@ float
 8055 014a FFF7FEFF 		bl	_Z15PrintValueCommaf
 8056              	.LVL627:
 421:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(minArmedThrottle);
 8057              		.loc 25 421 0
 8058 014e 604B     		ldr	r3, .L555+28
 8059 0150 5D48     		ldr	r0, .L555+20
 8060 0152 1968     		ldr	r1, [r3, #0]
 8061 0154 1AE1     		b	.L551
 8062              	.L502:
 426:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 8063              		.loc 25 426 0
 8064 0156 5F4B     		ldr	r3, .L555+32
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 8065              		.loc 25 369 0
 8066 0158 5F4C     		ldr	r4, .L555+36
 426:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(receiverXmitFactor);
 8067              		.loc 25 426 0
 8068 015a 1868     		ldr	r0, [r3, #0]	@ float
 8069 015c FFF7FEFF 		bl	_Z15PrintValueCommaf
 8070              	.LVL628:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 8071              		.loc 25 369 0
 8072 0160 04F11805 		add	r5, r4, #24
 8073              	.LVL629:
 8074              	.L528:
 8075              	.LBB389:
 428:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverSmoothFactor[axis]);
 8076              		.loc 25 428 0 discriminator 2
 8077 0164 54F8040F 		ldr	r0, [r4, #4]!	@ float
 8078 0168 FFF7FEFF 		bl	_Z15PrintValueCommaf
 8079              	.LVL630:
 427:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 8080              		.loc 25 427 0 discriminator 2
 8081 016c AC42     		cmp	r4, r5
 8082 016e F9D1     		bne	.L528
 8083              	.LBE389:
 430:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintDummyValues(10 - LASTCHANNEL);
 8084              		.loc 25 430 0
 8085 0170 0420     		movs	r0, #4
 8086 0172 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 8087              	.LVL631:
 8088 0176 3CE1     		b	.L546
 8089              	.L503:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 8090              		.loc 25 369 0
 8091 0178 584C     		ldr	r4, .L555+40
 8092              	.LBB390:
 437:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 8093              		.loc 25 437 0
 8094 017a 0625     		movs	r5, #6
 8095              	.LBE390:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 8096              		.loc 25 369 0
 8097 017c 04F11806 		add	r6, r4, #24
 8098              	.L529:
 8099              	.LBB391:
 437:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverSlope[axis], 6);
 8100              		.loc 25 437 0 discriminator 2
 8101 0180 54F8040F 		ldr	r0, [r4, #4]!	@ float
 8102 0184 FFF7FEFF 		bl	__aeabi_f2d
 8103              	.LVL632:
 8104 0188 0095     		str	r5, [sp, #0]
 8105 018a 0246     		mov	r2, r0
 8106 018c 0B46     		mov	r3, r1
 8107 018e 4E48     		ldr	r0, .L555+20
 8108 0190 FFF7FEFF 		bl	_ZN5Print5printEdi
 8109              	.LVL633:
 438:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 8110              		.loc 25 438 0 discriminator 2
 8111 0194 2C21     		movs	r1, #44
 8112 0196 4C48     		ldr	r0, .L555+20
 8113 0198 FFF7FEFF 		bl	_ZN5Print5printEc
 8114              	.LVL634:
 436:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 8115              		.loc 25 436 0 discriminator 2
 8116 019c B442     		cmp	r4, r6
 8117 019e EFD1     		bne	.L529
 8118 01a0 27E1     		b	.L546
 8119              	.L504:
 8120              	.LBE391:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 8121              		.loc 25 369 0
 8122 01a2 4F4C     		ldr	r4, .L555+44
 8123              	.LBB392:
 446:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 8124              		.loc 25 446 0
 8125 01a4 0625     		movs	r5, #6
 8126              	.LBE392:
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** void sendSerialTelemetry() {
 8127              		.loc 25 369 0
 8128 01a6 04F11806 		add	r6, r4, #24
 8129              	.L530:
 8130              	.LBB393:
 446:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(receiverOffset[axis], 6);
 8131              		.loc 25 446 0 discriminator 2
 8132 01aa 54F8040F 		ldr	r0, [r4, #4]!	@ float
 8133 01ae FFF7FEFF 		bl	__aeabi_f2d
 8134              	.LVL635:
 8135 01b2 0095     		str	r5, [sp, #0]
 8136 01b4 0246     		mov	r2, r0
 8137 01b6 0B46     		mov	r3, r1
 8138 01b8 4348     		ldr	r0, .L555+20
 8139 01ba FFF7FEFF 		bl	_ZN5Print5printEdi
 8140              	.LVL636:
 447:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       Serial.print(',');
 8141              		.loc 25 447 0 discriminator 2
 8142 01be 2C21     		movs	r1, #44
 8143 01c0 4148     		ldr	r0, .L555+20
 8144 01c2 FFF7FEFF 		bl	_ZN5Print5printEc
 8145              	.LVL637:
 445:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = XAXIS; axis < LASTCHANNEL; axis++) {
 8146              		.loc 25 445 0 discriminator 2
 8147 01c6 B442     		cmp	r4, r6
 8148 01c8 EFD1     		bne	.L530
 8149 01ca 12E1     		b	.L546
 8150              	.L506:
 8151              	.LBE393:
 479:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 8152              		.loc 25 479 0
 8153 01cc 454F     		ldr	r7, .L555+48
 481:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 8154              		.loc 25 481 0
 8155 01ce 464E     		ldr	r6, .L555+52
 479:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[XAXIS], 6);
 8156              		.loc 25 479 0
 8157 01d0 3868     		ldr	r0, [r7, #0]	@ float
 8158 01d2 FFF7FEFF 		bl	__aeabi_f2d
 8159              	.LVL638:
 8160 01d6 0625     		movs	r5, #6
 8161 01d8 0246     		mov	r2, r0
 8162 01da 0B46     		mov	r3, r1
 8163 01dc 3A48     		ldr	r0, .L555+20
 8164 01de 0095     		str	r5, [sp, #0]
 8165 01e0 FFF7FEFF 		bl	_ZN5Print5printEdi
 8166              	.LVL639:
 480:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 8167              		.loc 25 480 0
 8168 01e4 FFF7FEFF 		bl	_Z5commav
 8169              	.LVL640:
 481:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[XAXIS], 6);
 8170              		.loc 25 481 0
 8171 01e8 3068     		ldr	r0, [r6, #0]	@ float
 8172 01ea FFF7FEFF 		bl	__aeabi_f2d
 8173              	.LVL641:
 8174 01ee 0095     		str	r5, [sp, #0]
 8175 01f0 0246     		mov	r2, r0
 8176 01f2 0B46     		mov	r3, r1
 8177 01f4 3448     		ldr	r0, .L555+20
 8178 01f6 FFF7FEFF 		bl	_ZN5Print5printEdi
 8179              	.LVL642:
 482:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 8180              		.loc 25 482 0
 8181 01fa FFF7FEFF 		bl	_Z5commav
 8182              	.LVL643:
 483:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[YAXIS], 6);
 8183              		.loc 25 483 0
 8184 01fe 7868     		ldr	r0, [r7, #4]	@ float
 8185 0200 FFF7FEFF 		bl	__aeabi_f2d
 8186              	.LVL644:
 8187 0204 0095     		str	r5, [sp, #0]
 8188 0206 0246     		mov	r2, r0
 8189 0208 0B46     		mov	r3, r1
 8190 020a 2F48     		ldr	r0, .L555+20
 8191 020c FFF7FEFF 		bl	_ZN5Print5printEdi
 8192              	.LVL645:
 484:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 8193              		.loc 25 484 0
 8194 0210 FFF7FEFF 		bl	_Z5commav
 8195              	.LVL646:
 485:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(runTimeAccelBias[YAXIS], 6);
 8196              		.loc 25 485 0
 8197 0214 7068     		ldr	r0, [r6, #4]	@ float
 8198 0216 FFF7FEFF 		bl	__aeabi_f2d
 8199              	.LVL647:
 8200 021a 0095     		str	r5, [sp, #0]
 8201 021c 0246     		mov	r2, r0
 8202 021e 0B46     		mov	r3, r1
 8203 0220 2948     		ldr	r0, .L555+20
 8204 0222 FFF7FEFF 		bl	_ZN5Print5printEdi
 8205              	.LVL648:
 486:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 8206              		.loc 25 486 0
 8207 0226 FFF7FEFF 		bl	_Z5commav
 8208              	.LVL649:
 487:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINT(accelScaleFactor[ZAXIS], 6);
 8209              		.loc 25 487 0
 8210 022a B868     		ldr	r0, [r7, #8]	@ float
 8211 022c FFF7FEFF 		bl	__aeabi_f2d
 8212              	.LVL650:
 8213 0230 0095     		str	r5, [sp, #0]
 8214 0232 0246     		mov	r2, r0
 8215 0234 0B46     		mov	r3, r1
 8216 0236 2448     		ldr	r0, .L555+20
 8217 0238 FFF7FEFF 		bl	_ZN5Print5printEdi
 8218              	.LVL651:
 488:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     comma();
 8219              		.loc 25 488 0
 8220 023c FFF7FEFF 		bl	_Z5commav
 8221              	.LVL652:
 489:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(runTimeAccelBias[ZAXIS], 6);
 8222              		.loc 25 489 0
 8223 0240 B068     		ldr	r0, [r6, #8]	@ float
 8224 0242 FFF7FEFF 		bl	__aeabi_f2d
 8225              	.LVL653:
 8226 0246 0095     		str	r5, [sp, #0]
 8227 0248 0246     		mov	r2, r0
 8228 024a 0B46     		mov	r3, r1
 8229 024c 1E48     		ldr	r0, .L555+20
 8230 024e C0E0     		b	.L553
 8231              	.L507:
 497:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]));
 8232              		.loc 25 497 0
 8233 0250 264C     		ldr	r4, .L555+56
 494:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     evaluateMetersPerSec();    // reset sample data
 8234              		.loc 25 494 0
 8235 0252 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 8236              	.LVL654:
 495:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     delay(2);
 8237              		.loc 25 495 0
 8238 0256 0220     		movs	r0, #2
 8239 0258 FFF7FEFF 		bl	_Z5delaym
 8240              	.LVL655:
 496:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     measureCriticalSensors();  // call mesureAccelSum that give one raw sample in accelSample
 8241              		.loc 25 496 0
 8242 025c FFF7FEFF 		bl	_Z22measureCriticalSensorsv
 8243              	.LVL656:
 497:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[XAXIS]));
 8244              		.loc 25 497 0
 8245 0260 2068     		ldr	r0, [r4, #0]
 8246 0262 FFF7FEFF 		bl	_Z15PrintValueCommai
 8247              	.LVL657:
 498:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma((int)(accelSample[YAXIS]));
 8248              		.loc 25 498 0
 8249 0266 6068     		ldr	r0, [r4, #4]
 8250 0268 FFF7FEFF 		bl	_Z15PrintValueCommai
 8251              	.LVL658:
 499:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN ((int)(accelSample[ZAXIS]));
 8252              		.loc 25 499 0
 8253 026c 1648     		ldr	r0, .L555+20
 8254 026e A168     		ldr	r1, [r4, #8]
 8255 0270 A3E0     		b	.L548
 8256              	.L509:
 519:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(3);
 8257              		.loc 25 519 0
 8258 0272 0320     		movs	r0, #3
 8259 0274 8FE0     		b	.L552
 8260              	.L544:
 534:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(4);
 8261              		.loc 25 534 0
 8262 0276 0420     		movs	r0, #4
 8263 0278 8DE0     		b	.L552
 8264              	.L511:
 562:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****         PrintDummyValues(13);
 8265              		.loc 25 562 0
 8266 027a 0D20     		movs	r0, #13
 8267 027c 8BE0     		b	.L552
 8268              	.L512:
 570:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(vehicleState);
 8269              		.loc 25 570 0
 8270 027e 1C4B     		ldr	r3, .L555+60
 8271 0280 1148     		ldr	r0, .L555+20
 8272 0282 1968     		ldr	r1, [r3, #0]
 8273 0284 0A22     		movs	r2, #10
 8274 0286 FFF7FEFF 		bl	_ZN5Print7printlnEmi
 8275              	.LVL659:
 8276 028a A7E0     		b	.L545
 8277              	.L513:
 575:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 8278              		.loc 25 575 0
 8279 028c 194C     		ldr	r4, .L555+64
 8280 028e 2068     		ldr	r0, [r4, #0]	@ float
 8281 0290 FFF7FEFF 		bl	_Z15PrintValueCommaf
 8282              	.LVL660:
 576:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 8283              		.loc 25 576 0
 8284 0294 6068     		ldr	r0, [r4, #4]	@ float
 8285 0296 FFF7FEFF 		bl	_Z15PrintValueCommaf
 8286              	.LVL661:
 577:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(getHeading());
 8287              		.loc 25 577 0
 8288 029a 174B     		ldr	r3, .L555+68
 8289 029c 1868     		ldr	r0, [r3, #0]	@ float
 8290 029e FFF7FEFF 		bl	__aeabi_f2d
 8291              	.LVL662:
 8292 02a2 0B46     		mov	r3, r1
 8293 02a4 0221     		movs	r1, #2
 8294 02a6 0246     		mov	r2, r0
 8295 02a8 0091     		str	r1, [sp, #0]
 8296 02aa 0748     		ldr	r0, .L555+20
 8297 02ac FFF7FEFF 		bl	_ZN5Print7printlnEdi
 8298              	.LVL663:
 578:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 8299              		.loc 25 578 0
 8300 02b0 A5E0     		b	.L490
 8301              	.L556:
 8302 02b2 00BF     		.align	2
 8303              	.L555:
 8304 02b4 00000000 		.word	.LANCHOR79
 8305 02b8 00000000 		.word	.LANCHOR21
 8306 02bc 00000000 		.word	.LANCHOR82
 8307 02c0 00000000 		.word	.LANCHOR60
 8308 02c4 00000000 		.word	.LANCHOR68
 8309 02c8 00000000 		.word	SerialUSB
 8310 02cc 00000000 		.word	.LANCHOR77
 8311 02d0 00000000 		.word	.LANCHOR65
 8312 02d4 00000000 		.word	.LANCHOR12
 8313 02d8 FCFFFFFF 		.word	.LANCHOR9-4
 8314 02dc FCFFFFFF 		.word	.LANCHOR7-4
 8315 02e0 FCFFFFFF 		.word	.LANCHOR8-4
 8316 02e4 00000000 		.word	.LANCHOR29
 8317 02e8 00000000 		.word	.LANCHOR30
 8318 02ec 00000000 		.word	.LANCHOR31
 8319 02f0 00000000 		.word	.LANCHOR18
 8320 02f4 00000000 		.word	.LANCHOR36
 8321 02f8 00000000 		.word	.LANCHOR22
 8322              	.L514:
 581:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 8323              		.loc 25 581 0
 8324 02fc 444B     		ldr	r3, .L557+8
 582:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 8325              		.loc 25 582 0
 8326 02fe 454C     		ldr	r4, .L557+12
 581:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 8327              		.loc 25 581 0
 8328 0300 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 8329              	.LBB394:
 598:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 8330              		.loc 25 598 0
 8331 0302 454D     		ldr	r5, .L557+16
 8332              	.LBE394:
 581:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(motorArmed);
 8333              		.loc 25 581 0
 8334 0304 FFF7FEFF 		bl	_Z15PrintValueCommah
 8335              	.LVL664:
 582:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[XAXIS]);
 8336              		.loc 25 582 0
 8337 0308 2068     		ldr	r0, [r4, #0]	@ float
 8338 030a FFF7FEFF 		bl	_Z15PrintValueCommaf
 8339              	.LVL665:
 583:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(kinematicsAngle[YAXIS]);
 8340              		.loc 25 583 0
 8341 030e 6068     		ldr	r0, [r4, #4]	@ float
 8342 0310 FFF7FEFF 		bl	_Z15PrintValueCommaf
 8343              	.LVL666:
 584:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(getHeading());
 8344              		.loc 25 584 0
 8345 0314 414B     		ldr	r3, .L557+20
 8346 0316 1868     		ldr	r0, [r3, #0]	@ float
 8347 0318 FFF7FEFF 		bl	_Z15PrintValueCommaf
 8348              	.LVL667:
 593:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 8349              		.loc 25 593 0
 8350 031c 0020     		movs	r0, #0
 8351 031e FFF7FEFF 		bl	_Z15PrintValueCommai
 8352              	.LVL668:
 594:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 8353              		.loc 25 594 0
 8354 0322 0020     		movs	r0, #0
 8355 0324 FFF7FEFF 		bl	_Z15PrintValueCommai
 8356              	.LVL669:
 8357 0328 0024     		movs	r4, #0
 8358              	.LVL670:
 8359              	.L532:
 8360              	.LBB395:
 598:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma((channel < LASTCHANNEL) ? receiverCommand[channel] : 0);
 8361              		.loc 25 598 0
 8362 032a E3B2     		uxtb	r3, r4
 8363 032c 052B     		cmp	r3, #5
 8364 032e 94BF     		ite	ls
 8365 0330 55F82400 		ldrls	r0, [r5, r4, lsl #2]
 8366 0334 0020     		movhi	r0, #0
 8367 0336 0134     		adds	r4, r4, #1
 8368 0338 FFF7FEFF 		bl	_Z15PrintValueCommai
 8369              	.LVL671:
 597:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 8370              		.loc 25 597 0
 8371 033c 082C     		cmp	r4, #8
 8372 033e F4D1     		bne	.L532
 8373              	.LBE395:
 8374              	.LBB396:
 602:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 8375              		.loc 25 602 0
 8376 0340 374D     		ldr	r5, .L557+24
 8377              	.LBE396:
 8378              	.LBB397:
 597:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte channel = 0; channel < 8; channel++) { // Configurator expects 8 values
 8379              		.loc 25 597 0
 8380 0342 0024     		movs	r4, #0
 8381              	.L533:
 8382              	.LBE397:
 8383              	.LBB398:
 602:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 8384              		.loc 25 602 0 discriminator 2
 8385 0344 6059     		ldr	r0, [r4, r5]
 8386 0346 0434     		adds	r4, r4, #4
 8387 0348 FFF7FEFF 		bl	_Z15PrintValueCommai
 8388              	.LVL672:
 601:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8389              		.loc 25 601 0 discriminator 2
 8390 034c 102C     		cmp	r4, #16
 8391 034e F9D1     		bne	.L533
 8392              	.LBE398:
 604:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintDummyValues(8 - LASTMOTOR); // max of 8 motor outputs supported
 8393              		.loc 25 604 0
 8394 0350 0420     		movs	r0, #4
 8395 0352 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 8396              	.LVL673:
 609:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 8397              		.loc 25 609 0
 8398 0356 0020     		movs	r0, #0
 8399 0358 FFF7FEFF 		bl	_Z15PrintValueCommai
 8400              	.LVL674:
 611:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     PrintValueComma(flightMode);
 8401              		.loc 25 611 0
 8402 035c 314B     		ldr	r3, .L557+28
 8403 035e 1878     		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 8404 0360 FFF7FEFF 		bl	_Z15PrintValueCommah
 8405              	.LVL675:
 8406              	.L547:
 612:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 8407              		.loc 25 612 0
 8408 0364 3048     		ldr	r0, .L557+32
 8409              	.LBE383:
 8410              	.LBE382:
 731:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 8411              		.loc 25 731 0
 8412 0366 03B0     		add	sp, sp, #12
 8413 0368 BDE8F040 		pop	{r4, r5, r6, r7, lr}
 8414              	.LBB407:
 8415              	.LBB403:
 612:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 8416              		.loc 25 612 0
 8417 036c FFF7FEBF 		b	_ZN5Print7printlnEv
 8418              	.LVL676:
 8419              	.L535:
 8420              	.LBB399:
 617:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 8421              		.loc 25 617 0
 8422 0370 294D     		ldr	r5, .L557+16
 8423              	.LBE399:
 8424              	.LBE403:
 370:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 8425              		.loc 25 370 0
 8426 0372 0024     		movs	r4, #0
 8427              	.L515:
 8428              	.LBB404:
 8429              	.LBB400:
 617:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(receiverCommand[axis]);
 8430              		.loc 25 617 0 discriminator 2
 8431 0374 6059     		ldr	r0, [r4, r5]
 8432 0376 0434     		adds	r4, r4, #4
 8433 0378 FFF7FEFF 		bl	_Z15PrintValueCommai
 8434              	.LVL677:
 616:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte axis = 0; axis < LASTCHANNEL; axis++) {
 8435              		.loc 25 616 0 discriminator 2
 8436 037c 182C     		cmp	r4, #24
 8437 037e F9D1     		bne	.L515
 8438 0380 F0E7     		b	.L547
 8439              	.L516:
 8440              	.LBE400:
 627:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 8441              		.loc 25 627 0
 8442 0382 0020     		movs	r0, #0
 8443 0384 FFF7FEFF 		bl	_Z15PrintValueCommai
 8444              	.LVL678:
 8445              	.L554:
 628:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 8446              		.loc 25 628 0
 8447 0388 2748     		ldr	r0, .L557+32
 8448 038a 0021     		movs	r1, #0
 8449              	.L551:
 8450 038c 0A22     		movs	r2, #10
 8451 038e FFF7FEFF 		bl	_ZN5Print7printlnEii
 8452              	.LVL679:
 8453 0392 23E0     		b	.L545
 8454              	.L517:
 640:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(9);
 8455              		.loc 25 640 0
 8456 0394 0920     		movs	r0, #9
 8457              	.L552:
 8458 0396 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 8459              	.LVL680:
 8460              	.L550:
 642:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 8461              		.loc 25 642 0
 8462 039a 2348     		ldr	r0, .L557+32
 8463 039c FFF7FEFF 		bl	_ZN5Print7printlnEv
 8464              	.LVL681:
 8465 03a0 1CE0     		b	.L545
 8466              	.L518:
 659:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(11);
 8467              		.loc 25 659 0
 8468 03a2 0B20     		movs	r0, #11
 8469 03a4 04E0     		b	.L549
 8470              	.L519:
 668:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(0);
 8471              		.loc 25 668 0
 8472 03a6 0020     		movs	r0, #0
 8473 03a8 FFF7FEFF 		bl	_Z15PrintValueCommai
 8474              	.LVL682:
 8475 03ac 03E0     		b	.L495
 8476              	.L494:
 687:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintDummyValues(3);
 8477              		.loc 25 687 0
 8478 03ae 0320     		movs	r0, #3
 8479              	.L549:
 8480 03b0 FFF7FEFF 		bl	_Z16PrintDummyValuesh
 8481              	.LVL683:
 8482 03b4 D6E7     		b	.L547
 8483              	.L495:
 696:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 8484              		.loc 25 696 0
 8485 03b6 1C48     		ldr	r0, .L557+32
 8486 03b8 0021     		movs	r1, #0
 8487              	.L548:
 8488 03ba 0A22     		movs	r2, #10
 8489              	.LBE404:
 8490              	.LBE407:
 731:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 8491              		.loc 25 731 0
 8492 03bc 03B0     		add	sp, sp, #12
 8493 03be BDE8F040 		pop	{r4, r5, r6, r7, lr}
 8494              	.LBB408:
 8495              	.LBB405:
 696:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       SERIAL_PRINTLN(0);
 8496              		.loc 25 696 0
 8497 03c2 FFF7FEBF 		b	_ZN5Print7printlnEii
 8498              	.LVL684:
 8499              	.L492:
 704:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN(SOFTWARE_VERSION, 1);
 8500              		.loc 25 704 0
 8501 03c6 0123     		movs	r3, #1
 8502 03c8 0093     		str	r3, [sp, #0]
 8503 03ca 0FA3     		adr	r3, .L557
 8504 03cc D3E90023 		ldrd	r2, [r3]
 8505 03d0 1548     		ldr	r0, .L557+32
 8506              	.L553:
 8507 03d2 FFF7FEFF 		bl	_ZN5Print7printlnEdi
 8508              	.LVL685:
 8509 03d6 01E0     		b	.L545
 8510              	.L493:
 709:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     reportVehicleState();
 8511              		.loc 25 709 0
 8512 03d8 FFF7FEFF 		bl	_Z18reportVehicleStatev
 8513              	.LVL686:
 8514              	.L545:
 710:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 8515              		.loc 25 710 0
 8516 03dc 5823     		movs	r3, #88
 8517 03de 2370     		strb	r3, [r4, #0]
 711:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     break;
 8518              		.loc 25 711 0
 8519 03e0 0DE0     		b	.L490
 8520              	.L534:
 8521              	.LBB401:
 715:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 8522              		.loc 25 715 0
 8523 03e2 0F4D     		ldr	r5, .L557+24
 8524              	.LBE401:
 8525              	.LBE405:
 370:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****   switch (queryType) {
 8526              		.loc 25 370 0
 8527 03e4 0024     		movs	r4, #0
 8528              	.L496:
 8529              	.LBB406:
 8530              	.LBB402:
 715:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****       PrintValueComma(motorCommand[motor]);
 8531              		.loc 25 715 0 discriminator 2
 8532 03e6 6059     		ldr	r0, [r4, r5]
 8533 03e8 0434     		adds	r4, r4, #4
 8534 03ea FFF7FEFF 		bl	_Z15PrintValueCommai
 8535              	.LVL687:
 714:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     for (byte motor = 0; motor < LASTMOTOR; motor++) {
 8536              		.loc 25 714 0 discriminator 2
 8537 03ee 102C     		cmp	r4, #16
 8538 03f0 F9D1     		bne	.L496
 8539              	.L546:
 8540              	.LBE402:
 717:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     SERIAL_PRINTLN();
 8541              		.loc 25 717 0
 8542 03f2 0D48     		ldr	r0, .L557+32
 8543 03f4 FFF7FEFF 		bl	_ZN5Print7printlnEv
 8544              	.LVL688:
 718:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h ****     queryType = 'X';
 8545              		.loc 25 718 0
 8546 03f8 0C4B     		ldr	r3, .L557+36
 8547 03fa 5822     		movs	r2, #88
 8548 03fc 1A70     		strb	r2, [r3, #0]
 8549              	.L490:
 8550              	.LBE406:
 8551              	.LBE408:
 731:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\SerialCom.h **** }
 8552              		.loc 25 731 0
 8553 03fe 03B0     		add	sp, sp, #12
 8554 0400 F0BD     		pop	{r4, r5, r6, r7, pc}
 8555              	.L558:
 8556 0402 00BFAFF3 		.align	3
 8556      0080
 8557              	.L557:
 8558 0408 000000A0 		.word	-1610612736
 8559 040c 99990940 		.word	1074370969
 8560 0410 00000000 		.word	.LANCHOR76
 8561 0414 00000000 		.word	.LANCHOR36
 8562 0418 00000000 		.word	.LANCHOR4
 8563 041c 00000000 		.word	.LANCHOR22
 8564 0420 00000000 		.word	.LANCHOR54
 8565 0424 00000000 		.word	.LANCHOR59
 8566 0428 00000000 		.word	SerialUSB
 8567 042c 00000000 		.word	.LANCHOR79
 8568              		.cfi_endproc
 8569              	.LFE216:
 8571              		.section	.text._Z5setupv,"ax",%progbits
 8572              		.align	1
 8573              		.global	_Z5setupv
 8574              		.thumb
 8575              		.thumb_func
 8577              	_Z5setupv:
 8578              	.LFB223:
 8579              		.file 26 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/AeroQuad.ino"
   1:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*
   2:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   AeroQuad v3.0.1 - February 2012
   3:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   www.AeroQuad.com
   4:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   Copyright (c) 2012 Ted Carancho.  All rights reserved.
   5:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   An Open Source Arduino based multicopter.
   6:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
   7:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   This program is free software: you can redistribute it and/or modify
   8:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   it under the terms of the GNU General Public License as published by
   9:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   the Free Software Foundation, either version 3 of the License, or
  10:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   (at your option) any later version.
  11:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  12:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   This program is distributed in the hope that it will be useful,
  13:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  15:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   GNU General Public License for more details.
  16:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  17:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   You should have received a copy of the GNU General Public License
  18:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   along with this program. If not, see <http://www.gnu.org/licenses/>.
  19:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** */
  20:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  21:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /****************************************************************************
  22:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    Before flight, select the different user options for your AeroQuad by
  23:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    editing UserConfiguration.h.
  24:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  25:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    If you need additional assistance go to http://www.aeroquad.com/forum.php
  26:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    or talk to us live on IRC #aeroquad
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** *****************************************************************************/
  28:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  29:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "UserConfiguration.h" // Edit this file first before uploading to the AeroQuad
  30:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  31:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  32:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Define Security Checks
  33:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //
  34:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  35:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPSNMEA) || defined(UseGPSUBLOX) || defined(UseGPSMTK) || defined(UseGPS406)
  36:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #define UseGPS
  37:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
  38:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  39:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPSNavigator) && !defined(AltitudeHoldBaro)
  40:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "GpsNavigation NEED AltitudeHoldBaro defined"
  41:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  42:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  43:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(AutoLanding) && (!defined(AltitudeHoldBaro) || !defined(AltitudeHoldRangeFinder))
  44:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "AutoLanding NEED AltitudeHoldBaro and AltitudeHoldRangeFinder defined"
  45:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  46:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  47:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(ReceiverSBUS) && defined(SlowTelemetry)
  48:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "Receiver SWBUS and SlowTelemetry are in conflict for Seria2, they can't be used together"
  49:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  50:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  51:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (CameraTXControl) && !defined (CameraControl)
  52:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #error "CameraTXControl need to have CameraControl defined"
  53:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
  54:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  55:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <EEPROM.h>
  56:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <Wire.h>
  57:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <GlobalDefined.h>
  58:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "AeroQuad.h"
  59:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "PID.h"
  60:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <AQMath.h>
  61:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include <FourtOrderFilter.h>
  62:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef BattMonitor
  63:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BatteryMonitorTypes.h>
  64:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
  65:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  66:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  67:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  68:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********* PLATFORM SPECIFIC SECTION ********************
  69:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  70:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
  71:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_v18
  72:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
  73:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
  74:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
  75:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  76:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
  77:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  78:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
  79:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
  80:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  81:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
  82:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
  83:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  84:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
  85:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
  86:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  87:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
  88:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
  89:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  90:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
  91:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
  92:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
  93:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
  94:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
  95:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
  96:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
  97:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15, 0.9, BM_NOPIN, 0, 0)
  98:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
  99:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder
 105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_v18 specific initialization need here
 112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 117:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 121:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 122:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 123:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // called when eeprom is initialized
 125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0047340002;
 128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0046519994;
 129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0046799998;
 130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuad_Mini
 143:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define ITG3200_ADDRESS_ALTERNATE
 151:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_ADXL345.h>
 155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 159:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 160:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config)
 161:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM_Timer
 162:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 163:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM
 164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif    
 165:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 166:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 167:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 168:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 169:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 170:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 171:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 172:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 173:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.53, BM_NOPIN, 0, 0)
 174:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 175:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 176:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 177:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 178:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 179:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in mini
 180:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 181:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 182:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 183:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 184:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 185:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 186:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 187:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 188:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_Mini specific initialization need here
 189:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 190:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 191:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 192:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 193:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 194:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 195:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 196:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 197:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 198:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 199:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 200:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 201:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // called when eeprom is initialized
 202:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 203:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 204:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0371299982;
 205:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0374319982;
 206:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0385979986;
 207:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 208:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 209:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 210:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 211:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 212:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 213:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 214:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 215:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 216:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 217:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 218:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef MWCFlip15
 219:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 220:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 12
 221:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 12
 222:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 223:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 224:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 225:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MPU6000_I2C
 226:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_MPU6000.h>
 227:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 228:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_MPU6000.h>
 229:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 230:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_MPU6000.h>
 231:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 232:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver declaration
 233:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_328P
 234:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 235:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 236:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config)
 237:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM_Timer
 238:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 239:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM
 240:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif    
 241:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 242:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // unsupported in mini
 243:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef HeadingMagHold
 244:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef BattMonitor
 245:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldBaro
 246:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef AltitudeHoldRangeFinder  
 247:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef CameraControl
 248:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef OSD
 249:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPS
 250:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #undef UseGPSNavigator
 251:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 252:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 253:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuad_Mini specific initialization need here
 254:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 255:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 256:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 257:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 258:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 259:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 260:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 261:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 262:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 263:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 264:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
 265:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeMPU6000Sensors();
 266:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 267:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 268:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // called when eeprom is initialized
 269:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 270:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 271:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0011980000;
 272:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0012020000;
 273:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0011750000;
 274:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 275:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 276:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 277:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 278:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 279:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 280:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     readMPU6000Sensors();
 281:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 282:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 283:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 284:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 285:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 286:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 287:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v2
 288:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 289:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 290:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 291:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 292:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 293:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 294:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 295:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_ITG3200.h>
 296:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 297:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 298:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_BMA180.h>
 299:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 300:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 301:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 302:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 303:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 304:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 305:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 306:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 307:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 308:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Compass.h>
 309:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #define SPARKFUN_5883L_BOB
 310:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5843
 311:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 312:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 313:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 314:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro    
 315:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BMP085 
 316:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 317:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 318:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 319:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 320:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 321:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 322:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 323:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 324:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 325:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 326:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 327:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 328:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 329:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 330:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 331:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 332:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 333:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 334:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 335:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 336:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 337:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 338:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 339:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 340:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 341:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 342:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v2 specific initialization need here
 343:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 344:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 345:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 346:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 347:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 348:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 349:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 350:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 351:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 352:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 353:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 354:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 355:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 356:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 357:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 358:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 359:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 360:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 361:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 362:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 363:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 364:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 365:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 366:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 367:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 368:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // called when eeprom is initialized
 369:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 370:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 371:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0046449995;
 372:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0047950000;
 373:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0047549996;
 374:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef HeadingMagHold
 375:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       magBias[XAXIS]  = 60.000000;
 376:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       magBias[YAXIS]  = -39.000000;
 377:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       magBias[ZAXIS]  = -7.500000;
 378:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 379:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 380:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 381:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 382:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 383:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 384:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 385:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 386:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 387:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 388:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 389:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 390:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadMega_v21
 391:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define LED_Green 13
 392:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define LED_Red 4
 393:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define LED_Yellow 31
 394:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 395:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Device_I2C.h>
 396:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Gyroscope declaration
 397:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define ITG3200_ADDRESS_ALTERNATE
 398:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Gyroscope_ITG3200_9DOF.h>
 399:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 400:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Accelerometer declaration
 401:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Accelerometer_ADXL345_9DOF.h>
 402:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 403:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Receiver Declaration
 404:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define RECEIVER_MEGA
 405:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 406:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Motor declaration
 407:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTOR_PWM_Timer
 408:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 409:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // heading mag hold declaration
 410:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef HeadingMagHold
 411:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #include <Compass.h>
 412:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define SPARKFUN_9DOF_5883L
 413:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 414:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 415:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Altitude declaration
 416:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef AltitudeHoldBaro
 417:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BMP085
 418:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 419:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef AltitudeHoldRangeFinder
 420:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define XLMAXSONAR 
 421:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 422:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 423:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 424:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Battery Monitor declaration
 425:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef BattMonitor
 426:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef POWERED_BY_VIN
 427:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****         #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powere
 428:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #else
 429:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****         #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield pow
 430:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
 431:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 432:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #undef BattMonitorAutoDescent
 433:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #undef POWERED_BY_VIN        
 434:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 435:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 436:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef OSD
 437:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define MAX7456_OSD
 438:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif  
 439:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
 440:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifndef UseGPS
 441:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #undef UseGPSNavigator
 442:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 443:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 444:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 445:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     /**
 446:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      * Put AeroQuadMega_v21 specific initialization need here
 447:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      */
 448:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     void initPlatform() {
 449:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 450:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(LED_Red, OUTPUT);
 451:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       digitalWrite(LED_Red, LOW);
 452:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(LED_Yellow, OUTPUT);
 453:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       digitalWrite(LED_Yellow, LOW);
 454:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 455:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // pins set to INPUT for camera stabilization so won't interfere with new camera class
 456:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 457:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 458:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 459:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(43, OUTPUT); // LED 1
 460:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(44, OUTPUT); // LED 2
 461:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(45, OUTPUT); // LED 3
 462:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       pinMode(46, OUTPUT); // LED 4
 463:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       digitalWrite(43, HIGH); // LED 1 on
 464:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       digitalWrite(44, HIGH); // LED 2 on
 465:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       digitalWrite(45, HIGH); // LED 3 on
 466:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       digitalWrite(46, HIGH); // LED 4 on
 467:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 468:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       Wire.begin();
 469:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       TWBR = 12;
 470:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 471:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
 472:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // called when eeprom is initialized
 473:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     void initializePlatformSpecificAccelCalibration() {
 474:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // Kenny default value, a real accel calibration is strongly recommended
 475:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       accelScaleFactor[XAXIS] = 0.0365570020;
 476:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       accelScaleFactor[YAXIS] = 0.0363000011;
 477:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       accelScaleFactor[ZAXIS] = -0.0384629964;
 478:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #ifdef HeadingMagHold
 479:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****         magBias[XAXIS]  = 1.500000;
 480:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****         magBias[YAXIS]  = 205.500000;
 481:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****         magBias[ZAXIS]  = -33.000000;
 482:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #endif
 483:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 484:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 485:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     /**
 486:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      * Measure critical sensors
 487:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      */
 488:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     void measureCriticalSensors() {
 489:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureGyroSum();
 490:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       measureAccelSum();
 491:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 492:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 493:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 494:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 495:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef MWCProEz30
 496:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Green 13
 497:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Red 4
 498:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define LED_Yellow 31
 499:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 500:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_I2C.h>
 501:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 502:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 503:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Compass.h>
 504:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define HMC5883L
 505:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //    #define SPARKFUN_5883L_BOB
 506:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 507:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 508:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 509:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MPU6000_I2C
 510:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Platform_MPU6000.h>
 511:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Gyroscope declaration
 512:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Gyroscope_MPU6000.h>
 513:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Accelerometer declaration
 514:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Accelerometer_MPU6000.h>
 515:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 516:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Receiver Declaration
 517:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define RECEIVER_MEGA
 518:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 519:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Motor declaration
 520:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define MOTOR_PWM_Timer
 521:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 522:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // heading mag hold declaration
 523:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 524:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Altitude declaration
 525:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 526:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MS5611
 527:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define USE_MS5611_ALTERNATE_ADDRESS
 528:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 529:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 530:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define XLMAXSONAR 
 531:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 532:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 533:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 534:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Battery Monitor declaration
 535:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 536:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef POWERED_BY_VIN
 537:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0, BM_NOPIN, 0, 0) // v2 shield powered 
 538:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 539:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       #define BattDefaultConfig DEFINE_BATTERY(0, 0, 15.0, 0.82, BM_NOPIN, 0, 0) // v2 shield power
 540:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 541:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 542:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BattMonitorAutoDescent
 543:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef POWERED_BY_VIN        
 544:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 545:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 546:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef OSD
 547:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MAX7456_OSD
 548:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif  
 549:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 550:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef UseGPS
 551:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef UseGPSNavigator
 552:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 553:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 554:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 555:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 556:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Put AeroQuadMega_v21 specific initialization need here
 557:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 558:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initPlatform() {
 559:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 560:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Red, OUTPUT);
 561:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Red, LOW);
 562:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(LED_Yellow, OUTPUT);
 563:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(LED_Yellow, LOW);
 564:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 565:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // pins set to INPUT for camera stabilization so won't interfere with new camera class
 566:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(33, INPUT); // disable SERVO 1, jumper D12 for roll
 567:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(34, INPUT); // disable SERVO 2, jumper D11 for pitch
 568:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(35, INPUT); // disable SERVO 3, jumper D13 for yaw
 569:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(43, OUTPUT); // LED 1
 570:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(44, OUTPUT); // LED 2
 571:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(45, OUTPUT); // LED 3
 572:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     pinMode(46, OUTPUT); // LED 4
 573:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(43, HIGH); // LED 1 on
 574:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(44, HIGH); // LED 2 on
 575:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(45, HIGH); // LED 3 on
 576:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     digitalWrite(46, HIGH); // LED 4 on
 577:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 578:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     Wire.begin();
 579:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     TWBR = 12;
 580:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
 581:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeMPU6000Sensors();
 582:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 583:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 584:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // called when eeprom is initialized
 585:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void initializePlatformSpecificAccelCalibration() {
 586:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // Kenny default value, a real accel calibration is strongly recommended
 587:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[XAXIS] = 0.0011980000;
 588:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[YAXIS] = -0.0012020000;
 589:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     accelScaleFactor[ZAXIS] = -0.0011750000;
 590:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef HeadingMagHold
 591:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       magBias[XAXIS]  = 1.500000;
 592:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       magBias[YAXIS]  = 205.500000;
 593:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       magBias[ZAXIS]  = -33.000000;
 594:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 595:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 596:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 597:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   /**
 598:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    * Measure critical sensors
 599:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    */
 600:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   void measureCriticalSensors() {
 601:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     readMPU6000Sensors();
 602:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureGyroSum();
 603:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureAccelSum();
 604:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 605:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 606:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 607:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 608:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 609:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 610:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********* HARDWARE GENERALIZATION SECTION **************
 611:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 612:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 613:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 614:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef AeroQuadSTM32
 615:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "AeroQuad_STM32.h"
 616:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(Naze32)
 617:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define AeroQuadSTM32
 618:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #define BOARD_naze32
 619:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "AeroQuad_STM32.h"
 620:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 621:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 622:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** // default to 10bit ADC (AVR)
 623:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifndef ADC_NUMBER_OF_BITS
 624:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #define ADC_NUMBER_OF_BITS 10
 625:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 626:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 627:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 628:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** KINEMATICS DECLARATION **************
 629:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 630:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "Kinematics.h"
 631:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "Kinematics_ARG.h"
 632:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 633:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 634:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 635:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******************** RECEIVER DECLARATION **************
 636:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 637:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(ReceiverHWPPM)
 638:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_HWPPM.h>
 639:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(ReceiverPPM)
 640:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_PPM.h>
 641:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(AeroQuad_Mini) && (defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Conf
 642:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_PPM.h>
 643:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RemotePCReceiver)
 644:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_RemotePC.h>
 645:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(ReceiverSBUS)
 646:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_SBUS.h>
 647:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_328P)
 648:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_328p.h>
 649:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_MEGA)
 650:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_MEGA.h>
 651:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_APM)
 652:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_APM.h>
 653:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_STM32PPM)
 654:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_STM32PPM.h>  
 655:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(RECEIVER_STM32)
 656:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Receiver_STM32.h>  
 657:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 658:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 659:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseAnalogRSSIReader) 
 660:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AnalogRSSIReader.h>
 661:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(UseEzUHFRSSIReader)
 662:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <EzUHFRSSIReader.h>
 663:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(UseSBUSRSSIReader)
 664:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <SBUSRSSIReader.h>
 665:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 666:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 667:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 668:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 669:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 670:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************** MOTORS DECLARATION **************
 671:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 672:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(triConfig)
 673:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined (MOTOR_STM32)
 674:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define MOTORS_STM32_TRI
 675:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Motors_STM32.h>    
 676:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 677:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #include <Motors_Tri.h>
 678:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 679:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_PWM)
 680:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_PWM.h>
 681:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_PWM_Timer)
 682:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_PWM_Timer.h>
 683:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_APM)
 684:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_APM.h>
 685:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_I2C)
 686:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_I2C.h>
 687:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MOTOR_STM32)
 688:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Motors_STM32.h>    
 689:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 690:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 691:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 692:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******* HEADING HOLD MAGNETOMETER DECLARATION **********
 693:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 694:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(HMC5843)
 695:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HeadingFusionProcessorMARG.h>
 696:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_HMC5843.h>
 697:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(SPARKFUN_9DOF_5883L) || defined(SPARKFUN_5883L_BOB) || defined(HMC5883L)
 698:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <HeadingFusionProcessorMARG.h>
 699:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Magnetometer_HMC5883L.h>
 700:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(COMPASS_CHR6DM)
 701:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 702:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 703:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 704:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******* ALTITUDE HOLD BAROMETER DECLARATION ************
 705:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 706:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(BMP085)
 707:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BarometricSensor_BMP085.h>
 708:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <VelocityProcessor.h>
 709:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(MS5611)
 710:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #include <BarometricSensor_MS5611.h>
 711:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  #include <VelocityProcessor.h>
 712:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 713:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(XLMAXSONAR)
 714:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <MaxSonarRangeFinder.h>
 715:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif 
 716:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 717:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //*************** BATTERY MONITOR DECLARATION ************
 718:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 719:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef BattMonitor
 720:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <BatteryMonitor.h>
 721:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifndef BattCustomConfig
 722:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BattCustomConfig BattDefaultConfig
 723:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 724:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   struct BatteryData batteryData[] = {BattCustomConfig};
 725:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 726:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 727:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //************** CAMERA CONTROL DECLARATION **************
 728:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 729:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** // used only on mega for now
 730:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(CameraControl_STM32)
 731:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <CameraStabilizer_STM32.h>
 732:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(CameraControl)
 733:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <CameraStabilizer_Aeroquad.h>
 734:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 735:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 736:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined (CameraTXControl)
 737:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <CameraStabilizer_TXControl.h>
 738:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 739:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 740:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 741:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //******** FLIGHT CONFIGURATION DECLARATION **************
 742:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 743:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(quadXConfig)
 744:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadX.h"
 745:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(quadPlusConfig)
 746:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadPlus.h"
 747:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(hexPlusConfig)
 748:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexPlus.h"
 749:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(hexXConfig)
 750:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexX.h"
 751:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(triConfig)
 752:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlTri.h"
 753:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(quadY4Config)
 754:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlQuadY4.h"
 755:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(hexY6Config)
 756:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlHexY6.h"
 757:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(octoX8Config)
 758:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoX8.h"
 759:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(octoXConfig)
 760:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoX.h"
 761:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #elif defined(octoPlusConfig)
 762:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "FlightControlOctoPlus.h"
 763:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 764:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 765:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 766:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** GPS DECLARATION *********************
 767:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 768:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS)
 769:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if !defined(HeadingMagHold)
 770:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #error We need the magnetometer to use the GPS
 771:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif 
 772:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <GpsAdapter.h>
 773:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "GpsNavigator.h"
 774:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 775:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 776:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 777:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** OSD DEVICE DECLARATION **************
 778:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 779:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef MAX7456_OSD     // only OSD supported for now is the MAX7456
 780:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <Device_SPI.h>
 781:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "OSDDisplayController.h"
 782:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "MAX7456.h"
 783:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 784:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 785:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(SERIAL_LCD)
 786:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "SerialLCD.h"
 787:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 788:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 789:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef OSD_SYSTEM_MENU
 790:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if !defined(MAX7456_OSD) && !defined(SERIAL_LCD)
 791:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #error "Menu cannot be used without OSD or LCD"
 792:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 793:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "OSDMenu.h"
 794:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 795:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 796:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 797:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 798:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //****************** SERIAL PORT DECLARATION *************
 799:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** //********************************************************
 800:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(WirelessTelemetry) 
 801:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
 802:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial3
 803:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else    // force 328p to use the normal port
 804:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial
 805:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 806:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else  
 807:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(SERIAL_USES_USB)   // STM32 Maple
 808:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT SerialUSB
 809:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #undef BAUD
 810:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define BAUD
 811:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #else
 812:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #define SERIAL_PORT Serial
 813:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 814:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif  
 815:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 816:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef SlowTelemetry
 817:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AQ_RSCode.h>
 818:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 819:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 820:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #ifdef SoftModem
 821:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include <AQ_SoftModem.h>
 822:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 823:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 824:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 825:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** // Include this last as it contains objects from above declarations
 826:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "AltitudeControlProcessor.h"
 827:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "FlightControlProcessor.h"
 828:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "FlightCommandProcessor.h"
 829:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "HeadingHoldProcessor.h"
 830:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #include "DataStorage.h"
 831:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 832:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(UseGPS) || defined(BattMonitor)
 833:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "LedStatusProcessor.h"
 834:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif  
 835:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 836:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #if defined(MavLink)
 837:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "MavLink.h"
 838:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #else
 839:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #include "SerialCom.h"
 840:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** #endif
 841:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 842:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 843:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 844:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
 845:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Main setup function, called one time at bootup
 846:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * initialize all system and sub system of the
 847:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Aeroquad
 848:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
 849:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void setup() {
 8580              		.loc 26 849 0
 8581              		.cfi_startproc
 8582              		@ args = 0, pretend = 0, frame = 0
 8583              		@ frame_needed = 0, uses_anonymous_args = 0
 8584 0000 10B5     		push	{r4, lr}
 8585              	.LCFI76:
 8586              		.cfi_def_cfa_offset 8
 8587              		.cfi_offset 4, -8
 8588              		.cfi_offset 14, -4
 8589              	.LBB409:
 850:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   SERIAL_BEGIN(BAUD);
 8590              		.loc 26 850 0
 8591 0002 2548     		ldr	r0, .L571
 8592 0004 4FF4E131 		mov	r1, #115200
 8593 0008 FFF7FEFF 		bl	_ZN9USBSerial5beginEi
 8594              	.LVL689:
 851:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   pinMode(LED_Green, OUTPUT);
 8595              		.loc 26 851 0
 8596 000c 4620     		movs	r0, #70
 8597 000e 0021     		movs	r1, #0
 8598 0010 FFF7FEFF 		bl	_Z7pinModeh13WiringPinMode
 8599              	.LVL690:
 852:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   digitalWrite(LED_Green, LOW);
 8600              		.loc 26 852 0
 8601 0014 4620     		movs	r0, #70
 8602 0016 0021     		movs	r1, #0
 8603 0018 FFF7FEFF 		bl	_Z12digitalWritehh
 8604              	.LVL691:
 853:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 854:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initCommunication();
 855:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 856:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   readEEPROM(); // defined in DataStorage.h
 8605              		.loc 26 856 0
 8606 001c FFF7FEFF 		bl	_Z10readEEPROMv
 8607              	.LVL692:
 857:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   boolean firstTimeBoot = false;
 858:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (readFloat(SOFTWARE_VERSION_ADR) != SOFTWARE_VERSION) { // If we detect the wrong soft version
 8608              		.loc 26 858 0
 8609 0020 4FF48A70 		mov	r0, #276
 8610 0024 FFF7FEFF 		bl	_Z12nvrReadFloati
 8611              	.LVL693:
 8612 0028 DFED1C7A 		flds	s15, .L571+4
 8613 002c 07EE100A 		fmsr	s14, r0
 8614 0030 B4EE677A 		fcmps	s14, s15
 8615 0034 F1EE10FA 		fmstat
 8616 0038 05D0     		beq	.L563
 859:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeEEPROM();
 8617              		.loc 26 859 0
 8618 003a FFF7FEFF 		bl	_Z16initializeEEPROMv
 8619              	.LVL694:
 860:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     writeEEPROM();
 861:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     firstTimeBoot = true;
 8620              		.loc 26 861 0
 8621 003e 0124     		movs	r4, #1
 860:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     writeEEPROM();
 8622              		.loc 26 860 0
 8623 0040 FFF7FEFF 		bl	_Z11writeEEPROMv
 8624              	.LVL695:
 8625 0044 00E0     		b	.L560
 8626              	.LVL696:
 8627              	.L563:
 857:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   boolean firstTimeBoot = false;
 8628              		.loc 26 857 0
 8629 0046 0024     		movs	r4, #0
 8630              	.LVL697:
 8631              	.L560:
 862:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 863:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 864:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initPlatform();
 8632              		.loc 26 864 0
 8633 0048 FFF7FEFF 		bl	_Z12initPlatformv
 8634              	.LVL698:
 865:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 866:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(quadXConfig) || defined(quadPlusConfig) || defined(quadY4Config) || defined(triConfig
 867:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(FOUR_Motors);
 8635              		.loc 26 867 0
 8636 004c 0420     		movs	r0, #4
 8637 004e FFF7FEFF 		bl	_Z16initializeMotors9NB_Motors
 8638              	.LVL699:
 868:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #elif defined(hexPlusConfig) || defined(hexXConfig) || defined(hexY6Config)
 869:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(SIX_Motors);
 870:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #elif defined(octoX8Config) || defined(octoXConfig) || defined(octoPlusConfig)
 871:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initializeMotors(EIGHT_Motors);
 872:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 873:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 874:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeReceiver(LASTCHANNEL);
 8639              		.loc 26 874 0
 8640 0052 0620     		movs	r0, #6
 8641 0054 FFF7FEFF 		bl	_Z18initializeReceiveri
 8642              	.LVL700:
 875:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initReceiverFromEEPROM();
 8643              		.loc 26 875 0
 8644 0058 FFF7FEFF 		bl	_Z22initReceiverFromEEPROMv
 8645              	.LVL701:
 876:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 877:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Initialize sensors
 878:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // If sensors have a common initialization routine
 879:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // insert it into the gyro class because it executes first
 880:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeGyro(); // defined in Gyro.h
 8646              		.loc 26 880 0
 8647 005c FFF7FEFF 		bl	_Z14initializeGyrov
 8648              	.LVL702:
 8649              	.L561:
 881:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   while (!calibrateGyro()); // this make sure the craft is still befor to continue init process
 8650              		.loc 26 881 0 discriminator 1
 8651 0060 FFF7FEFF 		bl	_Z13calibrateGyrov
 8652              	.LVL703:
 8653 0064 0028     		cmp	r0, #0
 8654 0066 FBD0     		beq	.L561
 882:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeAccel(); // defined in Accel.h
 883:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (firstTimeBoot) {
 8655              		.loc 26 883 0
 8656 0068 1CB1     		cbz	r4, .L562
 884:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     computeAccelBias();
 8657              		.loc 26 884 0
 8658 006a FFF7FEFF 		bl	_Z16computeAccelBiasv
 8659              	.LVL704:
 885:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     writeEEPROM();
 8660              		.loc 26 885 0
 8661 006e FFF7FEFF 		bl	_Z11writeEEPROMv
 8662              	.LVL705:
 8663              	.L562:
 886:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 887:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   setupFourthOrder();
 8664              		.loc 26 887 0
 8665 0072 FFF7FEFF 		bl	_Z16setupFourthOrderv
 8666              	.LVL706:
 888:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initSensorsZeroFromEEPROM();
 8667              		.loc 26 888 0
 8668 0076 FFF7FEFF 		bl	_Z25initSensorsZeroFromEEPROMv
 8669              	.LVL707:
 889:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 890:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Flight angle estimation
 891:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   initializeKinematics();
 8670              		.loc 26 891 0
 8671 007a FFF7FEFF 		bl	_Z20initializeKinematicsv
 8672              	.LVL708:
 892:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 893:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef HeadingMagHold
 894:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= HEADINGHOLD_ENABLED;
 895:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeMagnetometer();
 896:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeHeadingFusion();
 897:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 898:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 899:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Optional Sensors
 900:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldBaro
 901:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBaro();
 902:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= ALTITUDEHOLD_ENABLED;
 903:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 904:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
 905:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     inititalizeRangeFinders();
 906:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= RANGE_ENABLED;
 907:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].P = PID[BARO_ALTITUDE_HOLD_PID_IDX].P*2;
 908:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].I = PID[BARO_ALTITUDE_HOLD_PID_IDX].I;
 909:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].D = PID[BARO_ALTITUDE_HOLD_PID_IDX].D;
 910:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     PID[SONAR_ALTITUDE_HOLD_PID_IDX].windupGuard = PID[BARO_ALTITUDE_HOLD_PID_IDX].windupGuard;
 911:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 912:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 913:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef BattMonitor
 914:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeBatteryMonitor(sizeof(batteryData) / sizeof(struct BatteryData), batteryMonitorAlarmV
 915:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= BATTMONITOR_ENABLED;
 916:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 917:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 918:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(CameraControl)
 919:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeCameraStabilization();
 920:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     vehicleState |= CAMERASTABLE_ENABLED;
 921:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 922:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 923:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(MAX7456_OSD)
 924:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeSPI();
 925:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeOSD();
 926:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 927:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 928:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(SERIAL_LCD)
 929:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     InitSerialLCD();
 930:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 931:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 932:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(BinaryWrite) || defined(BinaryWritePID)
 933:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef OpenlogBinaryWrite
 934:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       binaryPort = &Serial1;
 935:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       binaryPort->begin(115200);
 936:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       delay(1000);
 937:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #else
 938:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      binaryPort = &Serial;
 939:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
 940:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 941:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 942:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(UseGPS)
 943:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     initializeGps();
 944:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif 
 945:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 946:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef SlowTelemetry
 947:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      initSlowTelemetry();
 948:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 949:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 950:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   previousTime = micros();
 8673              		.loc 26 950 0
 8674 007e FFF7FEFF 		bl	_ZL6microsv
 8675              	.LVL709:
 8676 0082 074B     		ldr	r3, .L571+8
 951:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   digitalWrite(LED_Green, HIGH);
 8677              		.loc 26 951 0
 8678 0084 0121     		movs	r1, #1
 950:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   previousTime = micros();
 8679              		.loc 26 950 0
 8680 0086 1860     		str	r0, [r3, #0]
 8681              		.loc 26 951 0
 8682 0088 4620     		movs	r0, #70
 8683 008a FFF7FEFF 		bl	_Z12digitalWritehh
 8684              	.LVL710:
 952:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   safetyCheck = 0;
 8685              		.loc 26 952 0
 8686 008e 054B     		ldr	r3, .L571+12
 8687 0090 0022     		movs	r2, #0
 8688 0092 1A70     		strb	r2, [r3, #0]
 8689 0094 10BD     		pop	{r4, pc}
 8690              	.L572:
 8691 0096 00BF     		.align	2
 8692              	.L571:
 8693 0098 00000000 		.word	SerialUSB
 8694 009c CDCC4C40 		.word	1078774989
 8695 00a0 00000000 		.word	.LANCHOR83
 8696 00a4 00000000 		.word	.LANCHOR64
 8697              	.LBE409:
 8698              		.cfi_endproc
 8699              	.LFE223:
 8701              		.section	.text._Z16process100HzTaskv,"ax",%progbits
 8702              		.align	1
 8703              		.global	_Z16process100HzTaskv
 8704              		.thumb
 8705              		.thumb_func
 8707              	_Z16process100HzTaskv:
 8708              	.LFB224:
 953:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 954:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 955:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 956:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
 957:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * 100Hz task
 958:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
 959:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process100HzTask() {
 8709              		.loc 26 959 0
 8710              		.cfi_startproc
 8711              		@ args = 0, pretend = 0, frame = 0
 8712              		@ frame_needed = 0, uses_anonymous_args = 0
 8713              	.LBB410:
 960:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 961:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 8714              		.loc 26 961 0
 8715 0000 1C4B     		ldr	r3, .L576
 8716 0002 1A68     		ldr	r2, [r3, #0]
 8717 0004 1C4B     		ldr	r3, .L576+4
 8718 0006 1968     		ldr	r1, [r3, #0]
 8719 0008 511A     		subs	r1, r2, r1
 8720 000a 07EE901A 		fmsr	s15, r1	@ int
 8721 000e B8EE677A 		fuitos	s14, s15
 8722 0012 DFED1A7A 		flds	s15, .L576+8
 8723 0016 C7EE277A 		fdivs	s15, s14, s15
 8724              	.LBE410:
 959:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process100HzTask() {
 8725              		.loc 26 959 0
 8726 001a F0B5     		push	{r4, r5, r6, r7, lr}
 8727              	.LCFI77:
 8728              		.cfi_def_cfa_offset 20
 8729              		.cfi_offset 4, -20
 8730              		.cfi_offset 5, -16
 8731              		.cfi_offset 6, -12
 8732              		.cfi_offset 7, -8
 8733              		.cfi_offset 14, -4
 8734              	.LBB413:
 8735              		.loc 26 961 0
 8736 001c 1849     		ldr	r1, .L576+12
 962:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   hundredHZpreviousTime = currentTime;
 8737              		.loc 26 962 0
 8738 001e 1A60     		str	r2, [r3, #0]
 8739              	.LBE413:
 959:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process100HzTask() {
 8740              		.loc 26 959 0
 8741 0020 85B0     		sub	sp, sp, #20
 8742              	.LCFI78:
 8743              		.cfi_def_cfa_offset 40
 8744              	.LBB414:
 959:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process100HzTask() {
 8745              		.loc 26 959 0
 8746 0022 184E     		ldr	r6, .L576+16
 8747 0024 184D     		ldr	r5, .L576+20
 8748              	.LBB411:
 963:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 964:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   evaluateGyroRate();
 965:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   evaluateMetersPerSec();
 966:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 967:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 968:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     filteredAccel[axis] = computeFourthOrder(meterPerSecSec[axis], &fourthOrder[axis]);
 8749              		.loc 26 968 0
 8750 0026 194F     		ldr	r7, .L576+24
 8751              	.LBE411:
 967:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 8752              		.loc 26 967 0
 8753 0028 0024     		movs	r4, #0
 961:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   G_Dt = (currentTime - hundredHZpreviousTime) / 1000000.0;
 8754              		.loc 26 961 0
 8755 002a C1ED007A 		fsts	s15, [r1, #0]
 964:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   evaluateGyroRate();
 8756              		.loc 26 964 0
 8757 002e FFF7FEFF 		bl	_Z16evaluateGyroRatev
 8758              	.LVL711:
 965:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   evaluateMetersPerSec();
 8759              		.loc 26 965 0
 8760 0032 FFF7FEFF 		bl	_Z20evaluateMetersPerSecv
 8761              	.LVL712:
 8762              	.L574:
 8763              	.LBB412:
 8764              		.loc 26 968 0 discriminator 2
 8765 0036 07EB4411 		add	r1, r7, r4, lsl #5
 8766 003a 56F8040F 		ldr	r0, [r6, #4]!	@ float
 8767 003e FFF7FEFF 		bl	_Z18computeFourthOrderfP15fourthOrderData
 8768              	.LVL713:
 967:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 8769              		.loc 26 967 0 discriminator 2
 8770 0042 0134     		adds	r4, r4, #1
 8771              	.LVL714:
 8772 0044 032C     		cmp	r4, #3
 8773              		.loc 26 968 0 discriminator 2
 8774 0046 45F8040F 		str	r0, [r5, #4]!	@ float
 967:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   for (int axis = XAXIS; axis <= ZAXIS; axis++) {
 8775              		.loc 26 967 0 discriminator 2
 8776 004a F4D1     		bne	.L574
 8777              	.LBE412:
 969:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
 970:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
 971:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   calculateKinematics(gyroRate[XAXIS], gyroRate[YAXIS], gyroRate[ZAXIS], filteredAccel[XAXIS], filt
 8778              		.loc 26 971 0
 8779 004c 104B     		ldr	r3, .L576+28
 8780 004e 114A     		ldr	r2, .L576+32
 8781 0050 5968     		ldr	r1, [r3, #4]	@ float
 8782 0052 0091     		str	r1, [sp, #0]	@ float
 8783 0054 9968     		ldr	r1, [r3, #8]	@ float
 8784 0056 0191     		str	r1, [sp, #4]	@ float
 8785 0058 0949     		ldr	r1, .L576+12
 8786 005a 0968     		ldr	r1, [r1, #0]	@ float
 8787 005c 0291     		str	r1, [sp, #8]	@ float
 8788 005e 1068     		ldr	r0, [r2, #0]	@ float
 8789 0060 5168     		ldr	r1, [r2, #4]	@ float
 8790 0062 1B68     		ldr	r3, [r3, #0]	@ float
 8791 0064 9268     		ldr	r2, [r2, #8]	@ float
 8792 0066 FFF7FEFF 		bl	_Z19calculateKinematicsfffffff
 8793              	.LVL715:
 8794              	.LBE414:
 972:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 973:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined AltitudeHoldBaro
 974:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     float filteredZAccel = (filteredAccel[ZAXIS] * (1 - accelOneG * invSqrt(isq(filteredAccel[XAXIS
 975:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     computeVelocity(filteredZAccel, G_Dt);
 976:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     zVelocitySum+=computedZVelicity;
 977:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     zVelocityCount++;
 978:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****    
 979:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureBaroSum(); 
 980:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % THROTTLE_ADJUST_TASK_SPEED == 0) {  //  50 Hz tasks
 981:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       evaluateBaroAltitude();
 982:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       computeVelocityErrorFromBaroAltitude(getBaroAltitude());
 983:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
 984:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       float estimatedBaroAltitude = (previousBaroAltitude) + (zVelocity / 50.0);
 985:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       estimatedAltitude = ((getBaroAltitude()*0.1) + (estimatedBaroAltitude*0.9));
 986:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      
 987:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       previousBaroAltitude = getBaroAltitude();
 988:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       zVelocity = computedZVelicity;
 989:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
 990:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
 991:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****         
 992:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   processFlightControl();
 993:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 994:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
 995:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(BinaryWrite)
 996:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (fastTransfer == ON) {
 997:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       // write out fastTelemetry to Configurator or openLog
 998:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       fastTelemetry();
 999:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1000:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif      
1001:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1002:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef SlowTelemetry
1003:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     updateSlowTelemetry100Hz();
1004:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1005:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1006:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(UseGPS)
1007:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     updateGps();
1008:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif      
1009:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1010:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(CameraControl)
1011:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     moveCamera(kinematicsAngle[YAXIS],kinematicsAngle[XAXIS],kinematicsAngle[ZAXIS]);
1012:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #if defined CameraTXControl
1013:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       processCameraTXControl();
1014:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1015:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif       
1016:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1017:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 8795              		.loc 26 1017 0
 8796 006a 05B0     		add	sp, sp, #20
 8797 006c BDE8F040 		pop	{r4, r5, r6, r7, lr}
 8798              	.LBB415:
 992:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   processFlightControl();
 8799              		.loc 26 992 0
 8800 0070 FFF7FEBF 		b	_Z20processFlightControlv
 8801              	.LVL716:
 8802              	.L577:
 8803              		.align	2
 8804              	.L576:
 8805 0074 00000000 		.word	.LANCHOR13
 8806 0078 00000000 		.word	.LANCHOR84
 8807 007c 00247449 		.word	1232348160
 8808 0080 00000000 		.word	.LANCHOR50
 8809 0084 FCFFFFFF 		.word	.LANCHOR28-4
 8810 0088 FCFFFFFF 		.word	.LANCHOR82-4
 8811 008c 00000000 		.word	.LANCHOR16
 8812 0090 00000000 		.word	.LANCHOR82
 8813 0094 00000000 		.word	.LANCHOR21
 8814              	.LBE415:
 8815              		.cfi_endproc
 8816              	.LFE224:
 8818              		.section	.text._Z15process50HzTaskv,"ax",%progbits
 8819              		.align	1
 8820              		.global	_Z15process50HzTaskv
 8821              		.thumb
 8822              		.thumb_func
 8824              	_Z15process50HzTaskv:
 8825              	.LFB225:
1018:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1019:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1020:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * 50Hz task
1021:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
1022:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process50HzTask() {
 8826              		.loc 26 1022 0
 8827              		.cfi_startproc
 8828              		@ args = 0, pretend = 0, frame = 0
 8829              		@ frame_needed = 0, uses_anonymous_args = 0
 8830              		@ link register save eliminated.
1023:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 8831              		.loc 26 1023 0
 8832 0000 094B     		ldr	r3, .L579
 8833 0002 1A68     		ldr	r2, [r3, #0]
 8834 0004 094B     		ldr	r3, .L579+4
 8835 0006 1968     		ldr	r1, [r3, #0]
1024:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   fiftyHZpreviousTime = currentTime;
 8836              		.loc 26 1024 0
 8837 0008 1A60     		str	r2, [r3, #0]
1023:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   G_Dt = (currentTime - fiftyHZpreviousTime) / 1000000.0;
 8838              		.loc 26 1023 0
 8839 000a 511A     		subs	r1, r2, r1
 8840 000c 07EE901A 		fmsr	s15, r1	@ int
 8841 0010 B8EE677A 		fuitos	s14, s15
 8842 0014 DFED067A 		flds	s15, .L579+8
 8843 0018 C7EE277A 		fdivs	s15, s14, s15
 8844 001c 0549     		ldr	r1, .L579+12
 8845 001e C1ED007A 		fsts	s15, [r1, #0]
1025:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1026:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Reads external pilot commands and performs functions based on stick configuration
1027:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   readPilotCommands(); 
1028:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1029:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(UseAnalogRSSIReader) || defined(UseEzUHFRSSIReader) || defined(UseSBUSRSSIReader)
1030:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     readRSSI();
1031:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1032:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1033:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef AltitudeHoldRangeFinder
1034:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     updateRangeFinders();
1035:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1036:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1037:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(UseGPS)
1038:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (haveAGpsLock() && !isHomeBaseInitialized()) {
1039:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       initHomeBase();
1040:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1041:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif      
1042:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 8846              		.loc 26 1042 0
1027:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   readPilotCommands(); 
 8847              		.loc 26 1027 0
 8848 0022 FFF7FEBF 		b	_Z17readPilotCommandsv
 8849              	.LVL717:
 8850              	.L580:
 8851 0026 00BF     		.align	2
 8852              	.L579:
 8853 0028 00000000 		.word	.LANCHOR13
 8854 002c 00000000 		.word	.LANCHOR85
 8855 0030 00247449 		.word	1232348160
 8856 0034 00000000 		.word	.LANCHOR50
 8857              		.cfi_endproc
 8858              	.LFE225:
 8860              		.section	.text._Z16process10HzTask1v,"ax",%progbits
 8861              		.align	1
 8862              		.global	_Z16process10HzTask1v
 8863              		.thumb
 8864              		.thumb_func
 8866              	_Z16process10HzTask1v:
 8867              	.LFB226:
1043:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1044:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1045:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * 10Hz task
1046:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
1047:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process10HzTask1() {
 8868              		.loc 26 1047 0
 8869              		.cfi_startproc
 8870              		@ args = 0, pretend = 0, frame = 0
 8871              		@ frame_needed = 0, uses_anonymous_args = 0
 8872              		@ link register save eliminated.
 8873 0000 7047     		bx	lr
 8874              		.cfi_endproc
 8875              	.LFE226:
 8877              		.section	.text._Z16process10HzTask2v,"ax",%progbits
 8878              		.align	1
 8879              		.global	_Z16process10HzTask2v
 8880              		.thumb
 8881              		.thumb_func
 8883              	_Z16process10HzTask2v:
 8884              	.LFB227:
1048:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1049:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(HeadingMagHold)
1050:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1051:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - tenHZpreviousTime) / 1000000.0;
1052:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     tenHZpreviousTime = currentTime;
1053:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****      
1054:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureMagnetometer(kinematicsAngle[XAXIS], kinematicsAngle[YAXIS]);
1055:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1056:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     calculateHeading();
1057:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1058:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1059:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
1060:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1061:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1062:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * low priority 10Hz task 2
1063:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
1064:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process10HzTask2() {
 8885              		.loc 26 1064 0
 8886              		.cfi_startproc
 8887              		@ args = 0, pretend = 0, frame = 0
 8888              		@ frame_needed = 0, uses_anonymous_args = 0
 8889              		.loc 26 1064 0
 8890 0000 08B5     		push	{r3, lr}
 8891              	.LCFI79:
 8892              		.cfi_def_cfa_offset 8
 8893              		.cfi_offset 3, -8
 8894              		.cfi_offset 14, -4
1065:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 8895              		.loc 26 1065 0
 8896 0002 0B4B     		ldr	r3, .L583
 8897 0004 1A68     		ldr	r2, [r3, #0]
 8898 0006 0B4B     		ldr	r3, .L583+4
 8899 0008 1968     		ldr	r1, [r3, #0]
1066:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   lowPriorityTenHZpreviousTime = currentTime;
 8900              		.loc 26 1066 0
 8901 000a 1A60     		str	r2, [r3, #0]
1065:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   G_Dt = (currentTime - lowPriorityTenHZpreviousTime) / 1000000.0;
 8902              		.loc 26 1065 0
 8903 000c 511A     		subs	r1, r2, r1
 8904 000e 07EE901A 		fmsr	s15, r1	@ int
 8905 0012 B8EE677A 		fuitos	s14, s15
 8906 0016 DFED087A 		flds	s15, .L583+8
 8907 001a C7EE277A 		fdivs	s15, s14, s15
 8908 001e 0749     		ldr	r1, .L583+12
 8909 0020 C1ED007A 		fsts	s15, [r1, #0]
1067:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1068:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #if defined(BattMonitor)
1069:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     measureBatteryVoltage(G_Dt*1000.0);
1070:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1071:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1072:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // Listen for configuration commands and reports telemetry
1073:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   readSerialCommand();
 8910              		.loc 26 1073 0
 8911 0024 FFF7FEFF 		bl	_Z17readSerialCommandv
 8912              	.LVL718:
1074:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   sendSerialTelemetry();
1075:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 8913              		.loc 26 1075 0
 8914 0028 BDE80840 		pop	{r3, lr}
1074:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   sendSerialTelemetry();
 8915              		.loc 26 1074 0
 8916 002c FFF7FEBF 		b	_Z19sendSerialTelemetryv
 8917              	.LVL719:
 8918              	.L584:
 8919              		.align	2
 8920              	.L583:
 8921 0030 00000000 		.word	.LANCHOR13
 8922 0034 00000000 		.word	.LANCHOR86
 8923 0038 00247449 		.word	1232348160
 8924 003c 00000000 		.word	.LANCHOR50
 8925              		.cfi_endproc
 8926              	.LFE227:
 8928              		.section	.text._Z16process10HzTask3v,"ax",%progbits
 8929              		.align	1
 8930              		.global	_Z16process10HzTask3v
 8931              		.thumb
 8932              		.thumb_func
 8934              	_Z16process10HzTask3v:
 8935              	.LFB228:
1076:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1077:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1078:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * low priority 10Hz task 3
1079:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
1080:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process10HzTask3() {
 8936              		.loc 26 1080 0
 8937              		.cfi_startproc
 8938              		@ args = 0, pretend = 0, frame = 0
 8939              		@ frame_needed = 0, uses_anonymous_args = 0
 8940              		@ link register save eliminated.
1081:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 8941              		.loc 26 1081 0
 8942 0000 084B     		ldr	r3, .L586
 8943 0002 1A68     		ldr	r2, [r3, #0]
 8944 0004 084B     		ldr	r3, .L586+4
 8945 0006 1968     		ldr	r1, [r3, #0]
1082:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     lowPriorityTenHZpreviousTime2 = currentTime;
 8946              		.loc 26 1082 0
 8947 0008 1A60     		str	r2, [r3, #0]
1081:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - lowPriorityTenHZpreviousTime2) / 1000000.0;
 8948              		.loc 26 1081 0
 8949 000a 511A     		subs	r1, r2, r1
 8950 000c 07EE901A 		fmsr	s15, r1	@ int
 8951 0010 B8EE677A 		fuitos	s14, s15
 8952 0014 DFED057A 		flds	s15, .L586+8
 8953 0018 C7EE277A 		fdivs	s15, s14, s15
 8954 001c 0449     		ldr	r1, .L586+12
 8955 001e C1ED007A 		fsts	s15, [r1, #0]
 8956              		.loc 26 1082 0
 8957 0022 7047     		bx	lr
 8958              	.L587:
 8959              		.align	2
 8960              	.L586:
 8961 0024 00000000 		.word	.LANCHOR13
 8962 0028 00000000 		.word	.LANCHOR87
 8963 002c 00247449 		.word	1232348160
 8964 0030 00000000 		.word	.LANCHOR50
 8965              		.cfi_endproc
 8966              	.LFE228:
 8968              		.section	.text._Z14process1HzTaskv,"ax",%progbits
 8969              		.align	1
 8970              		.global	_Z14process1HzTaskv
 8971              		.thumb
 8972              		.thumb_func
 8974              	_Z14process1HzTaskv:
 8975              	.LFB229:
1083:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1084:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef OSD_SYSTEM_MENU
1085:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       updateOSDMenu();
1086:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1087:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1088:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef MAX7456_OSD
1089:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       updateOSD();
1090:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1091:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1092:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #if defined(UseGPS) || defined(BattMonitor)
1093:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       processLedStatus();
1094:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1095:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1096:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #ifdef SlowTelemetry
1097:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       updateSlowTelemetry10Hz();
1098:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     #endif
1099:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
1100:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1101:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1102:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * 1Hz task 
1103:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
1104:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void process1HzTask() {
 8976              		.loc 26 1104 0
 8977              		.cfi_startproc
 8978              		@ args = 0, pretend = 0, frame = 0
 8979              		@ frame_needed = 0, uses_anonymous_args = 0
 8980              		@ link register save eliminated.
 8981 0000 7047     		bx	lr
 8982              		.cfi_endproc
 8983              	.LFE229:
 8985              		.section	.text._Z4loopv,"ax",%progbits
 8986              		.align	1
 8987              		.global	_Z4loopv
 8988              		.thumb
 8989              		.thumb_func
 8991              	_Z4loopv:
 8992              	.LFB230:
1105:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #ifdef MavLink
1106:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     G_Dt = (currentTime - oneHZpreviousTime) / 1000000.0;
1107:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     oneHZpreviousTime = currentTime;
1108:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1109:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     sendSerialHeartbeat();   
1110:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   #endif
1111:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
1112:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1113:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** /*******************************************************************
1114:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  * Main loop funtions
1115:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****  ******************************************************************/
1116:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** void loop () {
 8993              		.loc 26 1116 0
 8994              		.cfi_startproc
 8995              		@ args = 0, pretend = 0, frame = 0
 8996              		@ frame_needed = 0, uses_anonymous_args = 0
 8997              		.loc 26 1116 0
 8998 0000 10B5     		push	{r4, lr}
 8999              	.LCFI80:
 9000              		.cfi_def_cfa_offset 8
 9001              		.cfi_offset 4, -8
 9002              		.cfi_offset 14, -4
1117:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 9003              		.loc 26 1118 0
 9004 0002 FFF7FEFF 		bl	_ZL6microsv
 9005              	.LVL720:
 9006 0006 1E4B     		ldr	r3, .L598
1119:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   deltaTime = currentTime - previousTime;
 9007              		.loc 26 1119 0
 9008 0008 1E4C     		ldr	r4, .L598+4
1118:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   currentTime = micros();
 9009              		.loc 26 1118 0
 9010 000a 1860     		str	r0, [r3, #0]
 9011              		.loc 26 1119 0
 9012 000c 1E4B     		ldr	r3, .L598+8
 9013 000e 1B68     		ldr	r3, [r3, #0]
 9014 0010 C01A     		subs	r0, r0, r3
 9015 0012 2060     		str	r0, [r4, #0]
1120:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1121:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   measureCriticalSensors();
 9016              		.loc 26 1121 0
 9017 0014 FFF7FEFF 		bl	_Z22measureCriticalSensorsv
 9018              	.LVL721:
1122:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1123:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // ================================================================
1124:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // 100Hz task loop
1125:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   // ================================================================
1126:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (deltaTime >= 10000) {
 9019              		.loc 26 1126 0
 9020 0018 2268     		ldr	r2, [r4, #0]
 9021 001a 42F20F73 		movw	r3, #9999
 9022 001e 9A42     		cmp	r2, r3
 9023 0020 27D9     		bls	.L590
1127:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1128:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     frameCounter++;
 9024              		.loc 26 1128 0
 9025 0022 1A4C     		ldr	r4, .L598+12
 9026 0024 2368     		ldr	r3, [r4, #0]
 9027 0026 0133     		adds	r3, r3, #1
 9028 0028 2360     		str	r3, [r4, #0]
1129:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1130:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     process100HzTask();
 9029              		.loc 26 1130 0
 9030 002a FFF7FEFF 		bl	_Z16process100HzTaskv
 9031              	.LVL722:
1131:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1132:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1133:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 50Hz task loop
1134:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1135:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_50HZ == 0) {  //  50 Hz tasks
 9032              		.loc 26 1135 0
 9033 002e 2368     		ldr	r3, [r4, #0]
 9034 0030 D907     		lsls	r1, r3, #31
 9035 0032 01D4     		bmi	.L591
1136:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       process50HzTask();
 9036              		.loc 26 1136 0
 9037 0034 FFF7FEFF 		bl	_Z15process50HzTaskv
 9038              	.LVL723:
 9039              	.L591:
1137:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1138:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** 
1139:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1140:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 10Hz task loop
1141:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1142:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_10HZ == 0) {  //   10 Hz tasks
 9040              		.loc 26 1142 0
 9041 0038 2268     		ldr	r2, [r4, #0]
 9042 003a 0A23     		movs	r3, #10
 9043 003c B2FBF3F1 		udiv	r1, r2, r3
 9044 0040 03FB1123 		mls	r3, r3, r1, r2
 9045 0044 8BB1     		cbz	r3, .L592
1143:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       process10HzTask1();
1144:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1145:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime) > 100000) {
 9046              		.loc 26 1145 0
 9047 0046 0E4B     		ldr	r3, .L598
 9048 0048 1A68     		ldr	r2, [r3, #0]
 9049 004a 114B     		ldr	r3, .L598+16
 9050 004c 1968     		ldr	r1, [r3, #0]
 9051 004e 114B     		ldr	r3, .L598+20
 9052 0050 511A     		subs	r1, r2, r1
 9053 0052 9942     		cmp	r1, r3
 9054 0054 02D9     		bls	.L593
1146:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       process10HzTask2();
 9055              		.loc 26 1146 0
 9056 0056 FFF7FEFF 		bl	_Z16process10HzTask2v
 9057              	.LVL724:
 9058 005a 06E0     		b	.L592
 9059              	.L593:
1147:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1148:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     else if ((currentTime - lowPriorityTenHZpreviousTime2) > 100000) {
 9060              		.loc 26 1148 0
 9061 005c 0E49     		ldr	r1, .L598+24
 9062 005e 0968     		ldr	r1, [r1, #0]
 9063 0060 521A     		subs	r2, r2, r1
 9064 0062 9A42     		cmp	r2, r3
 9065 0064 01D9     		bls	.L592
1149:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       process10HzTask3();
 9066              		.loc 26 1149 0
 9067 0066 FFF7FEFF 		bl	_Z16process10HzTask3v
 9068              	.LVL725:
 9069              	.L592:
1150:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1151:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1152:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1153:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // 1Hz task loop
1154:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     // ================================================================
1155:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     if (frameCounter % TASK_1HZ == 0) {  //   1 Hz tasks
1156:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       process1HzTask();
1157:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     }
1158:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     
1159:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****     previousTime = currentTime;
 9070              		.loc 26 1159 0
 9071 006a 054B     		ldr	r3, .L598
 9072 006c 1A68     		ldr	r2, [r3, #0]
 9073 006e 064B     		ldr	r3, .L598+8
 9074 0070 1A60     		str	r2, [r3, #0]
 9075              	.L590:
1160:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1161:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   
1162:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   if (frameCounter >= 100) {
 9076              		.loc 26 1162 0
 9077 0072 064B     		ldr	r3, .L598+12
 9078 0074 1A68     		ldr	r2, [r3, #0]
 9079 0076 632A     		cmp	r2, #99
 9080 0078 01D9     		bls	.L589
1163:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****       frameCounter = 0;
 9081              		.loc 26 1163 0
 9082 007a 0022     		movs	r2, #0
 9083 007c 1A60     		str	r2, [r3, #0]
 9084              	.L589:
 9085 007e 10BD     		pop	{r4, pc}
 9086              	.L599:
 9087              		.align	2
 9088              	.L598:
 9089 0080 00000000 		.word	.LANCHOR13
 9090 0084 00000000 		.word	.LANCHOR88
 9091 0088 00000000 		.word	.LANCHOR83
 9092 008c 00000000 		.word	.LANCHOR75
 9093 0090 00000000 		.word	.LANCHOR86
 9094 0094 A0860100 		.word	100000
 9095 0098 00000000 		.word	.LANCHOR87
 9096              		.cfi_endproc
 9097              	.LFE230:
 9099              		.section	.text.startup.main,"ax",%progbits
 9100              		.align	1
 9101              		.global	main
 9102              		.thumb
 9103              		.thumb_func
 9105              	main:
 9106              	.LFB116:
  11:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** }
  12:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 
  13:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** // Uncomment this if compiling on OS X
  14:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** /*extern "C"{
  15:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 	void _init(){}; // dummy _init function for support of GNU toolchain from https://launchpad.net/gc
  16:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** }*/
  17:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 
  18:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** int main(void)
  19:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** {
 9107              		.loc 4 19 0
 9108              		.cfi_startproc
 9109              		@ Volatile: function does not return.
 9110              		@ args = 0, pretend = 0, frame = 0
 9111              		@ frame_needed = 0, uses_anonymous_args = 0
 9112 0000 08B5     		push	{r3, lr}
 9113              	.LCFI81:
 9114              		.cfi_def_cfa_offset 8
 9115              		.cfi_offset 3, -8
 9116              		.cfi_offset 14, -4
  20:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 	//init();
  21:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp ****   	setup();
 9117              		.loc 4 21 0
 9118 0002 FFF7FEFF 		bl	_Z5setupv
 9119              	.LVL726:
 9120              	.L601:
  22:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 
  23:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 	for (;;)
  24:c:/Working/Aeroquad/AeroQuad32\AeroQuadMain.cpp **** 		loop();
 9121              		.loc 4 24 0 discriminator 1
 9122 0006 FFF7FEFF 		bl	_Z4loopv
 9123              	.LVL727:
 9124 000a FCE7     		b	.L601
 9125              		.cfi_endproc
 9126              	.LFE116:
 9128              		.section	.text.startup._GLOBAL__sub_I__Z7premainv,"ax",%progbits
 9129              		.align	1
 9130              		.thumb
 9131              		.thumb_func
 9133              	_GLOBAL__sub_I__Z7premainv:
 9134              	.LFB232:
1164:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino ****   }
1165:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\AeroQuad.ino **** }
 9135              		.loc 26 1165 0
 9136              		.cfi_startproc
 9137              		@ args = 0, pretend = 0, frame = 0
 9138              		@ frame_needed = 0, uses_anonymous_args = 0
 9139              	.LVL728:
 9140 0000 10B5     		push	{r4, lr}
 9141              	.LCFI82:
 9142              		.cfi_def_cfa_offset 8
 9143              		.cfi_offset 4, -8
 9144              		.cfi_offset 14, -4
 9145              	.LBB423:
 9146              	.LBB424:
 9147              	.LBB425:
 9148              	.LBB426:
  17:../Libraries/AQ_SPI/HardwareSPIExt.h **** 	HardwareSPIExt(uint32 spiPortNumber) : HardwareSPI(spiPortNumber) {
 9149              		.loc 8 17 0
 9150 0002 084C     		ldr	r4, .L603
 9151 0004 0421     		movs	r1, #4
 9152 0006 2046     		mov	r0, r4
 9153 0008 FFF7FEFF 		bl	_ZN11HardwareSPIC2Ej
 9154              	.LVL729:
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
 9155              		.loc 8 18 0
 9156 000c 2046     		mov	r0, r4
 9157 000e FFF7FEFF 		bl	_ZN11HardwareSPI6nssPinEv
 9158              	.LVL730:
  19:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		fSpiMultiFlag = 0;
 9159              		.loc 8 19 0
 9160 0012 0023     		movs	r3, #0
 9161 0014 2372     		strb	r3, [r4, #8]
  18:../Libraries/AQ_SPI/HardwareSPIExt.h **** 		SetCS(nssPin());
 9162              		.loc 8 18 0
 9163 0016 6060     		str	r0, [r4, #4]
 9164              	.LBE426:
 9165              	.LBE425:
  27:c:/Working/Aeroquad/AeroQuad32/../AeroQuad\HeadingHoldProcessor.h **** unsigned long headingTime = micros();
 9166              		.loc 21 27 0
 9167 0018 FFF7FEFF 		bl	_ZL6microsv
 9168              	.LVL731:
 9169 001c 024B     		ldr	r3, .L603+4
 9170 001e 1860     		str	r0, [r3, #0]
 9171 0020 10BD     		pop	{r4, pc}
 9172              	.L604:
 9173 0022 00BF     		.align	2
 9174              	.L603:
 9175 0024 00000000 		.word	.LANCHOR17
 9176 0028 00000000 		.word	.LANCHOR74
 9177              	.LBE424:
 9178              	.LBE423:
 9179              		.cfi_endproc
 9180              	.LFE232:
 9182              		.section	.init_array,"aw",%init_array
 9183              		.align	2
 9184 0004 00000000 		.word	_GLOBAL__sub_I__Z7premainv(target1)
 9185              		.global	queryType
 9186              		.global	headingTime
 9187              		.global	setHeading
 9188              		.global	motorConfiguratorCommand
 9189              		.global	motorMinCommand
 9190              		.global	motorMaxCommand
 9191              		.global	motorAxisCommandYaw
 9192              		.global	motorAxisCommandPitch
 9193              		.global	motorAxisCommandRoll
 9194              		.global	motorCommand
 9195              		.global	numberOfMotors
 9196              		.global	FrqData
 9197              		.global	currentChannel
 9198              		.global	rawChannelValue
 9199              		.global	previousEz
 9200              		.global	previousEy
 9201              		.global	previousEx
 9202              		.global	ezInt
 9203              		.global	eyInt
 9204              		.global	exInt
 9205              		.global	q3
 9206              		.global	q2
 9207              		.global	q1
 9208              		.global	q0
 9209              		.global	halfT
 9210              		.global	Ki
 9211              		.global	Kp
 9212              		.global	accelCutoff
 9213              		.global	earthAccel
 9214              		.global	correctedRateVector
 9215              		.global	kinematicsAngle
 9216              		.global	kinematicsType
 9217              		.global	measureCriticalSensorsTime
 9218              		.global	previousMeasureCriticalSensorsTime
 9219              		.global	accelSampleCount
 9220              		.global	accelSample
 9221              		.global	meterPerSecSec
 9222              		.global	accelOneG
 9223              		.global	runTimeAccelBias
 9224              		.global	accelScaleFactor
 9225              		.global	gyroSampleCount
 9226              		.global	gyroLastMesuredTime
 9227              		.global	gyroHeading
 9228              		.global	gyroScaleFactor
 9229              		.global	gyroSample
 9230              		.global	gyroZero
 9231              		.global	gyroRate
 9232              		.global	spiMPU6000
 9233              		.global	MPU6000
 9234              		.global	vehicleState
 9235              		.global	gyroRaw
 9236              		.global	Serial
 9237              		.global	fourthOrder
 9238              		.global	PID
 9239              		.global	fastTransfer
 9240              		.global	headingHoldState
 9241              		.global	relativeHeading
 9242              		.global	heading
 9243              		.global	headingHold
 9244              		.global	headingHoldConfig
 9245              		.global	aref
 9246              		.global	hundredHZpreviousTime
 9247              		.global	fiftyHZpreviousTime
 9248              		.global	lowPriorityTenHZpreviousTime2
 9249              		.global	lowPriorityTenHZpreviousTime
 9250              		.global	tenHZpreviousTime
 9251              		.global	oneHZpreviousTime
 9252              		.global	deltaTime
 9253              		.global	currentTime
 9254              		.global	previousTime
 9255              		.global	rotationSpeedFactor
 9256              		.global	inFlight
 9257              		.global	filteredAccel
 9258              		.global	minLimit
 9259              		.global	maxLimit
 9260              		.global	safetyCheck
 9261              		.global	motorArmed
 9262              		.global	throttle
 9263              		.global	G_Dt
 9264              		.global	minArmedThrottle
 9265              		.global	frameCounter
 9266              		.global	flightMode
 9267              		.global	previousFlightMode
 9268              		.global	testCommand
 9269              		.global	calibrateESC
 9270              		.global	channelCal
 9271              		.global	receiverSmoothFactor
 9272              		.global	receiverOffset
 9273              		.global	receiverSlope
 9274              		.global	receiverCommandSmooth
 9275              		.global	receiverCommand
 9276              		.global	receiverZero
 9277              		.global	receiverData
 9278              		.global	receiverXmitFactor
 9279              		.global	lastReceiverChannel
 9280              		.section	.bss.MPU6000,"aw",%nobits
 9281              		.align	1
 9282              		.set	.LANCHOR19,. + 0
 9285              	MPU6000:
 9286 0000 00000000 		.space	14
 9286      00000000 
 9286      00000000 
 9286      0000
 9287              		.section	.bss.receiverData,"aw",%nobits
 9288              		.align	2
 9289              		.set	.LANCHOR11,. + 0
 9292              	receiverData:
 9293 0000 00000000 		.space	40
 9293      00000000 
 9293      00000000 
 9293      00000000 
 9293      00000000 
 9294              		.section	.bss.motorArmed,"aw",%nobits
 9295              		.set	.LANCHOR76,. + 0
 9298              	motorArmed:
 9299 0000 00       		.space	1
 9300              		.section	.bss.motorMinCommand,"aw",%nobits
 9301              		.align	2
 9302              		.set	.LANCHOR66,. + 0
 9305              	motorMinCommand:
 9306 0000 00000000 		.space	16
 9306      00000000 
 9306      00000000 
 9306      00000000 
 9307              		.section	.bss.gyroHeading,"aw",%nobits
 9308              		.align	2
 9309              		.set	.LANCHOR22,. + 0
 9312              	gyroHeading:
 9313 0000 00000000 		.space	4
 9314              		.section	.bss.deltaTime,"aw",%nobits
 9315              		.align	2
 9316              		.set	.LANCHOR88,. + 0
 9319              	deltaTime:
 9320 0000 00000000 		.space	4
 9321              		.section	.data.rotationSpeedFactor,"aw",%progbits
 9322              		.align	2
 9323              		.set	.LANCHOR60,. + 0
 9326              	rotationSpeedFactor:
 9327 0000 0000803F 		.word	1065353216
 9328              		.section	.bss.motorAxisCommandPitch,"aw",%nobits
 9329              		.align	2
 9330              		.set	.LANCHOR56,. + 0
 9333              	motorAxisCommandPitch:
 9334 0000 00000000 		.space	4
 9335              		.section	.bss.receiverSmoothFactor,"aw",%nobits
 9336              		.align	2
 9337              		.set	.LANCHOR9,. + 0
 9340              	receiverSmoothFactor:
 9341 0000 00000000 		.space	40
 9341      00000000 
 9341      00000000 
 9341      00000000 
 9341      00000000 
 9342              		.section	.bss.FrqData,"aw",%nobits
 9343              		.align	2
 9344              		.set	.LANCHOR0,. + 0
 9347              	FrqData:
 9348 0000 00000000 		.space	24
 9348      00000000 
 9348      00000000 
 9348      00000000 
 9348      00000000 
 9349              		.section	.bss.previousEz,"aw",%nobits
 9350              		.align	2
 9351              		.set	.LANCHOR48,. + 0
 9354              	previousEz:
 9355 0000 00000000 		.space	4
 9356              		.section	.bss.currentTime,"aw",%nobits
 9357              		.align	2
 9358              		.set	.LANCHOR13,. + 0
 9361              	currentTime:
 9362 0000 00000000 		.space	4
 9363              		.section	.bss.previousMeasureCriticalSensorsTime,"aw",%nobits
 9364              		.align	2
 9365              		.set	.LANCHOR35,. + 0
 9368              	previousMeasureCriticalSensorsTime:
 9369 0000 00000000 		.space	4
 9370              		.section	.data.queryType,"aw",%progbits
 9371              		.set	.LANCHOR79,. + 0
 9374              	queryType:
 9375 0000 58       		.byte	88
 9376              		.section	.bss.correctedRateVector,"aw",%nobits
 9377              		.align	2
 9378              		.set	.LANCHOR51,. + 0
 9381              	correctedRateVector:
 9382 0000 00000000 		.space	12
 9382      00000000 
 9382      00000000 
 9383              		.section	.data.numberOfMotors,"aw",%progbits
 9386              	numberOfMotors:
 9387 0000 04       		.byte	4
 9388              		.section	.bss.fiftyHZpreviousTime,"aw",%nobits
 9389              		.align	2
 9390              		.set	.LANCHOR85,. + 0
 9393              	fiftyHZpreviousTime:
 9394 0000 00000000 		.space	4
 9395              		.section	.bss.ezInt,"aw",%nobits
 9396              		.align	2
 9397              		.set	.LANCHOR47,. + 0
 9400              	ezInt:
 9401 0000 00000000 		.space	4
 9402              		.section	.bss.headingHoldState,"aw",%nobits
 9403              		.set	.LANCHOR73,. + 0
 9406              	headingHoldState:
 9407 0000 00       		.space	1
 9408              		.section	.rodata._ZL18ReceiverChannelMap,"a",%progbits
 9409              		.set	.LANCHOR10,. + 0
 9412              	_ZL18ReceiverChannelMap:
 9413 0000 00       		.byte	0
 9414 0001 01       		.byte	1
 9415 0002 03       		.byte	3
 9416 0003 02       		.byte	2
 9417 0004 04       		.byte	4
 9418 0005 05       		.byte	5
 9419 0006 06       		.byte	6
 9420 0007 07       		.byte	7
 9421 0008 08       		.byte	8
 9422 0009 09       		.byte	9
 9423              		.section	.rodata._ZL19stm32_motor_mapping,"a",%progbits
 9424              		.set	.LANCHOR53,. + 0
 9427              	_ZL19stm32_motor_mapping:
 9428 0000 29       		.byte	41
 9429 0001 28       		.byte	40
 9430 0002 27       		.byte	39
 9431 0003 26       		.byte	38
 9432 0004 0F       		.byte	15
 9433 0005 13       		.byte	19
 9434 0006 14       		.byte	20
 9435 0007 15       		.byte	21
 9436              		.section	.bss.motorCommand,"aw",%nobits
 9437              		.align	2
 9438              		.set	.LANCHOR54,. + 0
 9441              	motorCommand:
 9442 0000 00000000 		.space	32
 9442      00000000 
 9442      00000000 
 9442      00000000 
 9442      00000000 
 9443              		.section	.bss.accelSampleCount,"aw",%nobits
 9444              		.set	.LANCHOR32,. + 0
 9447              	accelSampleCount:
 9448 0000 00       		.space	1
 9449              		.section	.bss.eyInt,"aw",%nobits
 9450              		.align	2
 9451              		.set	.LANCHOR45,. + 0
 9454              	eyInt:
 9455 0000 00000000 		.space	4
 9456              		.section	.bss.previousEx,"aw",%nobits
 9457              		.align	2
 9458              		.set	.LANCHOR44,. + 0
 9461              	previousEx:
 9462 0000 00000000 		.space	4
 9463              		.section	.bss.previousEy,"aw",%nobits
 9464              		.align	2
 9465              		.set	.LANCHOR46,. + 0
 9468              	previousEy:
 9469 0000 00000000 		.space	4
 9470              		.section	.bss.heading,"aw",%nobits
 9471              		.align	2
 9472              		.set	.LANCHOR69,. + 0
 9475              	heading:
 9476 0000 00000000 		.space	4
 9477              		.section	.bss.oneHZpreviousTime,"aw",%nobits
 9478              		.align	2
 9481              	oneHZpreviousTime:
 9482 0000 00000000 		.space	4
 9483              		.section	.rodata.Serial,"a",%progbits
 9484              		.align	2
 9487              	Serial:
 9488 0000 00000000 		.word	SerialUSB
 9489              		.section	.bss.fastTransfer,"aw",%nobits
 9490              		.set	.LANCHOR81,. + 0
 9493              	fastTransfer:
 9494 0000 00       		.space	1
 9495              		.section	.bss.previousTime,"aw",%nobits
 9496              		.align	2
 9497              		.set	.LANCHOR83,. + 0
 9500              	previousTime:
 9501 0000 00000000 		.space	4
 9502              		.section	.bss.accelCutoff,"aw",%nobits
 9503              		.align	2
 9506              	accelCutoff:
 9507 0000 00000000 		.space	4
 9508              		.section	.bss.minLimit,"aw",%nobits
 9511              	minLimit:
 9512 0000 00       		.space	1
 9513              		.section	.data.testCommand,"aw",%progbits
 9514              		.align	2
 9515              		.set	.LANCHOR62,. + 0
 9518              	testCommand:
 9519 0000 E8030000 		.word	1000
 9520              		.section	.bss.relativeHeading,"aw",%nobits
 9521              		.align	2
 9522              		.set	.LANCHOR71,. + 0
 9525              	relativeHeading:
 9526 0000 00000000 		.space	4
 9527              		.section	.bss.q0,"aw",%nobits
 9528              		.align	2
 9529              		.set	.LANCHOR40,. + 0
 9532              	q0:
 9533 0000 00000000 		.space	4
 9534              		.section	.bss.q1,"aw",%nobits
 9535              		.align	2
 9536              		.set	.LANCHOR38,. + 0
 9539              	q1:
 9540 0000 00000000 		.space	4
 9541              		.section	.bss.q2,"aw",%nobits
 9542              		.align	2
 9543              		.set	.LANCHOR41,. + 0
 9546              	q2:
 9547 0000 00000000 		.space	4
 9548              		.section	.bss.q3,"aw",%nobits
 9549              		.align	2
 9550              		.set	.LANCHOR39,. + 0
 9553              	q3:
 9554 0000 00000000 		.space	4
 9555              		.section	.bss.accelSample,"aw",%nobits
 9556              		.align	2
 9557              		.set	.LANCHOR31,. + 0
 9560              	accelSample:
 9561 0000 00000000 		.space	12
 9561      00000000 
 9561      00000000 
 9562              		.section	.bss.tenHZpreviousTime,"aw",%nobits
 9563              		.align	2
 9566              	tenHZpreviousTime:
 9567 0000 00000000 		.space	4
 9568              		.section	.bss.receiverCommand,"aw",%nobits
 9569              		.align	2
 9570              		.set	.LANCHOR4,. + 0
 9573              	receiverCommand:
 9574 0000 00000000 		.space	40
 9574      00000000 
 9574      00000000 
 9574      00000000 
 9574      00000000 
 9575              		.section	.bss.currentChannel,"aw",%nobits
 9576              		.set	.LANCHOR1,. + 0
 9579              	currentChannel:
 9580 0000 00       		.space	1
 9581              		.section	.bss.accelScaleFactor,"aw",%nobits
 9582              		.align	2
 9583              		.set	.LANCHOR29,. + 0
 9586              	accelScaleFactor:
 9587 0000 00000000 		.space	12
 9587      00000000 
 9587      00000000 
 9588              		.section	.bss.setHeading,"aw",%nobits
 9589              		.align	2
 9590              		.set	.LANCHOR70,. + 0
 9593              	setHeading:
 9594 0000 00000000 		.space	4
 9595              		.section	.bss.aref,"aw",%nobits
 9596              		.align	2
 9597              		.set	.LANCHOR77,. + 0
 9600              	aref:
 9601 0000 00000000 		.space	4
 9602              		.section	.bss.headingHold,"aw",%nobits
 9603              		.align	2
 9604              		.set	.LANCHOR72,. + 0
 9607              	headingHold:
 9608 0000 00000000 		.space	4
 9609              		.section	.bss.maxLimit,"aw",%nobits
 9612              	maxLimit:
 9613 0000 00       		.space	1
 9614              		.section	.bss.frameCounter,"aw",%nobits
 9615              		.align	2
 9616              		.set	.LANCHOR75,. + 0
 9619              	frameCounter:
 9620 0000 00000000 		.space	4
 9621              		.section	.bss.Ki,"aw",%nobits
 9622              		.align	2
 9623              		.set	.LANCHOR43,. + 0
 9626              	Ki:
 9627 0000 00000000 		.space	4
 9628              		.section	.bss.receiverCommandSmooth,"aw",%nobits
 9629              		.align	2
 9630              		.set	.LANCHOR5,. + 0
 9633              	receiverCommandSmooth:
 9634 0000 00000000 		.space	40
 9634      00000000 
 9634      00000000 
 9634      00000000 
 9634      00000000 
 9635              		.section	.bss.minArmedThrottle,"aw",%nobits
 9636              		.align	2
 9637              		.set	.LANCHOR65,. + 0
 9640              	minArmedThrottle:
 9641 0000 00000000 		.space	4
 9642              		.section	.bss.Kp,"aw",%nobits
 9643              		.align	2
 9644              		.set	.LANCHOR49,. + 0
 9647              	Kp:
 9648 0000 00000000 		.space	4
 9649              		.section	.bss.headingTime,"aw",%nobits
 9650              		.align	2
 9651              		.set	.LANCHOR74,. + 0
 9654              	headingTime:
 9655 0000 00000000 		.space	4
 9656              		.section	.rodata.str1.1,"aMS",%progbits,1
 9657              	.LC0:
 9658 0000 3A2000   		.ascii	": \000"
 9659              	.LC1:
 9660 0003 4E6F7420 		.ascii	"Not \000"
 9660      00
 9661              	.LC2:
 9662 0008 536F6674 		.ascii	"Software Version: \000"
 9662      77617265 
 9662      20566572 
 9662      73696F6E 
 9662      3A2000
 9663              	.LC3:
 9664 001b 426F6172 		.ascii	"Board Type: \000"
 9664      64205479 
 9664      70653A20 
 9664      00
 9665              	.LC4:
 9666 0028 6165726F 		.ascii	"aeroquad32\000"
 9666      71756164 
 9666      333200
 9667              	.LC5:
 9668 0033 466C6967 		.ascii	"Flight Config: \000"
 9668      68742043 
 9668      6F6E6669 
 9668      673A2000 
 9669              	.LC6:
 9670 0043 51756164 		.ascii	"Quad X\000"
 9670      205800
 9671              	.LC7:
 9672 004a 52656365 		.ascii	"Receiver Channels: \000"
 9672      69766572 
 9672      20436861 
 9672      6E6E656C 
 9672      733A2000 
 9673              	.LC8:
 9674 005e 4D6F746F 		.ascii	"Motors: \000"
 9674      72733A20 
 9674      00
 9675              	.LC9:
 9676 0067 4779726F 		.ascii	"Gyroscope\000"
 9676      73636F70 
 9676      6500
 9677              	.LC10:
 9678 0071 44657465 		.ascii	"Detected\000"
 9678      63746564 
 9678      00
 9679              	.LC11:
 9680 007a 41636365 		.ascii	"Accelerometer\000"
 9680      6C65726F 
 9680      6D657465 
 9680      7200
 9681              	.LC12:
 9682 0088 4261726F 		.ascii	"Barometer\000"
 9682      6D657465 
 9682      7200
 9683              	.LC13:
 9684 0092 4D61676E 		.ascii	"Magnetometer\000"
 9684      65746F6D 
 9684      65746572 
 9684      00
 9685              	.LC14:
 9686 009f 48656164 		.ascii	"Heading Hold\000"
 9686      696E6720 
 9686      486F6C64 
 9686      00
 9687              	.LC15:
 9688 00ac 456E6162 		.ascii	"Enabled\000"
 9688      6C656400 
 9689              	.LC16:
 9690 00b4 416C7469 		.ascii	"Altitude Hold\000"
 9690      74756465 
 9690      20486F6C 
 9690      6400
 9691              	.LC17:
 9692 00c2 42617474 		.ascii	"Battery Monitor\000"
 9692      65727920 
 9692      4D6F6E69 
 9692      746F7200 
 9693              	.LC18:
 9694 00d2 43616D65 		.ascii	"Camera Stability\000"
 9694      72612053 
 9694      74616269 
 9694      6C697479 
 9694      00
 9695              	.LC19:
 9696 00e3 52616E67 		.ascii	"Range Detection\000"
 9696      65204465 
 9696      74656374 
 9696      696F6E00 
 9697              	.LC20:
 9698 00f3 4750533A 		.ascii	"GPS: Not Enabled\000"
 9698      204E6F74 
 9698      20456E61 
 9698      626C6564 
 9698      00
 9699              		.section	.bss.gyroRaw,"aw",%nobits
 9700              		.align	2
 9701              		.set	.LANCHOR24,. + 0
 9704              	gyroRaw:
 9705 0000 00000000 		.space	12
 9705      00000000 
 9705      00000000 
 9706              		.section	.data.throttle,"aw",%progbits
 9707              		.align	2
 9708              		.set	.LANCHOR55,. + 0
 9711              	throttle:
 9712 0000 E8030000 		.word	1000
 9713              		.section	.bss.gyroRate,"aw",%nobits
 9714              		.align	2
 9715              		.set	.LANCHOR21,. + 0
 9718              	gyroRate:
 9719 0000 00000000 		.space	12
 9719      00000000 
 9719      00000000 
 9720              		.section	.bss.PID,"aw",%nobits
 9721              		.align	2
 9722              		.set	.LANCHOR15,. + 0
 9725              	PID:
 9726 0000 00000000 		.space	192
 9726      00000000 
 9726      00000000 
 9726      00000000 
 9726      00000000 
 9727              		.section	.bss.kinematicsAngle,"aw",%nobits
 9728              		.align	2
 9729              		.set	.LANCHOR36,. + 0
 9732              	kinematicsAngle:
 9733 0000 00000000 		.space	12
 9733      00000000 
 9733      00000000 
 9734              		.section	.data.rawChannelValue,"aw",%progbits
 9735              		.align	1
 9736              		.set	.LANCHOR2,. + 0
 9739              	rawChannelValue:
 9740 0000 DC05     		.short	1500
 9741 0002 DC05     		.short	1500
 9742 0004 DC05     		.short	1500
 9743 0006 DC05     		.short	1500
 9744 0008 DC05     		.short	1500
 9745 000a DC05     		.short	1500
 9746 000c DC05     		.short	1500
 9747 000e DC05     		.short	1500
 9748 0010 DC05     		.short	1500
 9749 0012 DC05     		.short	1500
 9750              		.section	.data.previousFlightMode,"aw",%progbits
 9751              		.set	.LANCHOR78,. + 0
 9754              	previousFlightMode:
 9755 0000 01       		.byte	1
 9756              		.section	.bss.calibrateESC,"aw",%nobits
 9757              		.set	.LANCHOR61,. + 0
 9760              	calibrateESC:
 9761 0000 00       		.space	1
 9762              		.section	.bss.spiMPU6000,"aw",%nobits
 9763              		.align	2
 9764              		.set	.LANCHOR17,. + 0
 9767              	spiMPU6000:
 9768 0000 00000000 		.space	12
 9768      00000000 
 9768      00000000 
 9769              		.section	.bss.fourthOrder,"aw",%nobits
 9770              		.align	2
 9771              		.set	.LANCHOR16,. + 0
 9774              	fourthOrder:
 9775 0000 00000000 		.space	128
 9775      00000000 
 9775      00000000 
 9775      00000000 
 9775      00000000 
 9776              		.section	.bss.headingHoldConfig,"aw",%nobits
 9777              		.set	.LANCHOR68,. + 0
 9780              	headingHoldConfig:
 9781 0000 00       		.space	1
 9782              		.section	.bss.inFlight,"aw",%nobits
 9783              		.set	.LANCHOR14,. + 0
 9786              	inFlight:
 9787 0000 00       		.space	1
 9788              		.section	.bss.exInt,"aw",%nobits
 9789              		.align	2
 9790              		.set	.LANCHOR42,. + 0
 9793              	exInt:
 9794 0000 00000000 		.space	4
 9795              		.section	.bss.receiverXmitFactor,"aw",%nobits
 9796              		.align	2
 9797              		.set	.LANCHOR12,. + 0
 9800              	receiverXmitFactor:
 9801 0000 00000000 		.space	4
 9802              		.section	.bss.filteredAccel,"aw",%nobits
 9803              		.align	2
 9804              		.set	.LANCHOR82,. + 0
 9807              	filteredAccel:
 9808 0000 00000000 		.space	12
 9808      00000000 
 9808      00000000 
 9809              		.section	.bss.accelOneG,"aw",%nobits
 9810              		.align	2
 9811              		.set	.LANCHOR33,. + 0
 9814              	accelOneG:
 9815 0000 00000000 		.space	4
 9816              		.section	.bss.earthAccel,"aw",%nobits
 9817              		.align	2
 9820              	earthAccel:
 9821 0000 00000000 		.space	12
 9821      00000000 
 9821      00000000 
 9822              		.section	.bss.gyroLastMesuredTime,"aw",%nobits
 9823              		.align	2
 9824              		.set	.LANCHOR23,. + 0
 9827              	gyroLastMesuredTime:
 9828 0000 00000000 		.space	4
 9829              		.section	.bss.gyroSampleCount,"aw",%nobits
 9830              		.set	.LANCHOR27,. + 0
 9833              	gyroSampleCount:
 9834 0000 00       		.space	1
 9835              		.section	.bss.motorConfiguratorCommand,"aw",%nobits
 9836              		.align	2
 9837              		.set	.LANCHOR63,. + 0
 9840              	motorConfiguratorCommand:
 9841 0000 00000000 		.space	16
 9841      00000000 
 9841      00000000 
 9841      00000000 
 9842              		.section	.bss.halfT,"aw",%nobits
 9843              		.align	2
 9844              		.set	.LANCHOR37,. + 0
 9847              	halfT:
 9848 0000 00000000 		.space	4
 9849              		.section	.bss.motorMaxCommand,"aw",%nobits
 9850              		.align	2
 9851              		.set	.LANCHOR67,. + 0
 9854              	motorMaxCommand:
 9855 0000 00000000 		.space	16
 9855      00000000 
 9855      00000000 
 9855      00000000 
 9856              		.section	.bss.receiverZero,"aw",%nobits
 9857              		.align	2
 9858              		.set	.LANCHOR6,. + 0
 9861              	receiverZero:
 9862 0000 00000000 		.space	12
 9862      00000000 
 9862      00000000 
 9863              		.section	.bss.motorAxisCommandYaw,"aw",%nobits
 9864              		.align	2
 9865              		.set	.LANCHOR58,. + 0
 9868              	motorAxisCommandYaw:
 9869 0000 00000000 		.space	4
 9870              		.section	.bss.lowPriorityTenHZpreviousTime,"aw",%nobits
 9871              		.align	2
 9872              		.set	.LANCHOR86,. + 0
 9875              	lowPriorityTenHZpreviousTime:
 9876 0000 00000000 		.space	4
 9877              		.section	.bss.channelCal,"aw",%nobits
 9878              		.align	2
 9879              		.set	.LANCHOR80,. + 0
 9882              	channelCal:
 9883 0000 00000000 		.space	4
 9884              		.section	.bss.measureCriticalSensorsTime,"aw",%nobits
 9885              		.align	2
 9886              		.set	.LANCHOR34,. + 0
 9889              	measureCriticalSensorsTime:
 9890 0000 00000000 		.space	4
 9891              		.section	.bss.receiverOffset,"aw",%nobits
 9892              		.align	2
 9893              		.set	.LANCHOR8,. + 0
 9896              	receiverOffset:
 9897 0000 00000000 		.space	40
 9897      00000000 
 9897      00000000 
 9897      00000000 
 9897      00000000 
 9898              		.section	.bss.kinematicsType,"aw",%nobits
 9901              	kinematicsType:
 9902 0000 00       		.space	1
 9903              		.section	.bss.lastReceiverChannel,"aw",%nobits
 9904              		.align	2
 9905              		.set	.LANCHOR3,. + 0
 9908              	lastReceiverChannel:
 9909 0000 00000000 		.space	4
 9910              		.section	.bss.meterPerSecSec,"aw",%nobits
 9911              		.align	2
 9912              		.set	.LANCHOR28,. + 0
 9915              	meterPerSecSec:
 9916 0000 00000000 		.space	12
 9916      00000000 
 9916      00000000 
 9917              		.section	.bss.receiverSlope,"aw",%nobits
 9918              		.align	2
 9919              		.set	.LANCHOR7,. + 0
 9922              	receiverSlope:
 9923 0000 00000000 		.space	40
 9923      00000000 
 9923      00000000 
 9923      00000000 
 9923      00000000 
 9924              		.section	.bss.flightMode,"aw",%nobits
 9925              		.set	.LANCHOR59,. + 0
 9928              	flightMode:
 9929 0000 00       		.space	1
 9930              		.section	.bss.vehicleState,"aw",%nobits
 9931              		.align	2
 9932              		.set	.LANCHOR18,. + 0
 9935              	vehicleState:
 9936 0000 00000000 		.space	4
 9937              		.section	.bss.motorAxisCommandRoll,"aw",%nobits
 9938              		.align	2
 9939              		.set	.LANCHOR57,. + 0
 9942              	motorAxisCommandRoll:
 9943 0000 00000000 		.space	4
 9944              		.section	.bss.safetyCheck,"aw",%nobits
 9945              		.set	.LANCHOR64,. + 0
 9948              	safetyCheck:
 9949 0000 00       		.space	1
 9950              		.section	.bss.lowPriorityTenHZpreviousTime2,"aw",%nobits
 9951              		.align	2
 9952              		.set	.LANCHOR87,. + 0
 9955              	lowPriorityTenHZpreviousTime2:
 9956 0000 00000000 		.space	4
 9957              		.section	.data.G_Dt,"aw",%progbits
 9958              		.align	2
 9959              		.set	.LANCHOR50,. + 0
 9962              	G_Dt:
 9963 0000 6F12033B 		.word	990057071
 9964              		.section	.bss.hundredHZpreviousTime,"aw",%nobits
 9965              		.align	2
 9966              		.set	.LANCHOR84,. + 0
 9969              	hundredHZpreviousTime:
 9970 0000 00000000 		.space	4
 9971              		.section	.bss.gyroScaleFactor,"aw",%nobits
 9972              		.align	2
 9973              		.set	.LANCHOR20,. + 0
 9976              	gyroScaleFactor:
 9977 0000 00000000 		.space	4
 9978              		.section	.bss.gyroSample,"aw",%nobits
 9979              		.align	2
 9980              		.set	.LANCHOR26,. + 0
 9983              	gyroSample:
 9984 0000 00000000 		.space	12
 9984      00000000 
 9984      00000000 
 9985              		.section	.bss._ZL19_stm32_motor_number,"aw",%nobits
 9986              		.align	2
 9987              		.set	.LANCHOR52,. + 0
 9990              	_ZL19_stm32_motor_number:
 9991 0000 00000000 		.space	4
 9992              		.section	.bss.gyroZero,"aw",%nobits
 9993              		.align	2
 9994              		.set	.LANCHOR25,. + 0
 9997              	gyroZero:
 9998 0000 00000000 		.space	12
 9998      00000000 
 9998      00000000 
 9999              		.section	.bss.runTimeAccelBias,"aw",%nobits
 10000              		.align	2
 10001              		.set	.LANCHOR30,. + 0
 10004              	runTimeAccelBias:
 10005 0000 00000000 		.space	12
 10005      00000000 
 10005      00000000 
 10006              		.text
 10007              	.Letext0:
 10008              		.file 27 "c:\\users\\kenny\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 10009              		.file 28 "../Libmaple/libmaple/libmaple/libmaple_types.h"
 10010              		.file 29 "../Libmaple/libmaple/libmaple/rccF2.h"
 10011              		.file 30 "../Libmaple/libmaple/libmaple/gpioF2.h"
 10012              		.file 31 "../Libmaple/libmaple/libmaple/adc.h"
 10013              		.file 32 "../Libmaple/libmaple/wirish/wirish_types.h"
 10014              		.file 33 "../Libmaple/libmaple/wirish/io.h"
 10015              		.file 34 "../Libmaple/libmaple/libmaple/spi.h"
 10016              		.file 35 "../Libmaple/libmaple/wirish/comm/HardwareSPI.h"
 10017              		.file 36 "../Libmaple/libmaple/wirish/Print.h"
 10018              		.file 37 "../Libmaple/libmaple/wirish/wirish.h"
 10019              		.file 38 "../AeroQuad32/MapleCompatibility/WProgram.h"
 10020              		.file 39 "../Libmaple/libmaple/wirish/usb_serial.h"
 10021              		.file 40 "../AeroQuad32/MapleCompatibility/flash_stm32.h"
 10022              		.file 41 "../AeroQuad32/MapleCompatibility/EEPROM.h"
 10023              		.file 42 "../Libmaple/libmaple/libraries/Wire/Wire.h"
 10024              		.file 43 "../Libraries/AQ_Gps/GpsDataType.h"
 10025              		.file 44 "c:/Working/Aeroquad/AeroQuad32/../AeroQuad/AeroQuad.h"
 10026              		.file 45 "../Libmaple/libmaple/wirish/boards.h"
 10027              		.file 46 "../AeroQuad32/AeroQuad_STM32.h"
 10028              		.file 47 "../Libraries/AQ_Defines/SensorsStatus.h"
 10029              		.file 48 "../Libraries/AQ_Gyroscope/Gyroscope.h"
 10030              		.file 49 "../Libraries/AQ_Accelerometer/Accelerometer.h"
 10031              		.file 50 "../Libraries/AQ_FlightControlProcessor/FlightControlVariable.h"
 10032              		.file 51 "../Libraries/AQ_Math/AQMath.h"
 10033              		.file 52 "../Libmaple/libmaple/wirish/wirish_math.h"
 10034              		.file 53 "c:\\users\\kenny\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 10035              		.file 54 "c:\\users\\kenny\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 10036              		.file 55 "../Libmaple/libmaple/wirish/comm/HardwareSerial.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AeroQuadMain.cpp
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:20     .text._ZL6microsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:24     .text._ZL6microsv:00000000 _ZL6microsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:122    .text._ZL6microsv:00000038 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:128    .text._Z9FrqChangev:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:133    .text._Z9FrqChangev:00000000 _Z9FrqChangev
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:203    .text._Z9FrqChangev:0000004c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:211    .text.startup._Z7premainv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:216    .text.startup._Z7premainv:00000000 _Z7premainv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:232    .init_array:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:235    .text._init:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:240    .text._init:00000000 _init
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:252    .text._Z23initializeReceiverParami:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:257    .text._Z23initializeReceiverParami:00000000 _Z23initializeReceiverParami
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:423    .text._Z23initializeReceiverParami:00000090 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:434    .text._Z12readReceiverv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:439    .text._Z12readReceiverv:00000000 _Z12readReceiverv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:595    .text._Z12readReceiverv:000000d4 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:610    .text._Z17getReceiverSIDatah:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:615    .text._Z17getReceiverSIDatah:00000000 _Z17getReceiverSIDatah
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:640    .text._Z17getReceiverSIDatah:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:647    .text._Z9updatePIDffP7PIDdata:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:652    .text._Z9updatePIDffP7PIDdata:00000000 _Z9updatePIDffP7PIDdata
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:730    .text._Z9updatePIDffP7PIDdata:00000080 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:738    .text._Z17zeroIntegralErrorv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:743    .text._Z17zeroIntegralErrorv:00000000 _Z17zeroIntegralErrorv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:777    .text._Z17zeroIntegralErrorv:00000020 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:783    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:788    .text._Z18computeFourthOrderfP15fourthOrderData:00000000 _Z18computeFourthOrderfP15fourthOrderData
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:853    .text._Z18computeFourthOrderfP15fourthOrderData:00000088 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:864    .text._Z16setupFourthOrderv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:869    .text._Z16setupFourthOrderv:00000000 _Z16setupFourthOrderv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:931    .text._Z16setupFourthOrderv:00000038 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:937    .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:942    .text._ZN14HardwareSPIExt4ReadEiPhi:00000000 _ZN14HardwareSPIExt4ReadEiPhi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1013   .text._Z19MPU6000_SpiLowSpeedv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1018   .text._Z19MPU6000_SpiLowSpeedv:00000000 _Z19MPU6000_SpiLowSpeedv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1061   .text._Z19MPU6000_SpiLowSpeedv:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1068   .text._Z20MPU6000_SpiHighSpeedv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1073   .text._Z20MPU6000_SpiHighSpeedv:00000000 _Z20MPU6000_SpiHighSpeedv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1118   .text._Z20MPU6000_SpiHighSpeedv:0000002c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1125   .text._Z16MPU6000_WriteRegih:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1130   .text._Z16MPU6000_WriteRegih:00000000 _Z16MPU6000_WriteRegih
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1197   .text._Z16MPU6000_WriteRegih:00000038 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1202   .text._Z15MPU6000_ReadRegi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1207   .text._Z15MPU6000_ReadRegi:00000000 _Z15MPU6000_ReadRegi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1256   .text._Z15MPU6000_ReadRegi:00000020 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1261   .text._Z24initializeMPU6000Sensorsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1266   .text._Z24initializeMPU6000Sensorsv:00000000 _Z24initializeMPU6000Sensorsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1370   .text._Z24initializeMPU6000Sensorsv:00000080 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1377   .text._Z15MPU6000SwapDataPhi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1382   .text._Z15MPU6000SwapDataPhi:00000000 _Z15MPU6000SwapDataPhi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1425   .text._Z18readMPU6000Sensorsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1430   .text._Z18readMPU6000Sensorsv:00000000 _Z18readMPU6000Sensorsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1460   .text._Z18readMPU6000Sensorsv:0000001c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1466   .text._Z14initializeGyrov:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1471   .text._Z14initializeGyrov:00000000 _Z14initializeGyrov
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1494   .text._Z14initializeGyrov:0000000c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1501   .text._Z17gyroUpdateHeadingv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1506   .text._Z17gyroUpdateHeadingv:00000000 _Z17gyroUpdateHeadingv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1554   .text._Z17gyroUpdateHeadingv:00000054 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1565   .text._Z11measureGyrov:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1570   .text._Z11measureGyrov:00000000 _Z11measureGyrov
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1650   .text._Z11measureGyrov:0000006c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1660   .text._Z14measureGyroSumv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1665   .text._Z14measureGyroSumv:00000000 _Z14measureGyroSumv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1712   .text._Z14measureGyroSumv:00000038 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1720   .text._Z16evaluateGyroRatev:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1725   .text._Z16evaluateGyroRatev:00000000 _Z16evaluateGyroRatev
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1812   .text._Z16evaluateGyroRatev:00000078 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1822   .text._Z13calibrateGyrov:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1827   .text._Z13calibrateGyrov:00000000 _Z13calibrateGyrov
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1937   .text._Z13calibrateGyrov:00000070 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1943   .text._Z15initializeAccelv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1948   .text._Z15initializeAccelv:00000000 _Z15initializeAccelv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1961   .text._Z12measureAccelv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:1966   .text._Z12measureAccelv:00000000 _Z12measureAccelv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2021   .text._Z12measureAccelv:00000064 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2029   .text._Z15measureAccelSumv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2034   .text._Z15measureAccelSumv:00000000 _Z15measureAccelSumv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2067   .text._Z15measureAccelSumv:0000002c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2074   .text._Z20evaluateMetersPerSecv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2079   .text._Z20evaluateMetersPerSecv:00000000 _Z20evaluateMetersPerSecv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2147   .text._Z20evaluateMetersPerSecv:0000004c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2157   .text._Z16computeAccelBiasv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2162   .text._Z16computeAccelBiasv:00000000 _Z16computeAccelBiasv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2282   .text._Z16computeAccelBiasv:000000a8 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2295   .text._Z12initPlatformv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2300   .text._Z12initPlatformv:00000000 _Z12initPlatformv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2432   .text._Z12initPlatformv:000000b0 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2438   .text._Z42initializePlatformSpecificAccelCalibrationv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2443   .text._Z42initializePlatformSpecificAccelCalibrationv:00000000 _Z42initializePlatformSpecificAccelCalibrationv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2464   .text._Z42initializePlatformSpecificAccelCalibrationv:00000010 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2472   .text._Z22measureCriticalSensorsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2477   .text._Z22measureCriticalSensorsv:00000000 _Z22measureCriticalSensorsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2523   .text._Z22measureCriticalSensorsv:00000028 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2531   .text._Z29initializeBaseKinematicsParamv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2536   .text._Z29initializeBaseKinematicsParamv:00000000 _Z29initializeBaseKinematicsParamv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2559   .text._Z29initializeBaseKinematicsParamv:0000000c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2565   .text._Z27kinematicsGetDegreesHeadingh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2570   .text._Z27kinematicsGetDegreesHeadingh:00000000 _Z27kinematicsGetDegreesHeadingh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2603   .text._Z27kinematicsGetDegreesHeadingh:0000002c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2612   .text._Z9argUpdatefffffff:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2617   .text._Z9argUpdatefffffff:00000000 _Z9argUpdatefffffff
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2936   .text._Z9argUpdatefffffff:00000238 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2953   .text._Z11eulerAnglesv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:2958   .text._Z11eulerAnglesv:00000000 _Z11eulerAnglesv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3072   .text._Z11eulerAnglesv:000000f8 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3081   .text._Z20initializeKinematicsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3086   .text._Z20initializeKinematicsv:00000000 _Z20initializeKinematicsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3144   .text._Z20initializeKinematicsv:00000044 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3162   .text._Z19calculateKinematicsfffffff:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3167   .text._Z19calculateKinematicsfffffff:00000000 _Z19calculateKinematicsfffffff
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3202   .text._Z19calculateKinematicsfffffff:00000020 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3207   .text._Z13getGyroUnbiash:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3212   .text._Z13getGyroUnbiash:00000000 _Z13getGyroUnbiash
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3230   .text._Z13getGyroUnbiash:0000000c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3235   .text._Z19calibrateKinematicsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3240   .text._Z19calibrateKinematicsv:00000000 _Z19calibrateKinematicsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3252   .text._Z7FrqInitiP9timer_devi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3257   .text._Z7FrqInitiP9timer_devi:00000000 _Z7FrqInitiP9timer_devi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3374   .text._Z7FrqInitiP9timer_devi:00000090 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3381   .text._Z18InitFrqMeasurementv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3386   .text._Z18InitFrqMeasurementv:00000000 _Z18InitFrqMeasurementv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3441   .text._Z18InitFrqMeasurementv:00000040 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3449   .text._Z18initializeReceiveri:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3454   .text._Z18initializeReceiveri:00000000 _Z18initializeReceiveri
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3478   .text._Z18getRawChannelValueh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3483   .text._Z18getRawChannelValueh:00000000 _Z18getRawChannelValueh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3502   .text._Z18getRawChannelValueh:0000000c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3508   .text._Z15setChannelValuehi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3513   .text._Z15setChannelValuehi:00000000 _Z15setChannelValuehi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3526   .text._Z11writeMotorsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3531   .text._Z11writeMotorsv:00000000 _Z11writeMotorsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3604   .text._Z11writeMotorsv:00000030 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3612   .text._Z16commandAllMotorsi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3617   .text._Z16commandAllMotorsi:00000000 _Z16commandAllMotorsi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3686   .text._Z16commandAllMotorsi:0000002c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3693   .text._Z16initializeMotors9NB_Motors:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3698   .text._Z16initializeMotors9NB_Motors:00000000 _Z16initializeMotors9NB_Motors
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3866   .text._Z16initializeMotors9NB_Motors:00000088 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3875   .text._Z11pulseMotorsh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3880   .text._Z11pulseMotorsh:00000000 _Z11pulseMotorsh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3935   .text._Z17applyMotorCommandv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3940   .text._Z17applyMotorCommandv:00000000 _Z17applyMotorCommandv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:3997   .text._Z17applyMotorCommandv:00000034 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4006   .text._Z20calculateFlightErrorv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4011   .text._Z20calculateFlightErrorv:00000000 _Z20calculateFlightErrorv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4145   .text._Z20calculateFlightErrorv:000000e0 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4164   .text._Z19processCalibrateESCv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4169   .text._Z19processCalibrateESCv:00000000 _Z19processCalibrateESCv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4281   .text._Z19processCalibrateESCv:00000078 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4291   .text._Z25processThrottleCorrectionv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4296   .text._Z25processThrottleCorrectionv:00000000 _Z25processThrottleCorrectionv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4326   .text._Z25processThrottleCorrectionv:00000020 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4332   .text._Z20processHardManueversv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4337   .text._Z20processHardManueversv:00000000 _Z20processHardManueversv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4398   .text._Z20processHardManueversv:00000040 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4407   .text._Z20processMinMaxCommandv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4412   .text._Z20processMinMaxCommandv:00000000 _Z20processMinMaxCommandv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4511   .text._Z20processMinMaxCommandv:00000054 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4519   .text._Z14processHeadingv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4524   .text._Z14processHeadingv:00000000 _Z14processHeadingv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4735   .text._Z14processHeadingv:00000188 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4764   .text._Z20processFlightControlv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4769   .text._Z20processFlightControlv:00000000 _Z20processFlightControlv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4928   .text._Z20processFlightControlv:000000b0 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4944   .text._Z12nvrReadFloati:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4949   .text._Z12nvrReadFloati:00000000 _Z12nvrReadFloati
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4994   .text._Z12nvrReadFloati:00000028 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:4999   .text._Z13nvrWriteFloatfi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5004   .text._Z13nvrWriteFloatfi:00000000 _Z13nvrWriteFloatfi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5052   .text._Z13nvrWriteFloatfi:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5059   .text._Z11nvrReadLongi:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5064   .text._Z11nvrReadLongi:00000000 _Z11nvrReadLongi
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5107   .text._Z11nvrReadLongi:00000028 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5112   .text._Z12nvrWriteLongli:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5117   .text._Z12nvrWriteLongli:00000000 _Z12nvrWriteLongli
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5166   .text._Z12nvrWriteLongli:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5173   .text._Z10nvrReadPIDhj:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5178   .text._Z10nvrReadPIDhj:00000000 _Z10nvrReadPIDhj
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5230   .text._Z10nvrReadPIDhj:00000030 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5236   .text._Z11nvrWritePIDhj:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5241   .text._Z11nvrWritePIDhj:00000000 _Z11nvrWritePIDhj
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5288   .text._Z11nvrWritePIDhj:00000028 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5294   .text._Z10readEEPROMv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5299   .text._Z10readEEPROMv:00000000 _Z10readEEPROMv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5402   .text._Z10readEEPROMv:000000b0 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5412   .text._Z11writeEEPROMv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5417   .text._Z11writeEEPROMv:00000000 _Z11writeEEPROMv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5632   .text._Z11writeEEPROMv:00000158 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5655   .text._Z25initSensorsZeroFromEEPROMv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5660   .text._Z25initSensorsZeroFromEEPROMv:00000000 _Z25initSensorsZeroFromEEPROMv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5717   .text._Z25initSensorsZeroFromEEPROMv:00000050 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5724   .text._Z24storeSensorsZeroToEEPROMv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5729   .text._Z24storeSensorsZeroToEEPROMv:00000000 _Z24storeSensorsZeroToEEPROMv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5790   .text._Z24storeSensorsZeroToEEPROMv:00000054 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5797   .text._Z16initializeEEPROMv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5802   .text._Z16initializeEEPROMv:00000000 _Z16initializeEEPROMv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:5979   .text._Z16initializeEEPROMv:000000bc $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6006   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6011   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:00000000 _Z46processZeroThrottleFunctionFromReceiverCommandv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6144   .text._Z46processZeroThrottleFunctionFromReceiverCommandv:000000a0 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6154   .text._Z17readPilotCommandsv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6159   .text._Z17readPilotCommandsv:00000000 _Z17readPilotCommandsv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6236   .text._Z17readPilotCommandsv:0000005c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6246   .text._Z22initReceiverFromEEPROMv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6251   .text._Z22initReceiverFromEEPROMv:00000000 _Z22initReceiverFromEEPROMv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6323   .text._Z22initReceiverFromEEPROMv:00000050 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6331   .text._Z17initCommunicationv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6336   .text._Z17initCommunicationv:00000000 _Z17initCommunicationv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6349   .text._Z10getHeadingv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6354   .text._Z10getHeadingv:00000000 _Z10getHeadingv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6368   .text._Z10getHeadingv:00000008 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6373   .text._Z15readValueSerialPch:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6378   .text._Z15readValueSerialPch:00000000 _Z15readValueSerialPch
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6465   .text._Z15readValueSerialPch:0000004c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6471   .text._Z15readFloatSerialv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6476   .text._Z15readFloatSerialv:00000000 _Z15readFloatSerialv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6518   .text._Z16skipSerialValuesh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6523   .text._Z16skipSerialValuesh:00000000 _Z16skipSerialValuesh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6564   .text._Z13readSerialPIDh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6569   .text._Z13readSerialPIDh:00000000 _Z13readSerialPIDh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6614   .text._Z13readSerialPIDh:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6620   .text._Z24validateCalibrateCommandh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6625   .text._Z24validateCalibrateCommandh:00000000 _Z24validateCalibrateCommandh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6672   .text._Z24validateCalibrateCommandh:00000038 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6680   .text._Z17readSerialCommandv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6685   .text._Z17readSerialCommandv:00000000 _Z17readSerialCommandv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6719   .text._Z17readSerialCommandv:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:6766   .text._Z17readSerialCommandv:00000078 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7081   .text._Z17readSerialCommandv:00000204 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7098   .text._Z17readSerialCommandv:0000023c $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7148   .text._Z17readSerialCommandv:00000284 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7158   .text._Z17readIntegerSerialv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7163   .text._Z17readIntegerSerialv:00000000 _Z17readIntegerSerialv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7203   .text._Z5commav:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7208   .text._Z5commav:00000000 _Z5commav
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7225   .text._Z5commav:00000008 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7230   .text._Z15PrintValueCommal:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7235   .text._Z15PrintValueCommal:00000000 _Z15PrintValueCommal
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7263   .text._Z15PrintValueCommal:00000014 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7268   .text._Z15PrintValueCommah:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7273   .text._Z15PrintValueCommah:00000000 _Z15PrintValueCommah
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7301   .text._Z15PrintValueCommah:00000014 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7306   .text._Z15PrintValueCommam:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7311   .text._Z15PrintValueCommam:00000000 _Z15PrintValueCommam
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7339   .text._Z15PrintValueCommam:00000014 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7344   .text._Z15PrintValueCommai:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7349   .text._Z15PrintValueCommai:00000000 _Z15PrintValueCommai
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7377   .text._Z15PrintValueCommai:00000014 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7382   .text._Z16PrintDummyValuesh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7387   .text._Z16PrintDummyValuesh:00000000 _Z16PrintDummyValuesh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7429   .text._Z15PrintValueCommac:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7434   .text._Z15PrintValueCommac:00000000 _Z15PrintValueCommac
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7461   .text._Z15PrintValueCommac:00000014 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7466   .text._Z15PrintValueCommad:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7471   .text._Z15PrintValueCommad:00000000 _Z15PrintValueCommad
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7506   .text._Z15PrintValueCommad:0000001c $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7511   .text._Z15PrintValueCommaf:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7516   .text._Z15PrintValueCommaf:00000000 _Z15PrintValueCommaf
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7549   .text._Z15PrintValueCommaf:00000020 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7554   .text._Z8PrintPIDh:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7559   .text._Z8PrintPIDh:00000000 _Z8PrintPIDh
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7595   .text._Z8PrintPIDh:00000020 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7600   .text._Z17printVehicleStatePKcmS0_:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7605   .text._Z17printVehicleStatePKcmS0_:00000000 _Z17printVehicleStatePKcmS0_
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7659   .text._Z17printVehicleStatePKcmS0_:00000034 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7667   .text._Z18reportVehicleStatev:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7672   .text._Z18reportVehicleStatev:00000000 _Z18reportVehicleStatev
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7822   .text._Z18reportVehicleStatev:000000d8 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7848   .text._Z19sendSerialTelemetryv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:7853   .text._Z19sendSerialTelemetryv:00000000 _Z19sendSerialTelemetryv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8304   .text._Z19sendSerialTelemetryv:000002b4 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8324   .text._Z19sendSerialTelemetryv:000002fc $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8558   .text._Z19sendSerialTelemetryv:00000408 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8572   .text._Z5setupv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8577   .text._Z5setupv:00000000 _Z5setupv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8693   .text._Z5setupv:00000098 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8702   .text._Z16process100HzTaskv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8707   .text._Z16process100HzTaskv:00000000 _Z16process100HzTaskv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8805   .text._Z16process100HzTaskv:00000074 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8819   .text._Z15process50HzTaskv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8824   .text._Z15process50HzTaskv:00000000 _Z15process50HzTaskv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8853   .text._Z15process50HzTaskv:00000028 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8861   .text._Z16process10HzTask1v:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8866   .text._Z16process10HzTask1v:00000000 _Z16process10HzTask1v
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8878   .text._Z16process10HzTask2v:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8883   .text._Z16process10HzTask2v:00000000 _Z16process10HzTask2v
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8921   .text._Z16process10HzTask2v:00000030 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8929   .text._Z16process10HzTask3v:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8934   .text._Z16process10HzTask3v:00000000 _Z16process10HzTask3v
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8961   .text._Z16process10HzTask3v:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8969   .text._Z14process1HzTaskv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8974   .text._Z14process1HzTaskv:00000000 _Z14process1HzTaskv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8986   .text._Z4loopv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:8991   .text._Z4loopv:00000000 _Z4loopv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9089   .text._Z4loopv:00000080 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9100   .text.startup.main:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9105   .text.startup.main:00000000 main
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9129   .text.startup._GLOBAL__sub_I__Z7premainv:00000000 $t
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9133   .text.startup._GLOBAL__sub_I__Z7premainv:00000000 _GLOBAL__sub_I__Z7premainv
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9175   .text.startup._GLOBAL__sub_I__Z7premainv:00000024 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9374   .data.queryType:00000000 queryType
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9654   .bss.headingTime:00000000 headingTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9593   .bss.setHeading:00000000 setHeading
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9840   .bss.motorConfiguratorCommand:00000000 motorConfiguratorCommand
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9305   .bss.motorMinCommand:00000000 motorMinCommand
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9854   .bss.motorMaxCommand:00000000 motorMaxCommand
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9868   .bss.motorAxisCommandYaw:00000000 motorAxisCommandYaw
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9333   .bss.motorAxisCommandPitch:00000000 motorAxisCommandPitch
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9942   .bss.motorAxisCommandRoll:00000000 motorAxisCommandRoll
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9441   .bss.motorCommand:00000000 motorCommand
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9386   .data.numberOfMotors:00000000 numberOfMotors
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9347   .bss.FrqData:00000000 FrqData
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9579   .bss.currentChannel:00000000 currentChannel
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9739   .data.rawChannelValue:00000000 rawChannelValue
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9354   .bss.previousEz:00000000 previousEz
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9468   .bss.previousEy:00000000 previousEy
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9461   .bss.previousEx:00000000 previousEx
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9400   .bss.ezInt:00000000 ezInt
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9454   .bss.eyInt:00000000 eyInt
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9793   .bss.exInt:00000000 exInt
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9553   .bss.q3:00000000 q3
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9546   .bss.q2:00000000 q2
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9539   .bss.q1:00000000 q1
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9532   .bss.q0:00000000 q0
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9847   .bss.halfT:00000000 halfT
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9626   .bss.Ki:00000000 Ki
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9647   .bss.Kp:00000000 Kp
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9506   .bss.accelCutoff:00000000 accelCutoff
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9820   .bss.earthAccel:00000000 earthAccel
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9381   .bss.correctedRateVector:00000000 correctedRateVector
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9732   .bss.kinematicsAngle:00000000 kinematicsAngle
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9901   .bss.kinematicsType:00000000 kinematicsType
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9889   .bss.measureCriticalSensorsTime:00000000 measureCriticalSensorsTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9368   .bss.previousMeasureCriticalSensorsTime:00000000 previousMeasureCriticalSensorsTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9447   .bss.accelSampleCount:00000000 accelSampleCount
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9560   .bss.accelSample:00000000 accelSample
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9915   .bss.meterPerSecSec:00000000 meterPerSecSec
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9814   .bss.accelOneG:00000000 accelOneG
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:10004  .bss.runTimeAccelBias:00000000 runTimeAccelBias
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9586   .bss.accelScaleFactor:00000000 accelScaleFactor
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9833   .bss.gyroSampleCount:00000000 gyroSampleCount
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9827   .bss.gyroLastMesuredTime:00000000 gyroLastMesuredTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9312   .bss.gyroHeading:00000000 gyroHeading
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9976   .bss.gyroScaleFactor:00000000 gyroScaleFactor
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9983   .bss.gyroSample:00000000 gyroSample
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9997   .bss.gyroZero:00000000 gyroZero
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9718   .bss.gyroRate:00000000 gyroRate
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9767   .bss.spiMPU6000:00000000 spiMPU6000
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9285   .bss.MPU6000:00000000 MPU6000
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9935   .bss.vehicleState:00000000 vehicleState
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9704   .bss.gyroRaw:00000000 gyroRaw
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9487   .rodata.Serial:00000000 Serial
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9774   .bss.fourthOrder:00000000 fourthOrder
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9725   .bss.PID:00000000 PID
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9493   .bss.fastTransfer:00000000 fastTransfer
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9406   .bss.headingHoldState:00000000 headingHoldState
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9525   .bss.relativeHeading:00000000 relativeHeading
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9475   .bss.heading:00000000 heading
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9607   .bss.headingHold:00000000 headingHold
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9780   .bss.headingHoldConfig:00000000 headingHoldConfig
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9600   .bss.aref:00000000 aref
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9969   .bss.hundredHZpreviousTime:00000000 hundredHZpreviousTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9393   .bss.fiftyHZpreviousTime:00000000 fiftyHZpreviousTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9955   .bss.lowPriorityTenHZpreviousTime2:00000000 lowPriorityTenHZpreviousTime2
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9875   .bss.lowPriorityTenHZpreviousTime:00000000 lowPriorityTenHZpreviousTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9566   .bss.tenHZpreviousTime:00000000 tenHZpreviousTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9481   .bss.oneHZpreviousTime:00000000 oneHZpreviousTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9319   .bss.deltaTime:00000000 deltaTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9361   .bss.currentTime:00000000 currentTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9500   .bss.previousTime:00000000 previousTime
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9326   .data.rotationSpeedFactor:00000000 rotationSpeedFactor
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9786   .bss.inFlight:00000000 inFlight
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9807   .bss.filteredAccel:00000000 filteredAccel
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9511   .bss.minLimit:00000000 minLimit
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9612   .bss.maxLimit:00000000 maxLimit
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9948   .bss.safetyCheck:00000000 safetyCheck
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9298   .bss.motorArmed:00000000 motorArmed
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9711   .data.throttle:00000000 throttle
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9962   .data.G_Dt:00000000 G_Dt
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9640   .bss.minArmedThrottle:00000000 minArmedThrottle
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9619   .bss.frameCounter:00000000 frameCounter
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9928   .bss.flightMode:00000000 flightMode
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9754   .data.previousFlightMode:00000000 previousFlightMode
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9518   .data.testCommand:00000000 testCommand
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9760   .bss.calibrateESC:00000000 calibrateESC
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9882   .bss.channelCal:00000000 channelCal
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9340   .bss.receiverSmoothFactor:00000000 receiverSmoothFactor
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9896   .bss.receiverOffset:00000000 receiverOffset
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9922   .bss.receiverSlope:00000000 receiverSlope
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9633   .bss.receiverCommandSmooth:00000000 receiverCommandSmooth
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9573   .bss.receiverCommand:00000000 receiverCommand
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9861   .bss.receiverZero:00000000 receiverZero
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9292   .bss.receiverData:00000000 receiverData
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9800   .bss.receiverXmitFactor:00000000 receiverXmitFactor
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9908   .bss.lastReceiverChannel:00000000 lastReceiverChannel
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9281   .bss.MPU6000:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9288   .bss.receiverData:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9299   .bss.motorArmed:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9301   .bss.motorMinCommand:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9308   .bss.gyroHeading:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9315   .bss.deltaTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9322   .data.rotationSpeedFactor:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9329   .bss.motorAxisCommandPitch:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9336   .bss.receiverSmoothFactor:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9343   .bss.FrqData:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9350   .bss.previousEz:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9357   .bss.currentTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9364   .bss.previousMeasureCriticalSensorsTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9377   .bss.correctedRateVector:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9389   .bss.fiftyHZpreviousTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9396   .bss.ezInt:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9407   .bss.headingHoldState:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9412   .rodata._ZL18ReceiverChannelMap:00000000 _ZL18ReceiverChannelMap
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9427   .rodata._ZL19stm32_motor_mapping:00000000 _ZL19stm32_motor_mapping
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9437   .bss.motorCommand:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9448   .bss.accelSampleCount:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9450   .bss.eyInt:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9457   .bss.previousEx:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9464   .bss.previousEy:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9471   .bss.heading:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9478   .bss.oneHZpreviousTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9484   .rodata.Serial:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9494   .bss.fastTransfer:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9496   .bss.previousTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9503   .bss.accelCutoff:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9512   .bss.minLimit:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9514   .data.testCommand:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9521   .bss.relativeHeading:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9528   .bss.q0:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9535   .bss.q1:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9542   .bss.q2:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9549   .bss.q3:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9556   .bss.accelSample:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9563   .bss.tenHZpreviousTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9569   .bss.receiverCommand:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9580   .bss.currentChannel:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9582   .bss.accelScaleFactor:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9589   .bss.setHeading:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9596   .bss.aref:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9603   .bss.headingHold:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9613   .bss.maxLimit:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9615   .bss.frameCounter:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9622   .bss.Ki:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9629   .bss.receiverCommandSmooth:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9636   .bss.minArmedThrottle:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9643   .bss.Kp:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9650   .bss.headingTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9700   .bss.gyroRaw:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9707   .data.throttle:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9714   .bss.gyroRate:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9721   .bss.PID:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9728   .bss.kinematicsAngle:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9735   .data.rawChannelValue:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9761   .bss.calibrateESC:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9763   .bss.spiMPU6000:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9770   .bss.fourthOrder:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9781   .bss.headingHoldConfig:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9787   .bss.inFlight:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9789   .bss.exInt:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9796   .bss.receiverXmitFactor:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9803   .bss.filteredAccel:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9810   .bss.accelOneG:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9817   .bss.earthAccel:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9823   .bss.gyroLastMesuredTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9834   .bss.gyroSampleCount:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9836   .bss.motorConfiguratorCommand:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9843   .bss.halfT:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9850   .bss.motorMaxCommand:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9857   .bss.receiverZero:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9864   .bss.motorAxisCommandYaw:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9871   .bss.lowPriorityTenHZpreviousTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9878   .bss.channelCal:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9885   .bss.measureCriticalSensorsTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9892   .bss.receiverOffset:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9902   .bss.kinematicsType:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9904   .bss.lastReceiverChannel:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9911   .bss.meterPerSecSec:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9918   .bss.receiverSlope:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9929   .bss.flightMode:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9931   .bss.vehicleState:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9938   .bss.motorAxisCommandRoll:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9949   .bss.safetyCheck:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9951   .bss.lowPriorityTenHZpreviousTime2:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9958   .data.G_Dt:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9965   .bss.hundredHZpreviousTime:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9972   .bss.gyroScaleFactor:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9979   .bss.gyroSample:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9986   .bss._ZL19_stm32_motor_number:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9990   .bss._ZL19_stm32_motor_number:00000000 _ZL19_stm32_motor_number
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:9993   .bss.gyroZero:00000000 $d
C:\Users\Kenny\AppData\Local\Temp\ccYWCMNa.s:10000  .bss.runTimeAccelBias:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
systick_uptime_millis
_Z4initv
_Z12filterSmoothfff
_Z12digitalWritehh
_ZN11HardwareSPI8transferEh
_Z7pinModeh13WiringPinMode
_ZN11HardwareSPI5beginE12SPIFrequencyjj
_ZN11HardwareSPI3endEv
_Z5delaym
_Z21findMedianIntWithDiffPiiS_
_Z17delayMicrosecondsj
_ZN7TwoWire5beginEhh
Wire
__aeabi_f2d
__aeabi_d2f
sqrt
_Z10isSwitchedff
atan2
asin
rcc_dev_timer_clk_speed
gpio_set_mode
timer_attach_interrupt
PIN_MAP
_ZN11EEPROMClass4readEt
EEPROM
_ZN11EEPROMClass5writeEtt
_ZN9USBSerial9availableEv
_ZN9USBSerial4readEv
SerialUSB
memset
atof
atol
_ZN5Print5printEc
_ZN5Print5printEli
_ZN5Print5printEhi
_ZN5Print5printEmi
_ZN5Print5printEii
_ZN5Print5printEdi
_ZN5Print5printEPKc
_ZN5Print7printlnEPKc
_ZN5Print7printlnEii
_ZN5Print7printlnEdi
_ZN5Print7printlnEmi
_ZN5Print7printlnEv
_ZN9USBSerial5beginEi
_ZN11HardwareSPIC2Ej
_ZN11HardwareSPI6nssPinEv
